817
00:29:56,300 --> 00:30:00,233
我們可以告訴客戶我們已經載入了

818
00:30:00,233 --> 00:30:04,933
這些數據，如果我們有回應

819
00:30:04,933 --> 00:30:08,300
我們可以告訴客戶我們已經

820
00:30:08,300 --> 00:30:09,033
收到

821
00:30:09,033 --> 00:30:11,433
一個回應，並且此情況下的快取策略

822
00:30:11,433 --> 00:30:12,766
比如說不允許，我們不想要

823
00:30:12,766 --> 00:30:13,433
去快取

824
00:30:13,433 --> 00:30:16,633
對，我們不擔心那個，好的

825
00:30:16,633 --> 00:30:21,666
讓我們運行這個，並且它仍然通過

826
00:30:21,666 --> 00:30:23,733
非常完美，並且它更清晰，我更喜歡

827
00:30:23,733 --> 00:30:25,100
這樣的方式

828
00:30:25,100 --> 00:30:28,933
讓我們提交並添加新數據

829
00:30:28,933 --> 00:30:32,466
以及新回應至請求

830
00:30:32,466 --> 00:30:37,266
錯誤的測試案例以使設置過程

831
00:30:37,266 --> 00:30:40,933
更直接 看起來很不錯

832
00:30:40,933 --> 00:30:42,633
好的，我們在這個節目中已經完成了很多工作

833
00:30:42,633 --> 00:30:44,766
我認為我們終於找到了

834
00:30:44,766 --> 00:30:47,500
我們想要用於stubbing的答案

835
00:30:47,500 --> 00:30:48,366
請求

836
00:30:48,366 --> 00:30:50,533
我們不想要使用端對端測試

837
00:30:50,533 --> 00:30:51,500
在這個階段

838
00:30:51,500 --> 00:30:54,300
我們不想要使用subclassing 或者

839
00:30:54,300 --> 00:30:56,000
基於協議的模仿
