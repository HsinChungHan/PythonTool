238
00:08:52,233 --> 00:08:54,366
對，或者我們也可以使用 unowned

239
00:08:54,366 --> 00:08:56,366
參考，這將會是隱式地

240
00:08:56,366 --> 00:08:57,733
解包裝，對吧

241
00:08:57,733 --> 00:09:01,100
但這個 guard let 與使用 static method 有很大的不同

242
00:09:01,100 --> 00:09:03,600
它看起來一樣，但實際卻不是

243
00:09:03,600 --> 00:09:05,500
這背後還有更多的原理

244
00:09:05,500 --> 00:09:08,066
而不僅僅是將 self 變為弱引用

245
00:09:08,066 --> 00:09:08,800
self

246
00:09:08,800 --> 00:09:09,900
問題在於，當我們將某物做成弱引用並返回

247
00:09:09,900 --> 00:09:12,066
這意味著，如果該實例已被釋放

248
00:09:12,066 --> 00:09:13,833
則這個區塊將不會被執行

249
00:09:13,833 --> 00:09:16,000
但如果我使用

250
00:09:16,000 --> 00:09:19,500
這裡的 static method

251
00:09:19,500 --> 00:09:22,533
即使 RemoteFeed 的實例已被釋放

252
00:09:22,533 --> 00:09:25,100
Loader

253
00:09:25,100 --> 00:09:25,600
這個區塊仍可能被調用

254
00:09:25,600 --> 00:09:28,066
我們可能仍然會調用 completion

255
00:09:28,066 --> 00:09:28,800
對，因為我們不知道客戶端的

256
00:09:28,800 --> 00:09:30,233
實作。也許它是一個

257
00:09:30,233 --> 00:09:31,733
單例（Singleton）

258
00:09:31,733 --> 00:09:33,100
並且它的生命週期比 Remote

259
00:09:33,100 --> 00:09:33,900
FeedLoader 長

260
00:09:33,900 --> 00:09:35,666
對，沒錯

261
00:09:35,666 --> 00:09:38,233
這可能是一個 bug，因為

262
00:09:38,233 --> 00:09:39,733
因為這可能是一個問題點