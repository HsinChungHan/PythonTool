994
00:38:47,666 --> 00:38:50,133
讓我們看看測試是否可以訪問這個

995
00:38:50,133 --> 00:38:51,733
類型和一切都還在

996
00:38:51,733 --> 00:38:55,333
通過，好的，這真是太棒了

997
00:38:55,333 --> 00:38:59,100
讓我們提交移動URLSessionHTTP

998
00:38:59,100 --> 00:38:59,666
客戶端

999
00:38:59,666 --> 00:39:04,300
到它自己的檔案在生產中

1000
00:39:04,300 --> 00:39:06,866
太棒了，只是要展示一下抽象化的力量

1001
00:39:06,866 --> 00:39:07,733
抽象化

1002
00:39:07,733 --> 00:39:09,833
即使是您對實施的測試

1003
00:39:09,833 --> 00:39:11,833
詳細資料是我們可以很容易地

1004
00:39:11,833 --> 00:39:14,066
重構這個實現就是

1005
00:39:14,066 --> 00:39:16,233
一個擴充套件

1006
00:39:16,233 --> 00:39:19,566
在URLSession上

1007
00:39:19,566 --> 00:39:21,333
所以我們不需要使用這個 session

1008
00:39:21,333 --> 00:39:22,800
實例了，我們可以直接調用

1009
00:39:22,800 --> 00:39:24,700
它自身的方法

1010
00:39:24,700 --> 00:39:28,000
對，所以在我們的測試中，我們只是將

1011
00:39:28,000 --> 00:39:29,566
makeSUT替換為使用

1012
00:39:29,566 --> 00:39:32,800
URLSession的共享實例, 所以我準備

1013
00:39:32,800 --> 00:39:33,900
去移除跟蹤

1014
00:39:33,900 --> 00:39:35,733
記憶體洩漏，因為共享實例

1015
00:39:35,733 --> 00:39:38,066
永遠不會消失，它是一個單例

1016
00:39:38,066 --> 00:39:41,200
對，讓我們運行測試

1017
00:39:41,200 --> 00:39:43,100
如你所見它們仍然通過，看看

1018
00:39:43,100 --> 00:39:44,933
我們如何輕易地進行重構
