766
00:29:34,633 --> 00:29:35,500
這個框架

767
00:29:35,500 --> 00:29:38,633
曾經以 HTTP

768
00:29:38,633 --> 00:29:39,733
URLResponse

769
00:29:39,733 --> 00:29:41,600
傳達了 nil 數據，這實際上是有效的，因為這個框架

770
00:29:41,600 --> 00:29:43,100
替換了 nil 數據

771
00:29:43,100 --> 00:29:46,300
為空數據，這裡真正有一個

772
00:29:46,300 --> 00:29:48,933
數據實例，但是它的字節數是零

773
00:29:48,933 --> 00:29:51,433
我認為這是一個有效的情況

774
00:29:51,433 --> 00:29:52,866
對，但我不希望在同一次提交中處理這個問題

775
00:29:52,866 --> 00:29:53,900
在一次提交中

776
00:29:53,900 --> 00:29:56,300
所以我們可以做的一件事情就是檢查

777
00:29:56,300 --> 00:29:58,366
數據的字節，數量是否大於

778
00:29:58,366 --> 00:30:00,866
零，也就是說，它不是空的

779
00:30:00,866 --> 00:30:02,633
好，我同意這個觀點，我們不應

780
00:30:02,633 --> 00:30:04,633
提交失敗的測試

781
00:30:04,633 --> 00:30:07,200
我不見得需要注釋

782
00:30:07,200 --> 00:30:09,433
這個斷言或者整個測試

783
00:30:09,433 --> 00:30:11,733
或者所有的測試

784
00:30:11,733 --> 00:30:12,366
在那裡

785
00:30:12,366 --> 00:30:15,600
所以我喜歡這樣

786
00:30:15,600 --> 00:30:18,633
好，所以在 HTTP

787
00:30:18,633 --> 00:30:22,700
請求成功後，傳遞數據和

788
00:30:22,700 --> 00:30:26,233
URL response

789
00:30:26,233 --> 00:30:28,633
好，但顯然，我們不希望這個

790
00:30:28,633 --> 00:30:31,266
在這裡，對吧
