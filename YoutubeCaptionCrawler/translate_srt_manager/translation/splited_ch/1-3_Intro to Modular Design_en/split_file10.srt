245
00:08:14,633 --> 00:08:16,933
但保持邏輯的區分

246
00:08:16,933 --> 00:08:17,900
關注點

247
00:08:17,900 --> 00:08:20,000
所以如果你需要把它拆解

248
00:08:20,000 --> 00:08:21,333
這很容易，所以大型單體結構

249
00:08:21,333 --> 00:08:22,300
monolith

250
00:08:22,300 --> 00:08:24,000
並沒有什麼不對，只要你保持你的類型模組化

251
00:08:24,000 --> 00:08:25,900
在大型單體結構內，而且，如我們在

252
00:08:25,900 --> 00:08:27,266
上一集中見到的，你有相同的

253
00:08:27,266 --> 00:08:28,233
代碼量，

254
00:08:28,233 --> 00:08:30,466
你只是將它們拆分成小

255
00:08:30,466 --> 00:08:32,700
類或結構體或函數，

256
00:08:32,700 --> 00:08:35,100
並在它們之間保持乾淨的介面

257
00:08:35,100 --> 00:08:36,533
對，確實。

258
00:08:36,533 --> 00:08:38,766
然而，在這種大型單體結構的

259
00:08:38,766 --> 00:08:40,766
方法中最大的缺點，我想這是一種

260
00:08:40,766 --> 00:08:41,566
偏好問題，但

261
00:08:41,566 --> 00:08:43,500
如果你正在創建一個iOS項目，你將

262
00:08:43,500 --> 00:08:45,266
必須看模擬器，

263
00:08:45,266 --> 00:08:48,300
而，老實說，這讓我感到困擾，要透過

264
00:08:48,300 --> 00:08:49,100
測試

265
00:08:49,100 --> 00:08:51,333
API組件或數據庫組件

266
00:08:51,333 --> 00:08:52,633
透過模擬器，

267
00:08:52,633 --> 00:08:55,433
而不是將Mac作為一個測試

268
00:08:55,433 --> 00:08:56,366
目標並擁有