

1
00:00:01,333 --> 00:00:03,833
嗨，Mike，嘿，Caio

2
00:00:03,833 --> 00:00:06,633
所以上次我們開始了 URLSession

3
00:00:06,633 --> 00:00:08,233
HTTPClient

4
00:00:08,233 --> 00:00:10,466
在這門課程中我們將會繼續

5
00:00:10,466 --> 00:00:11,500
實現它

6
00:00:11,500 --> 00:00:13,333
這將是一個實戰的章節

7
00:00:13,333 --> 00:00:14,766
我們將會快速進行

8
00:00:14,766 --> 00:00:17,100
會向你顯示很多照著

9
00:00:17,100 --> 00:00:18,700
我們一直在進行的原則來撰寫的程式碼

10
00:00:18,700 --> 00:00:20,066
在整個案例研究中

11
00:00:20,066 --> 00:00:22,066
聽起來相當棒，好的首先我

12
00:00:22,066 --> 00:00:23,600
想要重新評估

13
00:00:23,600 --> 00:00:26,800
我們使用 stub 的選擇，透過

14
00:00:26,800 --> 00:00:27,266
顯示

15
00:00:27,266 --> 00:00:29,833
過度依賴 stubs 的缺點

16
00:00:29,833 --> 00:00:31,733
來測試我們期待的行為

17
00:00:31,733 --> 00:00:34,000
好的，那會是什麼呢，讓我們開始

18
00:00:34,000 --> 00:00:35,600
來讓這個測試失敗

19
00:00:35,600 --> 00:00:37,733
假設我們有一個錯誤的實現

20
00:00:37,733 --> 00:00:39,600
出乎意料的，用對了

21
00:00:39,600 --> 00:00:43,666
URL，讓我運行測試

22
00:00:43,666 --> 00:00:46,700
結果失敗了，完美

23
00:00:46,700 --> 00:00:49,500
對，但問題是，我們怎麽能找出

24
00:00:49,500 --> 00:00:50,066
出

25
00:00:50,066 --> 00:00:52,366
這個問題是 URL 對吧首先

26
00:00:52,366 --> 00:00:53,666
首先，我們得到的是

27
00:00:53,666 --> 00:00:56,233
一個網絡錯誤，這意味著我們實際上

28
00:00:56,233 --> 00:00:56,866
嘗試

29
00:00:56,866 --> 00:00:59,433
進行網絡請求，但它失敗了

30
00:00:59,433 --> 00:01:01,100
但是這個測試與

31
00:01:01,100 --> 00:01:02,700
URL 無關

32
00:01:02,700 --> 00:01:04,866
在設定中，我們用錯誤進行替換儲存，並預期得到這個錯誤

33
00:01:04,866 --> 00:01:06,700
我們預期會得到這個錯誤

34
00:01:06,700 --> 00:01:07,200
返回

35
00:01:07,200 --> 00:01:09,433
並且在這個斷定失敗中沒有任何東西

36
00:01:09,433 --> 00:01:11,733
告訴我們問題出在 URL 上

37
00:01:11,733 --> 00:01:14,133
我看，所以找出問題的唯一方法是進行

38
00:01:14,133 --> 00:01:15,433
代碼的調試

39
00:01:15,433 --> 00:01:17,266
我們的測試如果能夠更具體地指出問題在哪里

40
00:01:17,266 --> 00:01:19,200
就會變得更有價值，而不需要進行調試

41
00:01:19,200 --> 00:01:21,100
問題在哪裡，而不用調試

42
00:01:21,100 --> 00:01:21,600
它

43
00:01:21,600 --> 00:01:23,433
如果你必須調試才能找到測試

44
00:01:23,433 --> 00:01:25,500
失敗，那麼你就在減少測試的價值

45
00:01:25,500 --> 00:01:26,300
你的測試

46
00:01:26,300 --> 00:01:28,466
確實，而在這種情況下，問題是

47
00:01:28,466 --> 00:01:30,133
我們只替換儲存

48
00:01:30,133 --> 00:01:32,400
特定的 URL，所以如果 URL 不匹配

49
00:01:32,400 --> 00:01:33,900
我們正在告訴URL加載系統

50
00:01:33,900 --> 00:01:35,500
我們不會處理這個

51
00:01:35,500 --> 00:01:36,133
請求

52
00:01:36,133 --> 00:01:38,000
所以它會通過正常的URL

53
00:01:38,000 --> 00:01:40,233
處理生成一個真正的HTTP

54
00:01:40,233 --> 00:01:42,533
請求，所以我認為我們可以通過

55
00:01:42,533 --> 00:01:44,300
移除這個基於URL的

56
00:01:44,300 --> 00:01:46,233
仿製並截取所有的

57
00:01:46,233 --> 00:01:48,633
請求並添加一個單獨的測試

58
00:01:48,633 --> 00:01:49,833
來確保我們傳遞的是

59
00:01:49,833 --> 00:01:52,366
正確的URL，因此，如果URL測試

60
00:01:52,366 --> 00:01:54,466
失敗，我們就知道問題出在URL上，

61
00:01:54,466 --> 00:01:56,766
如果請求錯誤測試失敗，我們就知道

62
00:01:56,766 --> 00:01:57,733
這是由於

63
00:01:57,733 --> 00:02:00,000
URL請求的錯誤，因此我們需要區分

64
00:02:00,000 --> 00:02:01,100
這兩個問題

65
00:02:01,100 --> 00:02:03,733
這聽起來不錯，所以為了實現它，我們可以

66
00:02:03,733 --> 00:02:04,633
停止

67
00:02:04,633 --> 00:02:08,133
在我們的仿製中調查URL並且

68
00:02:08,133 --> 00:02:10,000
通過返回真值於canInit

69
00:02:10,000 --> 00:02:12,000
方法來截取所有請求

70
00:02:12,000 --> 00:02:14,000
因此我們不需要傳遞一個URL

71
00:02:14,000 --> 00:02:16,400
再也不需要當我們stub

72
00:02:16,400 --> 00:02:18,133
而現在我們的stub不再需要

73
00:02:18,133 --> 00:02:20,466
成為URL和Stubs的字典

74
00:02:20,466 --> 00:02:22,800
它可以只是一個stub，我們可以使

75
00:02:22,800 --> 00:02:24,400
它變成選擇性的，因為也許我們

76
00:02:24,400 --> 00:02:27,033
沒有stub，所以在設定

77
00:02:27,033 --> 00:02:28,000
stub方法時

78
00:02:28,000 --> 00:02:30,633
我們現在可以將stub數據分配給

79
00:02:30,633 --> 00:02:32,300
我們的stub物件

80
00:02:32,300 --> 00:02:35,266
當我們停止攔截時，我們會移除

81
00:02:35,266 --> 00:02:38,233
stub

82
00:02:38,233 --> 00:02:40,133
在啟動加載方法中，因為我們要

83
00:02:40,133 --> 00:02:41,666
處理所有的請求

84
00:02:41,666 --> 00:02:43,266
我們不需要再檢查URL

85
00:02:43,266 --> 00:02:46,633
只要我們有stub

86
00:02:46,633 --> 00:02:49,333
我們就將數據傳遞給URL

87
00:02:49,333 --> 00:02:50,866
加載系統

88
00:02:50,866 --> 00:02:52,633
否則我們只完成了沒有

89
00:02:52,633 --> 00:02:54,066
值的部分，好了

90
00:02:54,066 --> 00:02:58,466
讓我們改變這個測試

91
00:02:58,466 --> 00:03:00,533
所以測試現在通過了，這意味著

92
00:03:00,533 --> 00:03:02,000
我們正在攔截所有的請求

93
00:03:02,000 --> 00:03:04,133
不論URL如何，我們可以專注

94
00:03:04,133 --> 00:03:05,266
這些測試在

95
00:03:05,266 --> 00:03:07,833
處理錯誤，而非隱含的

96
00:03:07,833 --> 00:03:09,333
也在測試我們是否傳遞正確的

97
00:03:09,333 --> 00:03:10,133
URL

98
00:03:10,133 --> 00:03:11,200
我認為對我們來說這就足夠了以便

99
00:03:11,200 --> 00:03:13,566
提交之前，我們先進行下個對URL的

100
00:03:13,566 --> 00:03:16,066
測試，總結一下，我們在這裡主要做兩件事情

101
00:03:16,066 --> 00:03:16,800
事情

102
00:03:16,800 --> 00:03:20,000
A.我們永遠不會擊中網絡

103
00:03:20,000 --> 00:03:22,933
因為我們總是在攔截

104
00:03:22,933 --> 00:03:23,733
請求

105
00:03:23,733 --> 00:03:25,666
不論它們是否來自正確的

106
00:03:25,666 --> 00:03:26,766
URL

107
00:03:26,766 --> 00:03:29,433
以及2. 我們希望擁有準確的

108
00:03:29,433 --> 00:03:30,466
宣稱

109
00:03:30,466 --> 00:03:34,133
所以當一個測試失敗，我們想知道為什麼

110
00:03:34,133 --> 00:03:37,266
它會失敗， 所以我們增加這個值

111
00:03:37,266 --> 00:03:40,300
對我們的測試確切知道，好的

112
00:03:40,300 --> 00:03:42,233
聽起來不錯，所以我將進行提交到

113
00:03:42,233 --> 00:03:43,833
到目前為止的更改，但是我不會

114
00:03:43,833 --> 00:03:44,300
添加

115
00:03:44,300 --> 00:03:47,733
錯誤的URL，其他一切皆是

116
00:03:47,733 --> 00:03:51,266
所以我們做了 URLProtocolStub

117
00:03:51,266 --> 00:03:54,300
攔截每一個網路

118
00:03:54,300 --> 00:03:57,733
請求而不是URL

119
00:03:57,733 --> 00:04:01,100
基於模擬，因為我們不

120
00:04:01,100 --> 00:04:04,533
想要在測試期間進行任何網路

121
00:04:04,533 --> 00:04:08,000
請求，同時我們

122
00:04:08,000 --> 00:04:12,700
希望我們的斷言更加精確

123
00:04:12,700 --> 00:04:16,233
關於當它們失敗時的錯誤

124
00:04:16,233 --> 00:04:19,100
對，非常具有描述性，就像它應該的那樣

125
00:04:19,100 --> 00:04:19,600
好的

126
00:04:19,600 --> 00:04:21,833
但是通過進行這種改變，我們失去了

127
00:04:21,833 --> 00:04:22,800
查看URL的價值，但由於那是

128
00:04:22,800 --> 00:04:24,933
另一種煩惱 

129
00:04:24,933 --> 00:04:26,066
以更精確的斷言

130
00:04:26,066 --> 00:04:28,000
將其移至單獨的測試中

131
00:04:28,000 --> 00:04:29,666
進行測試會更好

132
00:04:29,666 --> 00:04:33,033
確切地說，我們可以單獨地進行測試

133
00:04:33,033 --> 00:04:36,066
所以從URL獲取進行

134
00:04:36,066 --> 00:04:39,600
GET請求帶URL，好的

135
00:04:39,600 --> 00:04:43,166
因此我們需要攔截請求

136
00:04:43,166 --> 00:04:47,033
也需要停止攔截請求

137
00:04:47,033 --> 00:04:50,400
我們需要做的是以某種方式觀察

138
00:04:50,400 --> 00:04:54,000
所有請求具有某種觀察者

139
00:04:54,000 --> 00:04:56,233
閉包對吧，我們可以得到一個請求

140
00:04:56,233 --> 00:04:58,933
然後我們可以運行我們的斷言

141
00:04:58,933 --> 00:05:02,133
例如請求URL是一個

142
00:05:02,133 --> 00:05:03,166
給定的URL


143
00:05:03,166 --> 00:05:06,400
我們可以測試該HTTP方法

144
00:05:06,400 --> 00:05:09,666
該請求是否為GET，讓我們來實現

145
00:05:09,666 --> 00:05:10,000
這個

146
00:05:10,000 --> 00:05:17,600
觀察者，觀察請求

147
00:05:17,600 --> 00:05:21,033
所以我們可以傳遞一個觀察者閉包

148
00:05:21,033 --> 00:05:23,166
這將會轉發所有的

149
00:05:23,166 --> 00:05:26,300
請求

150
00:05:26,300 --> 00:05:29,333
這是一個函數，並且我們可以捕捉

151
00:05:29,333 --> 00:05:34,133
閉包，所以它需要是逃逸的

152
00:05:34,133 --> 00:05:37,600
好的，我們可以定義我們的靜態

153
00:05:37,600 --> 00:05:40,700
變量 request observer，我們甚至可以

154
00:05:40,700 --> 00:05:41,733
使其為選擇性的

155
00:05:41,733 --> 00:05:44,300
就像我們對stub所做的那樣，不要

156
00:05:44,300 --> 00:05:45,433
忘記

157
00:05:45,433 --> 00:05:47,033
在我們停止時將其設定為nil

158
00:05:47,033 --> 00:05:49,166
攔截請求

159
00:05:49,166 --> 00:05:52,466
並且每當發起請求時

160
00:05:52,466 --> 00:05:54,233
我們可以調用觀察者並傳遞

161
00:05:54,233 --> 00:05:56,800
請求，就可以了

162
00:05:56,800 --> 00:05:59,733
好的，編譯器很高興，但我們需要

163
00:05:59,733 --> 00:06:00,700
定義一個

164
00:06:00,700 --> 00:06:03,333
URL，所以我猜我們可以直接複製上一個測試中的

165
00:06:03,333 --> 00:06:05,166
從先前的測試中

166
00:06:05,166 --> 00:06:06,533
並且由於該區塊會被呼叫

167
00:06:06,533 --> 00:06:08,400
異步執行，這樣比較好

168
00:06:08,400 --> 00:06:10,633
確保它被具有

169
00:06:10,633 --> 00:06:12,533
期待

170
00:06:12,533 --> 00:06:17,166
等待要求所以我們可以滿足

171
00:06:17,166 --> 00:06:19,166
在區塊結束後的期待

172
00:06:19,166 --> 00:06:20,400
聲明

173
00:06:20,400 --> 00:06:22,933
並等待具有

174
00:06:22,933 --> 00:06:24,133
超時

175
00:06:24,133 --> 00:06:26,533
我們需要呼叫我們的 get 方法

176
00:06:26,533 --> 00:06:27,733
準確地

177
00:06:27,733 --> 00:06:30,700
如果我們不呼叫 get 方法，則將永遠

178
00:06:30,700 --> 00:06:31,833
無法通過，所以我們用我們

179
00:06:31,833 --> 00:06:34,633
預期的 URL 呼叫它

180
00:06:34,633 --> 00:06:35,333
預期

181
00:06:35,333 --> 00:06:36,866
並可以傳遞一個空的完成

182
00:06:36,866 --> 00:06:39,333
區塊，所以如果我們用

183
00:06:39,333 --> 00:06:39,833
URL

184
00:06:39,833 --> 00:06:42,800
呼叫 get 方法，我們預期一個請求會被

185
00:06:42,800 --> 00:06:44,933
執行並使用正確的 URL 和方法

186
00:06:44,933 --> 00:06:46,633
我喜歡這個，我覺得這個測試

187
00:06:46,633 --> 00:06:48,066
非常完美地補充了

188
00:06:48,066 --> 00:06:50,466
前面的一個，如果它失敗，如你

189
00:06:50,466 --> 00:06:51,166
之前所說

190
00:06:51,166 --> 00:06:53,333
我們將收到一個量身定制的信息

191
00:06:53,333 --> 00:06:55,500
這裡明確顯示

192
00:06:55,500 --> 00:06:58,466
這個測試為什麼失敗，我們甚至可以顯示它

193
00:06:58,466 --> 00:06:58,933
失敗

194
00:06:58,933 --> 00:07:02,133
通過放回錯誤的 URL

195
00:07:02,133 --> 00:07:04,933
完美，告訴我們確切地在哪裡


196
00:07:04,933 --> 00:07:06,233
問題是

197
00:07:06,233 --> 00:07:09,666
那很好，好，我們來清除

198
00:07:09,666 --> 00:07:10,466
這個

199
00:07:10,466 --> 00:07:13,566
我們來整理一點點這裡的程式碼

200
00:07:13,566 --> 00:07:16,466
再執行一次測試，它成功了，所以我們

201
00:07:16,466 --> 00:07:18,466
已將測試的關注點分開

202
00:07:18,466 --> 00:07:20,866
請求的URL和處理的

203
00:07:20,866 --> 00:07:22,066
請求錯誤

204
00:07:22,066 --> 00:07:25,100
我喜歡這個點子，同意，所以保證

205
00:07:25,100 --> 00:07:28,133
正確的URL和HTTP

206
00:07:28,133 --> 00:07:31,333
在取得請求的方法

207
00:07:31,333 --> 00:07:33,166
所以我們可以使用相同的機制來測試

208
00:07:33,166 --> 00:07:35,500
POST請求，並且也查看

209
00:07:35,500 --> 00:07:36,866
請求的主體

210
00:07:36,866 --> 00:07:38,300
我們也可以查看請求的

211
00:07:38,300 --> 00:07:40,466
參數，任何與請求

212
00:07:40,466 --> 00:07:41,100
相關的

213
00:07:41,100 --> 00:07:43,433
我們關心的資料可以被斷言

214
00:07:43,433 --> 00:07:44,700
透過這些觀察者

215
00:07:44,700 --> 00:07:47,566
並且不用打網路，完全是

216
00:07:47,566 --> 00:07:49,333
這讓它們變得可靠且快速

217
00:07:49,333 --> 00:07:51,733
對，繼續下去，我看到一堆

218
00:07:51,733 --> 00:07:54,300
重覆的代碼在這裡

219
00:07:54,300 --> 00:07:57,266
對，我覺得該是時間，開始和

220
00:07:57,266 --> 00:07:59,266
停止方法的呼叫可以被移動

221
00:07:59,266 --> 00:08:01,733
對於設置和拆解，所以如果你

222
00:08:01,733 --> 00:08:02,633
對此不熟悉

223
00:08:02,633 --> 00:08:04,800
XCTestCase的setUp和tearDown

224
00:08:04,800 --> 00:08:05,666
方法

225
00:08:05,666 --> 00:08:08,400
對於每一個測試用例，都會調用

226
00:08:08,400 --> 00:08:08,933
setUp

227
00:08:08,933 --> 00:08:11,666
在每個測試方法前調用，然後

228
00:08:11,666 --> 00:08:12,933
調用tearDown

229
00:08:12,933 --> 00:08:15,566
在每個測試方法后調用，所以我們可以安全地

230
00:08:15,566 --> 00:08:16,233
進行

231
00:08:16,233 --> 00:08:18,866
開始和停止到setUp和tear

232
00:08:18,866 --> 00:08:19,833
Down方法

233
00:08:19,833 --> 00:08:22,700
對於這個測試，你也可以做同樣的事情，並且

234
00:08:22,700 --> 00:08:23,833
隨著你不斷添加測試，

235
00:08:23,833 --> 00:08:25,666
我們可以保證我們正在

236
00:08:25,666 --> 00:08:26,866
攔截請求

237
00:08:26,866 --> 00:08:30,633
在所有測試方法中，好的

238
00:08:30,633 --> 00:08:33,666
讓我們提交移動開始

239
00:08:33,666 --> 00:08:37,033
並停止攔截請求

240
00:08:37,033 --> 00:08:42,466
選擇setUp和tearDown方法

241
00:08:42,466 --> 00:08:45,266
好的，所以我們可以將sut創建移到

242
00:08:45,266 --> 00:08:46,366
makeSUT

243
00:08:46,366 --> 00:08:48,766
工廠，這樣我們可以保護我們的

244
00:08:48,766 --> 00:08:49,733
測試免於任何

245
00:08:49,733 --> 00:08:53,033
API變化，好的，所以我覺得我們甚至可以

246
00:08:53,033 --> 00:08:53,666
做到

247
00:08:53,666 --> 00:08:55,833
得出一行的結果，我認為可以創建

248
00:08:55,833 --> 00:08:57,433
sut

249
00:08:57,433 --> 00:09:00,700
我們也可以在這裡做同樣的事情，對吧？

250
00:09:00,700 --> 00:09:02,633
所以這保證了當我們繼續

251
00:09:02,633 --> 00:09:04,466
實現 URLSession，如果我們曾經

252
00:09:04,466 --> 00:09:06,800
必須更改其API，例如，

253
00:09:06,800 --> 00:09:08,633
在這裡添加一些依賴，我們

254
00:09:08,633 --> 00:09:10,466
不會破壞那些不關心

255
00:09:10,466 --> 00:09:12,000
這種依賴的測試。

256
00:09:12,000 --> 00:09:14,533
經典的工廠方法，我們在這裡還可以做的另一件事是

257
00:09:14,533 --> 00:09:15,733
我們可以在這裡做的另一件事

258
00:09:15,733 --> 00:09:19,333
返回 HTTPClient 協議

259
00:09:19,333 --> 00:09:22,366
URLSessionHTTPClient 應該

260
00:09:22,366 --> 00:09:22,800
去

261
00:09:22,800 --> 00:09:25,100
符合這個協議，但它還沒

262
00:09:25,100 --> 00:09:26,800
沒有，不幸的是

263
00:09:26,800 --> 00:09:29,433
但沒關係，我們會做一個心裡

264
00:09:29,433 --> 00:09:30,066
筆記

265
00:09:30,066 --> 00:09:32,366
並在最後來完成它，當我們

266
00:09:32,366 --> 00:09:33,833
實現該協議後，我們可以

267
00:09:33,833 --> 00:09:35,500
使工廠方法返回

268
00:09:35,500 --> 00:09:37,500
一種抽象，而不是具體

269
00:09:37,500 --> 00:09:39,600
實現類型，所以我們可以保护我們的測試免受

270
00:09:39,600 --> 00:09:41,100
實現細節的影響

271
00:09:41,100 --> 00:09:44,133
我真的很喜歡。所以讓我們移動

272
00:09:44,133 --> 00:09:47,433
URLSessionHTTPClient 該怎麽處理呢？


273
00:09:47,433 --> 00:09:51,200
正在測試的系統或者說

274
00:09:51,200 --> 00:09:54,866
sut的創建到一個工廠

275
00:09:54,866 --> 00:09:58,366
方法來保護我們的測試

276
00:09:58,366 --> 00:10:01,500
免於破壞性變化

277
00:10:01,500 --> 00:10:04,533
就是這樣，不錯。好的，既然我們正在做

278
00:10:04,533 --> 00:10:05,500
這個

279
00:10:05,500 --> 00:10:07,666
我們也可以增加記憶體洩漏

280
00:10:07,666 --> 00:10:09,500
跟蹤，就像我們在其他測試中所做的那樣

281
00:10:09,500 --> 00:10:12,633
是的，聽上去不錯。跟蹤記憶體洩漏

282
00:10:12,633 --> 00:10:14,866
我們有這個方法，我們在

283
00:10:14,866 --> 00:10:16,533
其他組件中使用過

284
00:10:16,533 --> 00:10:19,600
現在讓我們只是複製到這裡好了，我喜歡

285
00:10:19,600 --> 00:10:21,200
這種做法，我們可以分兩步進行

286
00:10:21,200 --> 00:10:24,066
所以我們能夠通過傳遞sut執行跟蹤記憶體洩漏

287
00:10:24,066 --> 00:10:25,433
文件和行編號，這樣我們可以在

288
00:10:25,433 --> 00:10:28,633
正確的地方得到一個很好的斷言

289
00:10:28,633 --> 00:10:30,300
意味著我們需要在makeSUT方法中獲取最後

290
00:10:30,300 --> 00:10:32,633
的行數

291
00:10:32,633 --> 00:10:34,633
就是這樣，這應該就足夠了。

292
00:10:34,633 --> 00:10:38,066
好的，讓我們提交並添加記憶體洩漏

293
00:10:38,066 --> 00:10:41,433
跟蹤。既然我們現在已經有了這

294
00:10:41,433 --> 00:10:44,866
跟蹤，所以我們要繼續的了。

295
00:10:44,866 --> 00:10:47,200
重複的方法我們可以移動它

296
00:10:47,200 --> 00:10:48,800
它已經在兩個測試檔案中使用了

297
00:10:48,800 --> 00:10:50,933
所以我很樂意去做這個

298
00:10:50,933 --> 00:10:52,633
所以讓我在

299
00:10:52,633 --> 00:10:54,700
測試目標中創建一個助手的文件夾

300
00:10:54,700 --> 00:10:58,800
然後我將創建一個XCTestCase

301
00:10:58,800 --> 00:11:03,900
MemoryLeakTracking 輔助器

302
00:11:03,900 --> 00:11:06,300
好的，現在讓我們在

303
00:11:06,300 --> 00:11:07,833
XCTestCase 上創建一個擴展

304
00:11:07,833 --> 00:11:11,433
並移動追蹤內存洩漏輔助器

305
00:11:11,433 --> 00:11:14,933
到共享範疇 我們現在可以移除

306
00:11:14,933 --> 00:11:20,066
以前的函數，很好

307
00:11:20,066 --> 00:11:22,866
現在來跑測試，好的，他們都

308
00:11:22,866 --> 00:11:25,266
通過了，我們來提交

309
00:11:25,266 --> 00:11:28,300
提取內存洩漏

310
00:11:28,300 --> 00:11:32,133
跟蹤助手方法至共享的

311
00:11:32,133 --> 00:11:36,866
XCTestCase上的擴展

312
00:11:36,866 --> 00:11:40,233
很好，您還看到了什麼嗎

313
00:11:40,233 --> 00:11:42,366
我認為與

314
00:11:42,366 --> 00:11:44,366
相同的字符串創建的URL，所以這可以放在一個

315
00:11:44,366 --> 00:11:46,000
助手函數中

316
00:11:46,000 --> 00:11:50,066
好的，因為這是一個URL

317
00:11:50,066 --> 00:11:52,466
我們可以創建一個工廠方法，我們可以

318
00:11:52,466 --> 00:11:53,666
甚至可以叫它任何

319
00:11:53,666 --> 00:11:56,800
URL，對，它提供了一些上下文情境

320
00:11:56,800 --> 00:12:00,066
在測試中也同樣能用，那就讓我們使用它

321
00:12:00,066 --> 00:12:05,600
在第一個測試和第二個測試中使用

322
00:12:05,600 --> 00:12:07,733
我們甚至可以直接移動它，我認為這裡的情況

323
00:12:07,733 --> 00:12:09,200
非常明確

324
00:12:09,200 --> 00:12:11,033
任何URL都無所謂，因為我們

325
00:12:11,033 --> 00:12:12,300
正在進行模擬，所以這無關緊要

326
00:12:12,300 --> 00:12:14,800
讓我們執行測試，看起來很整潔

327
00:12:14,800 --> 00:12:16,633
讓我們提交

328
00:12:16,633 --> 00:12:19,733
將URL的創建移至

329
00:12:19,733 --> 00:12:23,033
共享的工廠方法，非常好

330
00:12:23,033 --> 00:12:25,266
非常整潔，你可以看到作為流程的一部分，我們不斷地進行重構

331
00:12:25,266 --> 00:12:26,866
生產代碼和測試代碼

332
00:12:26,866 --> 00:12:29,333
確實如此

333
00:12:29,333 --> 00:12:30,000
我們正在保護我們的代碼及我們的

334
00:12:30,000 --> 00:12:32,300
理智

335
00:12:32,300 --> 00:12:33,033
透過這些變化，找出原因是因為它可能

336
00:12:33,033 --> 00:12:35,600
變得繁瑣，我們不想要那樣，我們

337
00:12:35,600 --> 00:12:36,066
想要

338
00:12:36,066 --> 00:12:38,066
主動

339
00:12:38,066 --> 00:12:39,333
並花幾分鐘來完成這些

340
00:12:39,333 --> 00:12:42,233
工作

341
00:12:42,233 --> 00:12:43,900
現在進行變化，這樣我們就不必

342
00:12:43,900 --> 00:12:44,866
稍後付出代價

343
00:12:44,866 --> 00:12:46,800
確切地說，一邊做一邊清理，這樣我們就不會

344
00:12:46,800 --> 00:12:48,633
積累出垃圾

345
00:12:48,633 --> 00:12:51,100
確切地說，讓我們繼續前進並實施

346
00:12:51,100 --> 00:12:53,600
錯誤的案例

347
00:12:53,600 --> 00:12:55,833
讓我帶來所有的

348
00:12:55,833 --> 00:12:58,233
錯誤案例在這裡

349
00:12:58,233 --> 00:13:01,033
讓我們在這裡騰出一點空間，這樣你就可以

350
00:13:01,033 --> 00:13:02,933
看到我們有一堆錯誤的案例

351
00:13:02,933 --> 00:13:05,100
可能永遠不會發生，但因為

352
00:13:05,100 --> 00:13:06,000
URL系統

353
00:13:06,000 --> 00:13:09,733
API把輸出表示為可選的

354
00:13:09,733 --> 00:13:12,300
例如通過組合Data, URL

355
00:13:12,300 --> 00:13:14,066
Response和Error，我們只關心

356
00:13:14,066 --> 00:13:15,266
存在Error且無響應和

357
00:13:15,266 --> 00:13:18,000
Data的案例

358
00:13:18,000 --> 00:13:18,633
以及我們有 Data 和 HTTPURL

359
00:13:18,633 --> 00:13:22,366
Response並且無 Error的案例

360
00:13:22,366 --> 00:13:24,233
如你所見，URLResponse是一個

361
00:13:24,233 --> 00:13:26,066
類別，而 HTTPURLResponse則是

362
00:13:26,066 --> 00:13:28,466
URLResponse的子類別


364
00:13:30,233 --> 00:13:33,600
那非常不幸，因為這增加了

365
00:13:33,600 --> 00:13:34,633
複雜性

366
00:13:34,633 --> 00:13:36,633
看所有這些情況基本上每

367
00:13:36,633 --> 00:13:38,133
每次有URLResponse我們需要

368
00:13:38,133 --> 00:13:38,700
檢查

369
00:13:38,700 --> 00:13:41,433
是否有HTTPURLResponse，因為

370
00:13:41,433 --> 00:13:43,333
它是URLResponse的子類型

371
00:13:43,333 --> 00:13:46,800
確實，所以由於

372
00:13:46,800 --> 00:13:48,633
子類型的關係，我們增加了

373
00:13:48,633 --> 00:13:51,033
無效場景的數量，所以我們可以認為

374
00:13:51,033 --> 00:13:53,333
我們信任這個架構，因為那些是

375
00:13:53,333 --> 00:13:55,433
結果應該永不出現

376
00:13:55,433 --> 00:13:57,433
但是由於它可以被表示並且

377
00:13:57,433 --> 00:13:59,166
這個架構有一些不透明的一面

378
00:13:59,166 --> 00:13:59,833
架構

379
00:13:59,833 --> 00:14:01,266
由於我們甚至不能看到

380
00:14:01,266 --> 00:14:02,933
這些類型的實現

381
00:14:02,933 --> 00:14:05,166
我們可以增加一些額外的測試以保證

382
00:14:05,166 --> 00:14:07,433
我們涵蓋了所有的邊緣情況

383
00:14:07,433 --> 00:14:09,900
所以在使用第三方API時，

384
00:14:09,900 --> 00:14:12,000
建議增加額外的測試

385
00:14:12,000 --> 00:14:14,466
來驗證假設，再者，當有

386
00:14:14,466 --> 00:14:15,833
一個新版本

387
00:14:15,833 --> 00:14:17,833
第三方框架我們正在使用

388
00:14:17,833 --> 00:14:19,733
我們可以愉快地進行升級，並保證

389
00:14:19,733 --> 00:14:20,700
framework的更改

390
00:14:20,700 --> 00:14:22,700
沒有破壞我們的假設和

391
00:14:22,700 --> 00:14:23,900
期望

392
00:14:23,900 --> 00:14:26,066
所以讓我們從第一個開始，

393
00:14:26,066 --> 00:14:27,900
無效的案例，我們得到

394
00:14:27,900 --> 00:14:30,300
nil，nil和nil分別為Data，URL

395
00:14:30,300 --> 00:14:32,066
Response和Error

396
00:14:32,066 --> 00:14:36,633
好，複製這個測試

397
00:14:36,633 --> 00:14:39,733
所以在

398
00:14:39,733 --> 00:14:44,000
所有nil值的情況下失敗，所以我們沒有錯誤

399
00:14:44,000 --> 00:14:46,933
數據為新的，響應為新的，錯誤為

400
00:14:46,933 --> 00:14:47,600
nil

401
00:14:47,600 --> 00:14:49,900
現在，我們無法針對任何種類的錯誤進行

402
00:14:49,900 --> 00:14:50,866
檢查

403
00:14:50,866 --> 00:14:53,833
在這種情況下，我們希望它失敗，

404
00:14:53,833 --> 00:14:54,233
但是，

405
00:14:54,233 --> 00:14:56,300
公平地說，因為這是一個無效的案例，我

406
00:14:56,300 --> 00:14:57,600
只希望它失敗，我不

407
00:14:57,600 --> 00:14:58,000
在乎

408
00:14:58,000 --> 00:15:00,366
哪種錯誤出現，沒有一種好的

409
00:15:00,366 --> 00:15:01,033
方式

410
00:15:01,033 --> 00:15:03,333
處理或恢復這個錯誤，

411
00:15:03,333 --> 00:15:04,133
除了

412
00:15:04,133 --> 00:15:07,733
重新嘗試，對，這是一個無效的案例，

413
00:15:07,733 --> 00:15:09,266
它永遠不應該發生。

414
00:15:09,266 --> 00:15:11,166
我們不想讓我們的測試被

415
00:15:11,166 --> 00:15:12,700
特定的錯誤類型污染

416
00:15:12,700 --> 00:15:15,500
我認為我們也不希望這款應用程式

417
00:15:15,500 --> 00:15:16,300
發生崩潰

418
00:15:16,300 --> 00:15:18,000
因為雖然這種情況不應該發生

419
00:15:18,000 --> 00:15:19,500
但它可能會發生

420
00:15:19,500 --> 00:15:21,033
所以它應該是一個失敗，使用者應該

421
00:15:21,033 --> 00:15:23,266
能夠重試，它不應該崩潰

422
00:15:23,266 --> 00:15:24,866
但我也不關心哪一種

423
00:15:24,866 --> 00:15:26,466
錯誤，因為這種情況應該是

424
00:15:26,466 --> 00:15:28,366
程序員的錯誤或者是框架

425
00:15:28,366 --> 00:15:32,466
的錯誤，所以讓我們來看看我們的測試應該會失敗

426
00:15:32,466 --> 00:15:35,900
是的，它失敗了，所以那應該很容易

427
00:15:35,900 --> 00:15:39,033
讓它通過，我們可以創建一個

428
00:15:39,033 --> 00:15:40,933
else條件並完成

429
00:15:40,933 --> 00:15:43,733
這裡有個失敗，有任何錯誤對吧

430
00:15:43,733 --> 00:15:45,833
然後我們可以在那裡創建我們自己的類型

431
00:15:45,833 --> 00:15:49,100
所以由於這是一個意想不到的情況

432
00:15:49,100 --> 00:15:52,000
我們可以創建一個意想不到的值

433
00:15:52,000 --> 00:15:53,033
表示

434
00:15:53,033 --> 00:15:57,100
對，完全正確，例如它可以是

435
00:15:57,100 --> 00:15:59,833
例如，可以指示符合於此的


436
00:15:59,833 --> 00:16:01,033
Swift Error protocol

437
00:16:01,033 --> 00:16:03,433
好的，我們來看看它是否通過，我猜應該可以

438
00:16:03,433 --> 00:16:04,533
我猜應該可以

439
00:16:04,533 --> 00:16:07,033
好的，它通過了，很好。所以在這個

440
00:16:07,033 --> 00:16:08,700
情況下，我們選擇不進行檢查

441
00:16:08,700 --> 00:16:10,866
具體的錯誤因為這是個

442
00:16:10,866 --> 00:16:13,266
無效的情境可以表示

443
00:16:13,266 --> 00:16:15,266
但如果你真的關心這

444
00:16:15,266 --> 00:16:16,800
情況你最好在

445
00:16:16,800 --> 00:16:20,000
你的測試中增加一個類型檢查，但我對

446
00:16:20,000 --> 00:16:20,800
這個滿意

447
00:16:20,800 --> 00:16:22,366
到目前為止，我們可以在

448
00:16:22,366 --> 00:16:25,100
未來改變我們的想法，那就提交吧

449
00:16:25,100 --> 00:16:28,466
傳遞未預期的值

450
00:16:28,466 --> 00:16:32,000
當請求完成時的錯誤

451
00:16:32,000 --> 00:16:35,033
伴隨著數據，響應和錯誤

452
00:16:35,033 --> 00:16:39,033
都為nil，好的，好像我們現在有

453
00:16:39,033 --> 00:16:41,033
兩個失敗案例的一些重複現象，為何我們不提取

454
00:16:41,033 --> 00:16:43,733
重複的代碼呢？

455
00:16:43,733 --> 00:16:45,833
重複的代碼

456
00:16:45,833 --> 00:16:48,133
我們在這裡有不同的設定，但是

457
00:16:48,133 --> 00:16:50,133
算法非常相似

458
00:16:50,133 --> 00:16:52,700
好的，所以我們可以將這個移動到一個助手

459
00:16:52,700 --> 00:16:53,733
方法

460
00:16:53,733 --> 00:16:57,333
對，所以結果

461
00:16:57,333 --> 00:17:00,700
數據的錯誤

462
00:17:00,700 --> 00:17:04,700
響應和錯誤 

463
00:17:04,700 --> 00:17:06,866
並且它應該返回錯誤，並且它的

464
00:17:06,866 --> 00:17:09,033
可選的，因為如果是成功的

465
00:17:09,033 --> 00:17:11,266
結果，我們沒有錯誤，對

466
00:17:11,266 --> 00:17:12,066
確實如此

467
00:17:12,066 --> 00:17:16,300
讓我複製這個設置

468
00:17:16,300 --> 00:17:18,000
看看我們需要更改什麼

469
00:17:18,000 --> 00:17:20,700
我們需要傳遞數據、響應

470
00:17:20,700 --> 00:17:23,666
和錯誤，我們等待完成

471
00:17:23,666 --> 00:17:24,633
這很好

472
00:17:24,633 --> 00:17:27,833
但現在我們需要捕獲錯誤

473
00:17:27,833 --> 00:17:31,833
所以receivedError是一個Error可選項

474
00:17:31,833 --> 00:17:36,066
讓我們獲取錯誤

475
00:17:36,066 --> 00:17:38,866
並在最後返回錯誤，所以我們

476
00:17:38,866 --> 00:17:40,400
需要保留失敗的

477
00:17:40,400 --> 00:17:43,100
斷言，以防我們得到一個

478
00:17:43,100 --> 00:17:44,300
成功

479
00:17:44,300 --> 00:17:46,866
但我們最好通過文件和行數

480
00:17:46,866 --> 00:17:49,033
因為這已經在助手中了

481
00:17:49,033 --> 00:17:51,666
並且將要多次被用到

482
00:17:51,666 --> 00:17:52,233
次

483
00:17:52,233 --> 00:17:54,300
從其他的測試中，我們想確切地知道

484
00:17:54,300 --> 00:17:55,833
我們在哪裡失敗

485
00:17:55,833 --> 00:17:58,066
否則這些測試就失去了

486
00:17:58,066 --> 00:17:59,433
它們的重要性

487
00:17:59,433 --> 00:18:02,233
並且由於makeSUT也期待

488
00:18:02,233 --> 00:18:03,266
檔案和行數

489
00:18:03,266 --> 00:18:05,266
以在

490
00:18:05,266 --> 00:18:07,200
正確地地方顯示失敗的斷言，我們最好將這個放入一個

491
00:18:07,200 --> 00:18:08,300
變數裡

492
00:18:08,300 --> 00:18:11,666
好，看起來像是我們需要的設置

493
00:18:11,666 --> 00:18:12,300
我們現在

494
00:18:12,300 --> 00:18:14,866
要重構測試來使用它

495
00:18:14,866 --> 00:18:16,400
所以在第一個測試

496
00:18:16,400 --> 00:18:18,533
我們無需再調用stub

497
00:18:18,533 --> 00:18:19,500
我們只需要獲取

498
00:18:19,500 --> 00:18:23,900
收到的錯誤

499
00:18:23,900 --> 00:18:27,433
當我們傳遞nil，nil和

500
00:18:27,433 --> 00:18:32,400
錯誤，然後我們可以保持斷言

501
00:18:32,400 --> 00:18:34,233
他們收到錯誤，但我們現在需要

502
00:18:34,233 --> 00:18:36,066
將其轉換為NSError，是的

503
00:18:36,066 --> 00:18:37,733
基本上它等於傳遞的

504
00:18:37,733 --> 00:18:38,933
錯誤，讓我們繼續給出

505
00:18:38,933 --> 00:18:41,433
更多可能的情況，例如說明請求

506
00:18:41,433 --> 00:18:42,000
錯誤

507
00:18:42,000 --> 00:18:44,400
很好，這與測試的名稱也相符

508
00:18:44,400 --> 00:18:45,333
對

509
00:18:45,333 --> 00:18:47,500
確切地說，失敗和請求結束了所以

510
00:18:47,500 --> 00:18:48,933
這裡是請求錯誤

511
00:18:48,933 --> 00:18:50,866
我們將錯誤傳遞給輔助函數

512
00:18:50,866 --> 00:18:52,633
我們期望收到的錯誤

513
00:18:52,633 --> 00:18:54,866
與請求錯誤相同

514
00:18:54,866 --> 00:18:56,766
讓我們看看是否通過

515
00:18:56,766 --> 00:18:59,666
它通過了，太棒了，那第二個

516
00:18:59,666 --> 00:19:00,700
 測試呢？

517
00:19:00,700 --> 00:19:02,766
由於我們不在乎錯誤的類型

518
00:19:02,766 --> 00:19:05,200
我們只在乎存在錯誤

519
00:19:05,200 --> 00:19:08,766
我們可以使用assert not nil輔助器

520
00:19:08,766 --> 00:19:12,133
通過將result error傳遞給數據

521
00:19:12,133 --> 00:19:15,333
nil，response，nil 和 error

522
00:19:15,333 --> 00:19:17,733
nil的匹配就是我們所關心的無效案例

523
00:19:17,733 --> 00:19:18,533
我們關心的

524
00:19:18,533 --> 00:19:22,300
到目前為止，讓我們看看是否通過

525
00:19:22,300 --> 00:19:24,700
它通過了，這是一個很好的重構

526
00:19:24,700 --> 00:19:25,333
看看這個

527
00:19:25,333 --> 00:19:28,066
測試方法現在簡單得多，我認為

528
00:19:28,066 --> 00:19:28,700
這是一個

529
00:19:28,700 --> 00:19:31,500
極具價值的重構，好的

530
00:19:31,500 --> 00:19:32,400
那麼

531
00:19:32,400 --> 00:19:36,000
讓我們提交提取重複的

532
00:19:36,000 --> 00:19:39,666
代碼到共享的，可重用的

533
00:19:39,666 --> 00:19:42,866
輔助方法以簡化

534
00:19:42,866 --> 00:19:47,266
測試。對，太棒了


535
00:19:47,266 --> 00:19:50,466
我們應該為每個

536
00:19:50,466 --> 00:19:52,700
無效的案例增加一個測試方法嗎？我認為我們可以將它們分組

537
00:19:52,700 --> 00:19:53,600
在一次測試中

538
00:19:53,600 --> 00:19:56,700
並命名為適用於所有

539
00:19:56,700 --> 00:19:59,433
無效的案例或類似的東西

540
00:19:59,433 --> 00:20:01,500
好的，所以所有的失敗

541
00:20:01,500 --> 00:20:04,933
在所有無效的表示案例上？對，我們可以

542
00:20:04,933 --> 00:20:06,000
在這裡添加所有斷言

543
00:20:06,000 --> 00:20:09,266
非常準確，所以這裡是給第二個

544
00:20:09,266 --> 00:20:09,833
無效的案例

545
00:20:09,833 --> 00:20:12,000
在這裡我們有新的數據，我們

546
00:20:12,000 --> 00:20:14,133
有回應，但它是未知的

547
00:20:14,133 --> 00:20:17,433
HTTPURLResponse 對，

548
00:20:17,433 --> 00:20:20,066
沒有錯誤，所以這是這裡的第二個案例，

549
00:20:20,066 --> 00:20:21,733
什麼是非

550
00:20:21,733 --> 00:20:25,333
HTTP 回應，它是一個 URLResponse

551
00:20:25,333 --> 00:20:28,133
我們在這裡創建一個，用任何 URL，

552
00:20:28,133 --> 00:20:29,500
讓我們使用我們的輔助方法

553
00:20:29,500 --> 00:20:31,266
我們不需要給一個 mime 類型

554
00:20:31,266 --> 00:20:33,266
內容長度或

555
00:20:33,266 --> 00:20:35,600
編碼，好的，這是第二種情況

556
00:20:35,600 --> 00:20:37,666
我們看看是否可以通過

557
00:20:37,666 --> 00:20:40,700
它做到了，太棒了，所以我們繼續前進

558
00:20:40,700 --> 00:20:41,833
在相同的提交中

559
00:20:41,833 --> 00:20:44,766
所以這裡我們有一個 HTTPURLResponse

560
00:20:44,766 --> 00:20:45,900
實際上，任何的

561
00:20:45,900 --> 00:20:48,533
任何，沒錯，HTTP響應應該產生

562
00:20:48,533 --> 00:20:49,433
這個錯誤所以

563
00:20:49,433 --> 00:20:54,533
讓我們在這裡建立我們的 HTTP回應

564
00:20:54,533 --> 00:20:58,766
所以我們又有了任何的URL，任何狀態代碼

565
00:20:58,766 --> 00:21:00,866
我們不需要其他的東西好了

566
00:21:00,866 --> 00:21:02,866
這應該也能通過

567
00:21:02,866 --> 00:21:06,400
太好了，下一個測試

568
00:21:06,400 --> 00:21:09,266
當我們有像任何資料一樣的資料但是

569
00:21:09,266 --> 00:21:10,400
其他的全都是空值

570
00:21:10,400 --> 00:21:12,466
這也是無效的情況，所以讓我

571
00:21:12,466 --> 00:21:15,666
建立我們的任何資料

572
00:21:15,666 --> 00:21:19,266
任何資料的值，它應該會通過

573
00:21:19,266 --> 00:21:22,700
因為它返回一個錯誤，太好了

574
00:21:22,700 --> 00:21:25,900
現在下一個情況是，我們有任何資料

575
00:21:25,900 --> 00:21:30,066
和一個錯誤，但是沒有回應

576
00:21:30,066 --> 00:21:33,266
好的，所以任何錯誤，讓我們說它是一個

577
00:21:33,266 --> 00:21:35,500
NSError，因為它容易創建

578
00:21:35,500 --> 00:21:38,533
任何錯誤，它應該會通過因為我們是

579
00:21:38,533 --> 00:21:40,300
在這種情況下返回一個錯誤

580
00:21:40,300 --> 00:21:43,600
也很好

581
00:21:43,600 --> 00:21:46,700
現在的情況是資料為空的時候我們

582
00:21:46,700 --> 00:21:49,666
有一個非 HTTPURLResponse

583
00:21:49,666 --> 00:21:51,733
而且我們有一個錯誤它也應該是

584
00:21:51,733 --> 00:21:54,066
無效的

585
00:21:54,066 --> 00:21:57,266
通過，移動到下一個案例

586
00:21:57,266 --> 00:22:00,466
我們有 nil數據我們有

587
00:22:00,466 --> 00:22:04,000
一個 HTTPURLResponse 但也伴隨一個

588
00:22:04,000 --> 00:22:04,400
錯誤

589
00:22:04,400 --> 00:22:07,733
這是無效的，所以我們應該通過

590
00:22:07,733 --> 00:22:11,333
太好了，好的，下一個案例我們有

591
00:22:11,333 --> 00:22:12,066
所有的東西

592
00:22:12,066 --> 00:22:15,600
我們有任何數據，我們有回應，但它是一個

593
00:22:15,600 --> 00:22:18,000
非 HTTPURLResponse而且我們有一個

594
00:22:18,000 --> 00:22:18,933
錯誤

595
00:22:18,933 --> 00:22:22,133
這也是無效的，應該通過

596
00:22:22,133 --> 00:22:25,666
太好了，相同的，但現在是一個

597
00:22:25,666 --> 00:22:28,933
HTTPURLResponse

598
00:22:28,933 --> 00:22:33,333
同樣也是無效的案例，太好了

599
00:22:33,333 --> 00:22:36,866
現在是最後一種情況，我們有

600
00:22:36,866 --> 00:22:41,333
數據，一個非 HTTPURLResponse

601
00:22:41,333 --> 00:22:43,900
並且沒有錯誤，這幾乎是正確的，對

602
00:22:43,900 --> 00:22:44,533
非常接近

603
00:22:44,533 --> 00:22:47,033
但唯一的問題是它不是一個

604
00:22:47,033 --> 00:22:47,900
HTTP

605
00:22:47,900 --> 00:22:51,033
URLResponse還不太對，好的

606
00:22:51,033 --> 00:22:52,766
他們全部通過了，所以我們在涵蓋

607
00:22:52,766 --> 00:22:54,633
所有無效情況現在

608
00:22:54,633 --> 00:22:58,233
好極了，讓我們提交結果

609
00:22:58,233 --> 00:23:02,233
所有無效或預期外的

610
00:23:02,233 --> 00:23:05,600
表示方式的錯誤，就這樣

611
00:23:05,600 --> 00:23:07,433
好的，最後我們將所有的

612
00:23:07,433 --> 00:23:08,866
無效情況都解決了

613
00:23:08,866 --> 00:23:10,533
關於這個框架的我們的假設進行確證

614
00:23:10,533 --> 00:23:12,133
對，沒錯

615
00:23:12,133 --> 00:23:14,300
但是我們可以將這些常數提取到

616
00:23:14,300 --> 00:23:15,733
輔助函數中嗎

617
00:23:15,733 --> 00:23:18,766
好的，這有點吵，不是嗎，我

618
00:23:18,766 --> 00:23:20,466
覺得是的

619
00:23:20,466 --> 00:23:24,866
所以我們可以創建anyData輔助函數

620
00:23:24,866 --> 00:23:30,933
返回數據

621
00:23:30,933 --> 00:23:34,833
所以現在我們可以隨處使用輔助函數

622
00:23:34,833 --> 00:23:38,233
你也可以這樣做

623
00:23:38,233 --> 00:23:43,100
處理錯誤

624
00:23:43,100 --> 00:23:45,100
由於這是NSError，所以我會

625
00:23:45,100 --> 00:23:46,766
稱其為anyNSError

626
00:23:46,766 --> 00:23:49,733
對，非常特定，但也可能是

627
00:23:49,733 --> 00:23:50,633
任何錯誤

628
00:23:50,633 --> 00:23:52,766
是的，確實如此，但我們對

629
00:23:52,766 --> 00:23:54,633
類型很明確，所以我們的命名也要明確

630
00:23:54,633 --> 00:23:56,533
同樣清楚

631
00:23:56,533 --> 00:23:59,600
好的，所以我們可以替換

632
00:23:59,600 --> 00:24:03,733
兩個內聯呼叫anyNSError

633
00:24:03,733 --> 00:24:07,600
輔助方法，好的，我們可以做相同的事情

634
00:24:07,600 --> 00:24:09,433
與HTTPURL

635
00:24:09,433 --> 00:24:13,033
回應anyHTTP的

636
00:24:13,033 --> 00:24:22,400
URLResponse

637
00:24:22,400 --> 00:24:24,233
為了完成，讓我們也做

638
00:24:24,233 --> 00:24:25,666
跟非的一樣

639
00:24:25,666 --> 00:24:32,933
HTTPURLResponse

640
00:24:32,933 --> 00:24:37,433
非HTTPURLResponse回傳一個URL

641
00:24:37,433 --> 00:24:45,200
回應

642
00:24:45,200 --> 00:24:48,233
跑一下測試，很好

643
00:24:48,233 --> 00:24:51,433
更乾淨了，讓我們提交

644
00:24:51,433 --> 00:24:54,933
提取創建測試用值

645
00:24:54,933 --> 00:24:59,200
為公用的工廠方法，就是這樣

646
00:24:59,200 --> 00:25:00,866
我們甚至可以在第一個

647
00:25:00,866 --> 00:25:03,200
測試中使用anyNSError

648
00:25:03,200 --> 00:25:05,333
對，所以在這種情況下，我們可以修改這個

649
00:25:05,333 --> 00:25:07,266
改變之前的提交

650
00:25:07,266 --> 00:25:10,766
我很樂意這麼做，因為這是

651
00:25:10,766 --> 00:25:11,600
唯一的更動

652
00:25:11,600 --> 00:25:14,533
我們可以將它加到階段，我們可以

653
00:25:14,533 --> 00:25:15,100
修訂

654
00:25:15,100 --> 00:25:18,766
到以前的提交，太好了

655
00:25:18,766 --> 00:25:21,100
好的，該來處理順利的路徑了

656
00:25:21,100 --> 00:25:22,866
好的，最後我們要處理的是

657
00:25:22,866 --> 00:25:24,066
有效的案例

658
00:25:24,066 --> 00:25:27,100
所以測試

659
00:25:27,100 --> 00:25:31,333
從URL獲取成功

660
00:25:31,333 --> 00:25:34,766
在HTTPURLResponse上用

661
00:25:34,766 --> 00:25:38,466
數據


662
00:25:38,466 --> 00:25:41,733
所以我們需要用

663
00:25:41,733 --> 00:25:43,200
一些數據

664
00:25:43,200 --> 00:25:46,466
以一個應答和沒有錯誤

665
00:25:46,466 --> 00:25:49,666
就像這個第一個有效的案例

666
00:25:49,666 --> 00:25:53,433
所以數據是 anyData 和回應

667
00:25:53,433 --> 00:25:56,933
也是 anyHTTPURLResponse

668
00:25:56,933 --> 00:26:00,000
準確地說,所以我們需要製作

669
00:26:00,000 --> 00:26:03,033
我們的sut並說從任何

670
00:26:03,033 --> 00:26:06,533
URL獲取結果

671
00:26:06,533 --> 00:26:09,100
讓我們切換結果,現在我們

672
00:26:09,100 --> 00:26:10,133
關心的是

673
00:26:10,133 --> 00:26:13,600
成功的情況，接收到的

674
00:26:13,600 --> 00:26:16,700
數據和收到的回應

675
00:26:16,700 --> 00:26:19,900
現在我們需要確定我們得到的

676
00:26:19,900 --> 00:26:22,066
正確的值,所以收到的數據應該

677
00:26:22,066 --> 00:26:23,333
是傳遞的

678
00:26:23,333 --> 00:26:26,533
數據和收到的

679
00:26:26,533 --> 00:26:30,066
應答應該是回應

680
00:26:30,066 --> 00:26:34,233
否則，對於任何其他情況我們應該失敗

681
00:26:34,233 --> 00:26:36,833
是的，我們預期成功，所以我們應該失敗

682
00:26:36,833 --> 00:26:38,000
在那裡

683
00:26:38,000 --> 00:26:41,033
所以預期成功，得到了結果

684
00:26:41,033 --> 00:26:45,200
相反，讓我們實現

685
00:26:45,200 --> 00:26:48,233
好的，所以它是異步的，我們需要

686
00:26:48,233 --> 00:26:50,400
跟隨相同的步驟

687
00:26:50,400 --> 00:26:53,900
等待完成

688
00:26:53,900 --> 00:26:57,900
並且實現之後

689
00:26:57,900 --> 00:27:00,933
我們的聲明，然後我們需要

690
00:27:00,933 --> 00:27:03,100
等待期待完成

691
00:27:03,100 --> 00:27:04,066
有一個超時時間

692
00:27:04,066 --> 00:27:06,633
太棒了，讓我們運行這個測試然後我們

693
00:27:06,633 --> 00:27:07,900
應該得到的是

694
00:27:07,900 --> 00:27:10,300
失敗的測試，對我們預期了成功

695
00:27:10,300 --> 00:27:11,733
但是它失敗了

696
00:27:11,733 --> 00:27:13,833
帶有意外值的表示

697
00:27:13,833 --> 00:27:15,500
因為我們尚未實現

698
00:27:15,500 --> 00:27:18,933
這種行為。好的，讓我們來做

699
00:27:18,933 --> 00:27:22,133
我們在這裡需要另一個else情況如果我們

700
00:27:22,133 --> 00:27:23,666
有數據

701
00:27:23,666 --> 00:27:27,266
並且我們有回應並且這個回應

702
00:27:27,266 --> 00:27:30,300
是一個HTTPURLResponse

703
00:27:30,300 --> 00:27:33,500
正確的，然後我們可以完成

704
00:27:33,500 --> 00:27:34,700
成功

705
00:27:34,700 --> 00:27:37,900
帶有數據和響應

706
00:27:37,900 --> 00:27:39,900
當然我們需要命名變量

707
00:27:39,900 --> 00:27:41,500
數據和回應

708
00:27:41,500 --> 00:27:45,600
傳遞給完成閉包

709
00:27:45,600 --> 00:27:47,733
噢，應該是過的，但我們得到了

710
00:27:47,733 --> 00:27:50,633
失敗的測試，我們來看看這個

711
00:27:50,633 --> 00:27:53,900
發生了什麼，我們有兩個失敗

712
00:27:53,900 --> 00:27:54,933
測試在這裡

713
00:27:54,933 --> 00:27:57,266
首先是當我們

714
00:27:57,266 --> 00:27:58,300
有nil的無效案例

715
00:27:58,300 --> 00:28:01,500
數據和HTTPURLResponse開始

716
00:28:01,500 --> 00:28:02,233
失敗

717
00:28:02,233 --> 00:28:04,366
嗯，我們需要調查這個，還有

718
00:28:04,366 --> 00:28:05,500
下一個就是

719
00:28:05,500 --> 00:28:07,100
我們沒有收到相同的回應

720
00:28:07,100 --> 00:28:08,700
讓我們看一下對吧

721
00:28:08,700 --> 00:28:12,133
所以NSHTTPURLResponse是一個類別

722
00:28:12,133 --> 00:28:14,700
我們已經討論過，而內部

723
00:28:14,700 --> 00:28:16,066
URL加載系統

724
00:28:16,066 --> 00:28:18,866
以某種方式替換了傳遞的回应

725
00:28:18,866 --> 00:28:20,466
用他們自己的回应在這裡

726
00:28:20,466 --> 00:28:22,300
所以它在比較指針，他們

727
00:28:22,300 --> 00:28:23,600
並不相同

728
00:28:23,600 --> 00:28:26,066
正如您所見，地址是

729
00:28:26,066 --> 00:28:26,700
不同的

730
00:28:26,700 --> 00:28:28,933
所以他們不相等因為當你

731
00:28:28,933 --> 00:28:31,200
比較類別時，他們經常比較

732
00:28:31,200 --> 00:28:32,000
指針

733
00:28:32,000 --> 00:28:34,766
所以我們可以只檢查價值，URL

734
00:28:34,766 --> 00:28:36,133
和狀態碼例如

735
00:28:36,133 --> 00:28:39,433
這就是我們現在所關心的好吧

736
00:28:39,433 --> 00:28:41,266
那有道理，那應該就足夠了

737
00:28:41,266 --> 00:28:42,933
讓我們確保我們得到

738
00:28:42,933 --> 00:28:46,066
全面的回應好，我們看看

739
00:28:46,066 --> 00:28:47,900
如果我們現在解決這個問題

740
00:28:47,900 --> 00:28:49,433
好的，我們正在接近正確的

741
00:28:49,433 --> 00:28:51,100
回應，只是那

742
00:28:51,100 --> 00:28:53,500
不知怎麼的，框架將其替換成了

743
00:28:53,500 --> 00:28:54,533
另一個例子

744
00:28:54,533 --> 00:28:56,066
但這些值仍然一樣，所以我

745
00:28:56,066 --> 00:28:58,000
對此感到滿意，現在讓我們看看

746
00:28:58,000 --> 00:28:58,766
這個故障

747
00:28:58,766 --> 00:29:00,300
這裡發生了什麼問題，錯誤是

748
00:29:00,300 --> 00:29:02,000
表明的是什麼？

749
00:29:02,000 --> 00:29:03,900
好吧，我們當然預期會有故障，但是

750
00:29:03,900 --> 00:29:05,033
我們得到的是成功

751
00:29:05,033 --> 00:29:08,133
具有零字節數據和一個

752
00:29:08,133 --> 00:29:08,866
回應

753
00:29:08,866 --> 00:29:12,066
好吧，所以我們認為

754
00:29:12,066 --> 00:29:13,666
這樣會產生一個無效的

755
00:29:13,666 --> 00:29:15,600
情境，但URL載入

756
00:29:15,600 --> 00:29:16,066
系統

757
00:29:16,066 --> 00:29:19,100
將我們的nil數據替換成了

758
00:29:19,100 --> 00:29:22,000
在這種情況下為零字節的空數據

759
00:29:22,000 --> 00:29:22,533
哪裡

760
00:29:22,533 --> 00:29:25,833
我們返回了一個有效的HTTPURLResponse

761
00:29:25,833 --> 00:29:26,366
對

762
00:29:26,366 --> 00:29:29,033
從我們的生產端完成成功

763
00:29:29,033 --> 00:29:30,366
對

764
00:29:30,366 --> 00:29:32,700
是的，所以我們認為這是一個無效的

765
00:29:32,700 --> 00:29:34,633
情境，如果這是的話，它將會是一個無效的情境

766
00:29:34,633 --> 00:29:35,500
這個框架

767
00:29:35,500 --> 00:29:38,633
曾經以 HTTP

768
00:29:38,633 --> 00:29:39,733
URLResponse

769
00:29:39,733 --> 00:29:41,600
傳達了 nil 數據，這實際上是有效的，因為這個框架

770
00:29:41,600 --> 00:29:43,100
替換了 nil 數據

771
00:29:43,100 --> 00:29:46,300
為空數據，這裡真正有一個

772
00:29:46,300 --> 00:29:48,933
數據實例，但是它的字節數是零

773
00:29:48,933 --> 00:29:51,433
我認為這是一個有效的情況

774
00:29:51,433 --> 00:29:52,866
對，但我不希望在同一次提交中處理這個問題

775
00:29:52,866 --> 00:29:53,900
在一次提交中

776
00:29:53,900 --> 00:29:56,300
所以我們可以做的一件事情就是檢查

777
00:29:56,300 --> 00:29:58,366
數據的字節，數量是否大於

778
00:29:58,366 --> 00:30:00,866
零，也就是說，它不是空的

779
00:30:00,866 --> 00:30:02,633
好，我同意這個觀點，我們不應

780
00:30:02,633 --> 00:30:04,633
提交失敗的測試

781
00:30:04,633 --> 00:30:07,200
我不見得需要注釋

782
00:30:07,200 --> 00:30:09,433
這個斷言或者整個測試

783
00:30:09,433 --> 00:30:11,733
或者所有的測試

784
00:30:11,733 --> 00:30:12,366
在那裡

785
00:30:12,366 --> 00:30:15,600
所以我喜歡這樣

786
00:30:15,600 --> 00:30:18,633
好，所以在 HTTP

787
00:30:18,633 --> 00:30:22,700
請求成功後，傳遞數據和

788
00:30:22,700 --> 00:30:26,233
URL response

789
00:30:26,233 --> 00:30:28,633
好，但顯然，我們不希望這個

790
00:30:28,633 --> 00:30:31,266
在這裡，對吧


791
00:30:31,266 --> 00:30:33,833
因此，這是無效的案例

792
00:30:33,833 --> 00:30:34,466
實際上是

793
00:30:34,466 --> 00:30:36,766
由框架使有效，所以讓我

794
00:30:36,766 --> 00:30:38,533
移除它並將其移到單獨的

795
00:30:38,533 --> 00:30:39,900
聲明，因為我們需要知道什麼是

796
00:30:39,900 --> 00:30:40,766
在此進行

797
00:30:40,766 --> 00:30:44,066
確定，因此讓我複製這個

798
00:30:44,066 --> 00:30:47,333
並重建這個情境，所以我們

799
00:30:47,333 --> 00:30:47,733
擁有

800
00:30:47,733 --> 00:30:51,900
一個HTTPURLResponse，但我們沒有任何數據

801
00:30:51,900 --> 00:30:55,033
所以我在這裡不需要這些數據，而我們

802
00:30:55,033 --> 00:30:56,233
預期

803
00:30:56,233 --> 00:30:59,733
在這種情況下將擁有空的數據，而此次測試是

804
00:30:59,733 --> 00:31:03,200
成功並帶有空的數據

805
00:31:03,200 --> 00:31:06,633
在 HTTPURLResponse 中帶有 nil 數據，好的

806
00:31:06,633 --> 00:31:08,066
這是我們對

807
00:31:08,066 --> 00:31:10,233
框架的假設，但被證明是錯誤的

808
00:31:10,233 --> 00:31:14,066
這就是添加測試的價值

809
00:31:14,066 --> 00:31:16,633
好的，由於我們的

810
00:31:16,633 --> 00:31:18,466
條件在這裡，所以沒有通過

811
00:31:18,466 --> 00:31:19,733
我不想要這個

812
00:31:19,733 --> 00:31:22,533
條件在這裡

813
00:31:22,533 --> 00:31:24,700
因為空的數據表示法是

814
00:31:24,700 --> 00:31:27,667
有效的表示法，例如

814
00:31:24,700 --> 00:31:26,533
有一個HTTP狀態代碼代表

815
00:31:26,533 --> 00:31:28,233
表示沒有內容數據

816
00:31:28,233 --> 00:31:31,266
這就是204狀態碼，所以空數據是一個

817
00:31:31,266 --> 00:31:32,633
有效的HTTP

818
00:31:32,633 --> 00:31:35,733
回應，所以我們最好加上測試

819
00:31:35,733 --> 00:31:37,500
去驗證我們對於

820
00:31:37,500 --> 00:31:38,766
框架的假設

821
00:31:38,766 --> 00:31:40,466
所以現在它通過了，我們刪除了

822
00:31:40,466 --> 00:31:41,900
條件判斷，太好了

823
00:31:41,900 --> 00:31:43,266
但我想對於這裡的數據有更多

824
00:31:43,266 --> 00:31:45,666
上下文了解

825
00:31:45,666 --> 00:31:49,666
所以讓我們創建一個空數據

826
00:31:49,666 --> 00:31:51,433
就是為了提供更多的上下文，我們正在

827
00:31:51,433 --> 00:31:53,500
確認這裡的數據是空數據

828
00:31:53,500 --> 00:31:55,600
符合測試的表示方法

829
00:31:55,600 --> 00:31:57,900
命名有助於開發者和有助於

830
00:31:57,900 --> 00:31:59,733
我們自己，如果我們未來需要維護

831
00:31:59,733 --> 00:32:00,933
這個測試的話

832
00:32:00,933 --> 00:32:02,633
確實，我們在這裡做得很好

833
00:32:02,633 --> 00:32:05,033
好吧，測試已經過了，所以讓我們

834
00:32:05,033 --> 00:32:06,633
進行提交

835
00:32:06,633 --> 00:32:09,200
你看得出來加入這些測試

836
00:32:09,200 --> 00:32:09,733
有多重要

837
00:32:09,733 --> 00:32:12,933
對真實的框架進行測試，所以傳遞

838
00:32:12,933 --> 00:32:16,000
空數據並響應

839
00:32:16,000 --> 00:32:19,433
對於成功的HTTP回應以

840
00:32:19,433 --> 00:32:23,033
nil數據，因為 URL 載入

841
00:32:23,033 --> 00:32:26,300
系統以

842
00:32:26,300 --> 00:32:30,066
已知的 nil 空數據值完成請求

843
00:32:30,066 --> 00:32:33,733
好吧，零位元組，對，這是一個有效的

844
00:32:33,733 --> 00:32:34,466
情況

845
00:32:34,466 --> 00:32:37,600
例如HTTP 204

846
00:32:37,600 --> 00:32:40,766
沒有內容回應非常棒，然後我們

847
00:32:40,766 --> 00:32:42,533
在我們的提交中留下一些文件

848
00:32:42,533 --> 00:32:43,733
信息

849
00:32:43,733 --> 00:32:47,033
解釋此情況，好的，並且既然

850
00:32:47,033 --> 00:32:47,733
我們有兩個

851
00:32:47,733 --> 00:32:50,733
成功的案例，它們共享代碼，所以

852
00:32:50,700 --> 00:32:52,000
我認為我們可以提取

853
00:32:52,000 --> 00:32:54,366
就像我們在失敗案例中所做的那樣共享代碼

854
00:32:54,366 --> 00:32:55,333
失敗的案例

855
00:32:55,333 --> 00:32:59,333
好的，所以我們可以創建另一個函數

856
00:32:59,333 --> 00:33:02,700
例如 結果

857
00:33:02,700 --> 00:33:05,833
就在這裡，我們將返回

858
00:33:05,833 --> 00:33:08,000
成功的案例

859
00:33:08,000 --> 00:33:09,333
所以我們將有我們將要返回的我們收到的

860
00:33:09,333 --> 00:33:11,266
值，那麼

861
00:33:11,266 --> 00:33:12,066
它的類型是什麼

862
00:33:12,066 --> 00:33:15,200
收到的值的類型是一個 Data 和

863
00:33:15,200 --> 00:33:18,366
HTTPURLResponse 組成的元組

864
00:33:18,366 --> 00:33:22,000
對，好的，所以讓我們

865
00:33:22,000 --> 00:33:24,733
在這裡改變我們的類型簽名，這是

866
00:33:24,700 --> 00:33:25,433
是的


867
00:33:25,433 --> 00:33:29,200
與數據和回應的成功案例

868
00:33:29,200 --> 00:33:32,933
所以收到的值將會是數據

869
00:33:32,933 --> 00:33:36,700
和回應，所以預期的是成功

870
00:33:36,700 --> 00:33:40,133
得到結果而非好的

871
00:33:40,133 --> 00:33:41,666
讓我們看看我們是否可以重構測試

872
00:33:41,666 --> 00:33:43,500
現在

873
00:33:43,500 --> 00:33:47,600
所以receivedValues 是結果的值為

874
00:33:47,600 --> 00:33:51,333
數據為空，回應和錯誤

875
00:33:51,333 --> 00:33:54,300
好的，就是這樣，現在讓我們替換它

876
00:33:54,300 --> 00:33:55,500
用stub

877
00:33:55,500 --> 00:34:00,133
我們可以直接抓取我們的斷言

878
00:34:00,133 --> 00:34:02,366
並且現在對比收到的

879
00:34:02,366 --> 00:34:03,200
值

880
00:34:03,200 --> 00:34:06,633
數據, 收到的值, 響應URL和

881
00:34:06,633 --> 00:34:07,900
接收到的值

882
00:34:07,900 --> 00:34:10,533
回應狀態碼，就是這樣，讓我們看看

883
00:34:10,533 --> 00:34:13,033
是否通過

884
00:34:13,033 --> 00:34:16,300
很棒，好的

885
00:34:16,300 --> 00:34:18,700
對於前一個測試我們可以做同樣的事

886
00:34:18,700 --> 00:34:20,000
讓我複製這個設置

887
00:34:20,000 --> 00:34:24,133
這裡，但現在我們正在傳送數據

888
00:34:24,133 --> 00:34:26,300
我們想要在這裡調查正確的

889
00:34:26,300 --> 00:34:29,033
數據

890
00:34:29,033 --> 00:34:32,866
所以給定的，當

891
00:34:32,866 --> 00:34:36,466
然後, 給定的，當

892
00:34:36,466 --> 00:34:39,833
然後，是的，看起來很乾淨，好的

893
00:34:39,833 --> 00:34:41,433
它通過了

894
00:34:41,433 --> 00:34:44,933
是的，但我認為我們現在在測試助手中有些重複的

895
00:34:44,933 --> 00:34:48,000
代碼，所以也許

896
00:34:48,000 --> 00:34:50,366
我們可以將這些共享的代碼提取到一個

897
00:34:50,366 --> 00:34:52,800
新的私有函數中

898
00:34:52,800 --> 00:34:56,300
好，那麼讓我們創建一個函數結果

899
00:34:56,300 --> 00:34:59,733
讓我複製這個簽名這裡

900
00:34:59,733 --> 00:35:01,566
但我們將返回結果

901
00:35:01,566 --> 00:35:03,500
現在的HTTPClient

902
00:35:03,500 --> 00:35:05,666
結果並不是可選的，因為你

903
00:35:05,666 --> 00:35:07,566
總是有結果的

904
00:35:07,566 --> 00:35:12,300
好，讓我複製這個設置在這裡

905
00:35:12,300 --> 00:35:13,900
所以我們並非收到錯誤，我們有的是

906
00:35:13,900 --> 00:35:16,000
收到結果

907
00:35:16,000 --> 00:35:18,000
我們將返回，而且

908
00:35:18,000 --> 00:35:19,566
結果是類型的

909
00:35:19,566 --> 00:35:22,466
ClientResult，由於我們還沒有

910
00:35:22,466 --> 00:35:23,166
值

911
00:35:23,166 --> 00:35:25,566
我們需要在類型定義中強行包裝它

912
00:35:25,566 --> 00:35:26,866
但在這種情況下這樣做是安全的

913
00:35:26,866 --> 00:35:28,533
因為我們總是能得到結果

914
00:35:28,533 --> 00:35:30,866
我們在這種情況下不關心斷言，我們只是得到結果

915
00:35:30,866 --> 00:35:32,400
我們在這種情況下不關心斷言，我們只是得到結果

916
00:35:32,400 --> 00:35:34,066
案例，我們只會得到結果

917
00:35:34,066 --> 00:35:36,400
我們執行並返回結果

918
00:35:36,400 --> 00:35:38,800
很好

919
00:35:38,800 --> 00:35:40,000
現在在這種情況下，我們需要獲得

920
00:35:40,000 --> 00:35:42,133
結果所以

921
00:35:42,133 --> 00:35:45,166
結果是為了解決

922
00:35:45,166 --> 00:35:48,533
數據、響應、錯誤

923
00:35:48,533 --> 00:35:52,000
文件和行，我們不需要再擺放

924
00:35:52,000 --> 00:35:53,500
了

925
00:35:53,500 --> 00:35:56,833
並且只捕捉錯誤，嗯，更簡單

926
00:35:56,833 --> 00:35:59,166
你甚至可以直接返回

927
00:35:59,166 --> 00:36:03,433
它在這裡

928
00:36:03,433 --> 00:36:06,466
而且我們在這種情況下返回 nil，因為

929
00:36:06,466 --> 00:36:07,333
我們沒有錯誤

930
00:36:07,333 --> 00:36:10,700
確切地說，它仍然在通過

931
00:36:10,700 --> 00:36:15,100
非常好，所以我們可以使用相同的設置

932
00:36:15,100 --> 00:36:18,866
對於我們成功的結果價值

933
00:36:18,866 --> 00:36:19,433
案例

934
00:36:19,433 --> 00:36:22,300
好的，我們不再需要這個，我們只需要

935
00:36:22,300 --> 00:36:23,900
返回

936
00:36:23,900 --> 00:36:27,200
成功的價值或 nil

937
00:36:27,200 --> 00:36:30,400
在任何其他情況下

938
00:36:30,400 --> 00:36:33,733
那應該做到了，太好了

939
00:36:33,733 --> 00:36:37,433
讓我們提交提取重複

940
00:36:37,433 --> 00:36:41,033
代碼到新的共享可重用

941
00:36:41,033 --> 00:36:44,800
輔助方法來簡化測試

942
00:36:44,800 --> 00:36:47,333
就是這樣，我想我們已經完成了

943
00:36:47,333 --> 00:36:48,633
所有的案例，對，我們


944
00:36:48,633 --> 00:36:50,400
確證了我們對於

945
00:36:50,400 --> 00:36:52,133
架構的假設

946
00:36:52,133 --> 00:36:54,466
留下如何使用該功能的

947
00:36:54,466 --> 00:36:55,500
文件跡象

948
00:36:55,500 --> 00:36:58,133
我認為這樣做是值得的，我們提到過

949
00:36:58,133 --> 00:36:59,266
你可以辯稱你不需要

950
00:36:59,266 --> 00:37:01,333
測試那些無效的情況

951
00:37:01,333 --> 00:37:03,266
如果你對框架有信心，但是我們由此

952
00:37:03,266 --> 00:37:04,633
對這個第三方框架學到了很多。

953
00:37:04,633 --> 00:37:07,266
透過檢驗我們的假設和期待

954
00:37:07,266 --> 00:37:09,733
我們對此有深入瞭解。

955
00:37:09,733 --> 00:37:12,000
確實，我認為這非常重要。

956
00:37:12,000 --> 00:37:13,733
它不僅僅是為了

957
00:37:13,733 --> 00:37:16,000
涵蓋你知道的那些邊緣情況，

958
00:37:16,000 --> 00:37:17,666
而實際看到如何

959
00:37:17,666 --> 00:37:20,533
操作和你不擁有的類別，以及

960
00:37:20,533 --> 00:37:21,266
他們的行為。

961
00:37:21,266 --> 00:37:24,700
基本上，我對我們的

962
00:37:24,700 --> 00:37:27,666
決定測試所有無效狀態感到非常滿意。

963
00:37:27,666 --> 00:37:28,066
因為

964
00:37:28,066 --> 00:37:31,666
他們可以如我們證明的那樣被表示出來。

965
00:37:31,666 --> 00:37:34,300
沒錯，所以現在我們可以使URL

966
00:37:34,300 --> 00:37:35,100
Session

967
00:37:35,100 --> 00:37:37,833
符合 HTTPClient 協議。 

968
00:37:37,833 --> 00:37:38,700
既然我們已經完成了 

969
00:37:38,700 --> 00:37:40,466
實施部分。

970
00:37:40,466 --> 00:37:42,633
好的，如果你還記得我們的心理筆記

971
00:37:42,633 --> 00:37:45,500
我們將讓 makeSUT

972
00:37:45,500 --> 00:37:48,633
函數返回抽象，是的

973
00:37:48,633 --> 00:37:50,233
並且它應該仍然通過，因為我們

974
00:37:50,233 --> 00:37:52,000
不希望測試依賴

975
00:37:52,000 --> 00:37:54,700
太多的實施細節

976
00:37:54,700 --> 00:37:55,333
很棒

977
00:37:55,333 --> 00:37:59,333
看看，讓我們提交 make

978
00:37:59,333 --> 00:38:02,400
URLSessionHTTPClient

979
00:38:02,400 --> 00:38:05,833
符合 HTTPClient

980
00:38:05,833 --> 00:38:09,433
協議，好的，既然這已經完成，我們

981
00:38:09,433 --> 00:38:10,800
可以將它移至

982
00:38:10,800 --> 00:38:13,100
它自己的文件中，所以讓我把

983
00:38:13,100 --> 00:38:24,800
這個表格刪除，我們現在不再需要它

984
00:38:24,800 --> 00:38:28,466
好的，這就是它，現在是訪問控制

985
00:38:28,466 --> 00:38:31,566
這是一個公共類，公共

986
00:38:31,566 --> 00:38:33,500
初始化器

987
00:38:33,500 --> 00:38:35,333
這個結構，我們不需要暴露它

988
00:38:35,333 --> 00:38:36,800
還沒有，所以

989
00:38:36,800 --> 00:38:38,533
讓我們讓它保持私有，直到我們需要它

990
00:38:38,533 --> 00:38:40,066
被暴露

991
00:38:40,066 --> 00:38:43,666
我同意，是的，並且 get 函數是

992
00:38:43,666 --> 00:38:44,633
公開的

993
00:38:44,633 --> 00:38:47,666
作為 HTTPClient 界面的一部分

994
00:38:47,666 --> 00:38:50,133
讓我們看看測試是否可以訪問這個

995
00:38:50,133 --> 00:38:51,733
類型和一切都還在

996
00:38:51,733 --> 00:38:55,333
通過，好的，這真是太棒了

997
00:38:55,333 --> 00:38:59,100
讓我們提交移動URLSessionHTTP

998
00:38:59,100 --> 00:38:59,666
客戶端

999
00:38:59,666 --> 00:39:04,300
到它自己的檔案在生產中

1000
00:39:04,300 --> 00:39:06,866
太棒了，只是要展示一下抽象化的力量

1001
00:39:06,866 --> 00:39:07,733
抽象化

1002
00:39:07,733 --> 00:39:09,833
即使是您對實施的測試

1003
00:39:09,833 --> 00:39:11,833
詳細資料是我們可以很容易地

1004
00:39:11,833 --> 00:39:14,066
重構這個實現就是

1005
00:39:14,066 --> 00:39:16,233
一個擴充套件

1006
00:39:16,233 --> 00:39:19,566
在URLSession上

1007
00:39:19,566 --> 00:39:21,333
所以我們不需要使用這個 session

1008
00:39:21,333 --> 00:39:22,800
實例了，我們可以直接調用

1009
00:39:22,800 --> 00:39:24,700
它自身的方法

1010
00:39:24,700 --> 00:39:28,000
對，所以在我們的測試中，我們只是將

1011
00:39:28,000 --> 00:39:29,566
makeSUT替換為使用

1012
00:39:29,566 --> 00:39:32,800
URLSession的共享實例, 所以我準備

1013
00:39:32,800 --> 00:39:33,900
去移除跟蹤

1014
00:39:33,900 --> 00:39:35,733
記憶體洩漏，因為共享實例

1015
00:39:35,733 --> 00:39:38,066
永遠不會消失，它是一個單例

1016
00:39:38,066 --> 00:39:41,200
對，讓我們運行測試

1017
00:39:41,200 --> 00:39:43,100
如你所見它們仍然通過，看看

1018
00:39:43,100 --> 00:39:44,933
我們如何輕易地進行重構


1019
00:39:44,933 --> 00:39:47,333
一種類型轉換成另一種類型的擴展

1020
00:39:47,333 --> 00:39:48,866
而不破壞任何測試

1021
00:39:48,866 --> 00:39:51,033
只需替換工廠方法和

1022
00:39:51,033 --> 00:39:52,300
這就是使用抽象的能力

1023
00:39:52,300 --> 00:39:54,933
即使在您的測試中也要使用抽象

1024
00:39:54,933 --> 00:39:56,466
這有多強大

1025
00:39:56,466 --> 00:39:58,700
是的，我會說特別是在你的測試中

1026
00:39:58,700 --> 00:39:59,566
也是如此

1027
00:39:59,566 --> 00:40:02,233
這極其重要，因為你

1028
00:40:02,233 --> 00:40:04,133
希望靈活，你希望能夠

1029
00:40:04,133 --> 00:40:05,733
進行這類型的變更

1030
00:40:05,733 --> 00:40:08,800
在任何給定的時間，所以個人來說

1031
00:40:08,800 --> 00:40:11,666
我非常喜歡這個，所以我會撤銷那個

1032
00:40:11,666 --> 00:40:12,400
變更

1033
00:40:12,400 --> 00:40:16,700
對

1034
00:40:16,700 --> 00:40:19,500
好的，我們又回到我們的轉接器

1035
00:40:19,500 --> 00:40:20,533
類型這裡

1036
00:40:20,533 --> 00:40:22,866
如果你更喜歡在上面擴展

1037
00:40:22,866 --> 00:40:24,466
Foundation類型

1038
00:40:24,466 --> 00:40:26,933
URLSession也可以，我只是

1039
00:40:26,933 --> 00:40:27,833
擔心那個

1040
00:40:27,833 --> 00:40:30,400
我們可能有一個方法衝突在某處

1041
00:40:30,400 --> 00:40:31,200
點

1042
00:40:31,200 --> 00:40:33,100
如果他們曾經建立一個稱為 get 的方法

1043
00:40:33,100 --> 00:40:35,433
from URL 它可能永遠不會發生，但

1044
00:40:35,433 --> 00:40:37,100
我謹慎，所以這是我個人的


1045
00:40:37,100 --> 00:40:38,633
優先創建我自己的

1046
00:40:38,633 --> 00:40:40,633
adapter types，但你可以自由選擇

1047
00:40:40,633 --> 00:40:41,833
你自己的選擇

1048
00:40:41,833 --> 00:40:44,866
控制你所能的，我猜，並且在這

1049
00:40:44,866 --> 00:40:46,233
案例中我們可以控制

1050
00:40:46,233 --> 00:40:49,266
我們的類別，我們的新型態，所以是的，我同意

1051
00:40:49,266 --> 00:40:50,633
你的觀點，我感到滿意

1052
00:40:50,633 --> 00:40:53,100
就這樣保留它，那就是這樣，這

1053
00:40:53,100 --> 00:40:54,633
是一個非常密集的節目

1054
00:40:54,633 --> 00:40:57,200
我們已經做了一大堆的實戰編碼

1055
00:40:57,200 --> 00:40:58,066
和重構

1056
00:40:58,066 --> 00:40:59,500
不要忘記讀取說明，以

1057
00:40:59,500 --> 00:41:01,500
瞭解更多在此

1058
00:41:01,500 --> 00:41:02,400
節目中使用的技巧

1059
00:41:02,400 --> 00:41:04,466
並且我們下一次見，再見

1060
00:41:04,466 --> 00:41:05,433
再見

1061
00:41:05,433 --> 00:41:07,266
再見