

1
00:00:01,100 --> 00:00:03,333
你好 Mike，嗨 Caio

2
00:00:03,333 --> 00:00:04,633
是時候測試一下

3
00:00:04,633 --> 00:00:07,200
HTTPClient 的實現了

4
00:00:07,200 --> 00:00:09,566
對，那麼我們來看一下概覽

5
00:00:09,566 --> 00:00:11,266
到目前為止我們完成了哪些工作

6
00:00:11,266 --> 00:00:14,400
好的，我更新了圖示，到目前為止

7
00:00:14,400 --> 00:00:15,900
我們的 Feed API 模塊

8
00:00:15,900 --> 00:00:17,666
的架構看起來像這樣

9
00:00:17,666 --> 00:00:19,600
我們已實現了 RemoteFeedLoader

10
00:00:19,600 --> 00:00:21,600
它使用 FeedItemsMapper

11
00:00:21,600 --> 00:00:23,900
來映射回應，並請求

12
00:00:23,900 --> 00:00:26,133
從 HTTPClient 獲取數據

13
00:00:26,133 --> 00:00:28,466
但我們還沒有任何實現對吧

14
00:00:28,466 --> 00:00:30,066
所以該實現

15
00:00:30,066 --> 00:00:32,633
的 HTTPClient 協議將

16
00:00:32,633 --> 00:00:34,366
負責與網絡

17
00:00:34,366 --> 00:00:35,033
進行通信

18
00:00:35,033 --> 00:00:37,900
與後端進行通信，完全正確，很好

19
00:00:37,900 --> 00:00:39,333
我認為這裡的自然選擇如果你

20
00:00:39,333 --> 00:00:40,866
不打算使用任何第三方

21
00:00:40,866 --> 00:00:41,433
框架

22
00:00:41,433 --> 00:00:44,800
是使用 URLSessions，完全準確，它是

23
00:00:44,800 --> 00:00:47,733
最高級的 API，我們不使用

24
00:00:47,733 --> 00:00:49,100
任何第三方庫

25
00:00:49,100 --> 00:00:51,100
所以我很樂意採用 URLSession

26
00:00:51,100 --> 00:00:53,900
現在好了，所以讓我們創建一個 URL

27
00:00:53,900 --> 00:00:58,366
SessionHTTPClient

28
00:00:58,366 --> 00:00:59,733
好的，我們只需要做的是

29
00:00:59,733 --> 00:01:01,433
實現 get 方法

30
00:01:01,433 --> 00:01:04,133
從 URL 中，並有一個完成塊，對吧

31
00:01:04,133 --> 00:01:05,166
它可能會返回

32
00:01:05,166 --> 00:01:08,300
一個成功與 Data 和 HTTP 

33
00:01:08,300 --> 00:01:09,433
URLResponse

34
00:01:09,433 --> 00:01:12,133
或者失敗與一個錯誤，確切地說

35
00:01:12,133 --> 00:01:13,600
我們有很多方法可以測試這點

36
00:01:13,600 --> 00:01:13,900
或者

37
00:01:13,900 --> 00:01:16,866
測試驅動這個，其中一種就是直接

38
00:01:16,866 --> 00:01:17,200
運行

39
00:01:17,200 --> 00:01:19,833
端對端測試，對吧 ，意思是我們實際上正在

40
00:01:19,833 --> 00:01:21,733
觸及網路

41
00:01:21,733 --> 00:01:24,533
是的，執行 HTTP 請求，去到

42
00:01:24,533 --> 00:01:25,433
後端

43
00:01:25,433 --> 00:01:27,033
獲得回傳的資料，然後

44
00:01:27,033 --> 00:01:29,266
確認我們得到了正確的響應

45
00:01:29,266 --> 00:01:32,300
我可以看到這裡有幾個問題，首先

46
00:01:32,300 --> 00:01:32,766
一點

47
00:01:32,766 --> 00:01:35,833
我們還沒有後端，沒錯

48
00:01:35,833 --> 00:01:37,500
也不想被阻塞，對的


49
00:01:37,500 --> 00:01:39,500
確實，我們不希望被阻擋

50
00:01:39,500 --> 00:01:41,266
因為我們沒有後端的

51
00:01:41,266 --> 00:01:42,700
另一個問題

52
00:01:42,700 --> 00:01:45,500
是它們可能會不穩定

53
00:01:45,500 --> 00:01:47,100
之所以會不穩定，是因為它們

54
00:01:47,100 --> 00:01:50,766
正在進行網絡請求，而請求經常會

55
00:01:50,766 --> 00:01:52,866
失敗，如果你在嘗試執行你的

56
00:01:52,866 --> 00:01:54,633
測試時沒有連接呢？

57
00:01:54,633 --> 00:01:55,433
測試

58
00:01:55,433 --> 00:01:57,600
這是另一個好點，那麼你可以

59
00:01:57,600 --> 00:01:59,100
認為誰現在沒有

60
00:01:59,100 --> 00:02:00,533
網絡連接，但是

61
00:02:00,533 --> 00:02:02,700
你不想受到限制，對嗎？

62
00:02:02,700 --> 00:02:03,833
在這裡，我們正在談論的是

63
00:02:03,833 --> 00:02:04,933
組件級別

64
00:02:04,933 --> 00:02:06,633
我不認為這是進行

65
00:02:06,633 --> 00:02:08,000
端到端測試的地方

66
00:02:08,000 --> 00:02:11,033
對，我們確實需要端到端測試，但是

67
00:02:11,033 --> 00:02:12,633
不是在組件級別。

68
00:02:12,633 --> 00:02:14,066
確實，如果可以測試

69
00:02:14,066 --> 00:02:16,133
更多的組件集成的話，

70
00:02:16,133 --> 00:02:17,833
進行端到端測試將更有好處。

71
00:02:17,833 --> 00:02:19,900
準確地說，僅僅是為了說明清楚，端對端

72
00:02:19,900 --> 00:02:21,666
測試是一個有效的解決方案

73
00:02:21,666 --> 00:02:23,333
但既然我們有更可靠的

74
00:02:23,333 --> 00:02:25,333
解決方案，我認為我們應該給予那些

75
00:02:25,333 --> 00:02:28,133
更好的選擇一個機會，我同意，好的，讓我

76
00:02:28,133 --> 00:02:29,900
在這裡建立一個測試文件

77
00:02:29,900 --> 00:02:34,633
URLSessionHTTPClientTests

78
00:02:34,633 --> 00:02:36,933
好的，所以對於第一個測試，我們知道

79
00:02:36,933 --> 00:02:38,866
我們將請求URL

80
00:02:38,866 --> 00:02:41,200
我們將使用URLSessions，對

81
00:02:41,200 --> 00:02:42,933
好的，那麼 API是甚麼 

82
00:02:42,933 --> 00:02:46,233
它是一個名為dataTask的實例方法

83
00:02:46,233 --> 00:02:48,133
with URL，所以我們傳遞URL和一個

84
00:02:48,133 --> 00:02:49,733
完成處理器，然後我們返回

85
00:02:49,733 --> 00:02:50,233
回來

86
00:02:50,233 --> 00:02:54,233
我們可以重新開始或開始的DataTask

87
00:02:54,233 --> 00:02:56,466
確實，一旦請求完成，將調用

88
00:02:56,466 --> 00:02:58,133
完成處理器並帶有

89
00:02:58,133 --> 00:02:58,633
兩者之一

90
00:02:58,633 --> 00:03:01,666
Data和URLResponse或Error，對的

91
00:03:01,666 --> 00:03:04,000
好，所以首先，讓我們確保

92
00:03:04,000 --> 00:03:06,066
我們創建一個資料任務，

93
00:03:06,066 --> 00:03:06,466
對的，

94
00:03:06,466 --> 00:03:09,266
使用正確的URL，所以我們可以有一個斷言

95
00:03:09,266 --> 00:03:10,533
像是，

96
00:03:10,533 --> 00:03:14,066
session.receivedURLs

97
00:03:14,066 --> 00:03:17,333
只應該有一個URL，

98
00:03:17,333 --> 00:03:20,400
對，就是這樣。我們需要一個URL，

99
00:03:20,400 --> 00:03:24,300
這個URL可以是任何的URL，所以我們需要一個session，

100
00:03:24,300 --> 00:03:25,200
對。

101
00:03:27,833 --> 00:03:29,266
但是URLSession並沒有

102
00:03:29,266 --> 00:03:31,333
receivedURLs，因為這是

103
00:03:31,333 --> 00:03:33,666
一個測試的細節。對，我們正在間諜，所以我們

104
00:03:33,666 --> 00:03:34,633
需要創建

105
00:03:34,633 --> 00:03:39,100
我們自己的URLSessionSpy，對。

106
00:03:39,100 --> 00:03:42,400
所以URLSessionSpy這是一個子類別

107
00:03:42,400 --> 00:03:45,433
的URLSession。我們可以從這裡開始。我們要有一個received

108
00:03:45,433 --> 00:03:46,700
URLS的數組,然後開始時為空的。

109
00:03:46,700 --> 00:03:50,066
每次我們調用dataTask，

110
00:03:50,066 --> 00:03:52,866
跟著URL之後，

111
00:03:52,866 --> 00:03:53,500
及

112
00:03:53,500 --> 00:03:56,766
completion block之後，我們將會捕捉

113
00:03:56,766 --> 00:03:59,733
傳送的URL。就這樣，我們已經做完了，

114
00:03:59,733 --> 00:04:00,000
許多

115
00:04:00,000 --> 00:04:03,033
次。我們已經捕捉到了URL，

116
00:04:03,033 --> 00:04:06,933
對，但現在我們需要思考


117
00:04:06,933 --> 00:04:08,633
在這裡我們該返回什麼，因為這個方法

118
00:04:08,633 --> 00:04:10,766
返回一個 DataTask

119
00:04:10,766 --> 00:04:13,500
對，而我們不希望任何時候都執行

120
00:04:13,500 --> 00:04:14,700
網絡請求

121
00:04:14,700 --> 00:04:17,600
在測試期間確實如此，我們需要一種

122
00:04:17,600 --> 00:04:18,366
種類的

123
00:04:18,366 --> 00:04:21,100
對此 DataTask 的模擬實現

124
00:04:21,100 --> 00:04:22,233
在那裡

125
00:04:22,233 --> 00:04:25,033
所以我們可以創建一個 FakeURLSessionData

126
00:04:25,033 --> 00:04:25,733
Task

127
00:04:25,733 --> 00:04:29,500
對，我們可以只在這裡返回它

128
00:04:29,500 --> 00:04:31,266
所以這是預期，這是

129
00:04:31,266 --> 00:04:33,266
設置，但我們需要

130
00:04:33,266 --> 00:04:36,466
調用 get 方法，對，所以如果你說

131
00:04:36,466 --> 00:04:37,333
得到

132
00:04:37,333 --> 00:04:40,533
來自 URL，我期待這會發生

133
00:04:40,533 --> 00:04:43,333
我期待 sut 創建一個數據任務

134
00:04:43,333 --> 00:04:44,066
來自會議

135
00:04:44,066 --> 00:04:46,800
與接收到的 URL，這是正確的，所以

136
00:04:46,800 --> 00:04:48,133
sut 是什麼

137
00:04:48,133 --> 00:04:50,866
它可以是一種新類型 URLSessionHTTP

138
00:04:50,866 --> 00:04:51,900
Client

139
00:04:51,900 --> 00:04:54,533
而我們從會議開始，對

140
00:04:54,533 --> 00:04:55,100
再次

141
00:04:55,100 --> 00:04:56,700
構造器注入，如我們所做的

142
00:04:56,700 --> 00:04:58,233
多次，這將是

143
00:04:58,233 --> 00:05:00,133
將是生產代碼，所以保留它

144
00:05:00,133 --> 00:05:01,900
現在放到外面

145
00:05:01,900 --> 00:05:03,500
當我們準備好時可以移至生產環境

146
00:05:03,500 --> 00:05:05,833
到時候就行

147
00:05:05,833 --> 00:05:09,266
所以使用建構子注入和私有

148
00:05:09,266 --> 00:05:13,266
屬性

149
00:05:13,266 --> 00:05:15,833
所以從URL獲取，目前我們不需要

150
00:05:15,833 --> 00:05:16,300
block

151
00:05:16,300 --> 00:05:19,166
我們保持簡單就好，好像

152
00:05:19,166 --> 00:05:21,033
編譯器是快樂的

153
00:05:21,033 --> 00:05:23,833
讓我們看看會不會有測試失敗，

154
00:05:23,833 --> 00:05:25,500
還真的有 

155
00:05:25,500 --> 00:05:28,866
所以現在我們可以調用會話數據任務

156
00:05:28,866 --> 00:05:32,466
與URL，我們可以傳遞任何完成

157
00:05:32,466 --> 00:05:34,933
處理程序

158
00:05:34,933 --> 00:05:38,466
我們現在還不需要它，讓我們看看

159
00:05:38,466 --> 00:05:39,266
應該可以了

160
00:05:39,266 --> 00:05:42,066
好，現在測試通過了，讓我們給這個

161
00:05:42,066 --> 00:05:42,866
測試命名

162
00:05:42,866 --> 00:05:46,300
所以從URL獲取創建

163
00:05:46,300 --> 00:05:49,433
數據任務與URL，我對此感到滿意

164
00:05:49,433 --> 00:05:49,900
名字

165
00:05:49,900 --> 00:05:51,600
看看這種方法，我們正在

166
00:05:51,600 --> 00:05:53,033
子類化

167
00:05:53,033 --> 00:05:56,300
URLSession 和 URLSessionDataTask 

168
00:05:56,300 --> 00:05:58,533
這通常是比較危險的，因為我們

169
00:05:58,533 --> 00:05:59,900
並不擁有那些類別

170
00:05:59,900 --> 00:06:02,133
那是基礎類別，我們並不


171
00:06:02,133 --> 00:06:04,000
甚至可以訪問他們的實現

172
00:06:04,000 --> 00:06:07,166
是的，如果您開始模擬我們

173
00:06:07,166 --> 00:06:07,833
不擁有的類

174
00:06:07,833 --> 00:06:10,633
我們可以開始在我們的

175
00:06:10,633 --> 00:06:11,166
模擬

176
00:06:11,166 --> 00:06:13,666
行為中創建可能是錯誤的假設，是的，大

177
00:06:13,666 --> 00:06:14,233
時間

178
00:06:14,233 --> 00:06:17,266
再加上這些類型包含

179
00:06:17,266 --> 00:06:19,900
一堆我們沒有

180
00:06:19,900 --> 00:06:21,266
在這裡覆蓋的方法

181
00:06:21,266 --> 00:06:24,933
確實，看看這一堆方法

182
00:06:24,933 --> 00:06:27,333
我們並不在乎確實，您

183
00:06:27,333 --> 00:06:29,033
永遠不知道可能會如何

184
00:06:29,033 --> 00:06:32,466
這些方法可能會如何互相操作

185
00:06:32,466 --> 00:06:35,033
因此我視之為風險

186
00:06:35,033 --> 00:06:35,900
親自

187
00:06:35,900 --> 00:06:38,400
我認為我們正在做出大的假設

188
00:06:38,400 --> 00:06:39,166
在這裡

189
00:06:39,166 --> 00:06:42,933
但是到目前為止一切都好，這是真的，所以讓我們

190
00:06:42,933 --> 00:06:45,100
只是將我們的助手與我們的測試分開

191
00:06:45,100 --> 00:06:47,166
我認為我們應該提交

192
00:06:47,166 --> 00:06:49,500
是的，這是一個可以工作的解決方案，我們應該

193
00:06:49,500 --> 00:06:50,633
提交

194
00:06:50,633 --> 00:06:54,066
因此，創建URL

195
00:06:54,066 --> 00:06:57,666
在URLSessionHTTPClient上使用URL的Session data任務

196
00:06:57,666 --> 00:07:01,500
從URL中獲取

197
00:07:01,500 --> 00:07:06,066
好吧，所以這是我們的第一步

199
00:07:08,133 --> 00:07:10,000
檢查我們是否正在創建

200
00:07:10,000 --> 00:07:12,133
帶有正確URL的數據任務，但是

201
00:07:12,133 --> 00:07:13,433
下一步需要發生的事情是

202
00:07:13,433 --> 00:07:15,833
要開始數據任務，需要呼叫

203
00:07:15,833 --> 00:07:16,533
恢復

204
00:07:16,533 --> 00:07:19,033
是的，讓我們為此設定一個測試吧

205
00:07:19,033 --> 00:07:19,900
我們可以使用

206
00:07:19,900 --> 00:07:23,166
同樣的方式，監視數據任務

207
00:07:23,166 --> 00:07:23,733
現在 

208
00:07:23,733 --> 00:07:26,933
好的，從URL獲取數據並恢復

209
00:07:26,933 --> 00:07:30,000
帶有URL的數據任務，我們現在需要的是

210
00:07:30,000 --> 00:07:32,800
現在我們需要能夠確認的是

211
00:07:32,800 --> 00:07:33,500
任務

212
00:07:33,500 --> 00:07:36,800
只被重新開始一次，否則

213
00:07:36,800 --> 00:07:38,633
會有錯誤，所以我們

214
00:07:38,633 --> 00:07:40,533
需要一個任務

215
00:07:40,533 --> 00:07:43,666
到目前為止，我們有Fake

216
00:07:43,666 --> 00:07:46,233
URLSessionDataTask，我們可以創建

217
00:07:46,233 --> 00:07:47,100
另一個

218
00:07:47,100 --> 00:07:50,400
有一個URLSessionDataTaskSpy

219
00:07:50,400 --> 00:07:54,133
是的，我們可以有我們的變量

220
00:07:54,133 --> 00:07:57,500
resumeCallCount，從零開始

221
00:07:57,500 --> 00:08:00,633
每當我們調用恢復

222
00:08:00,633 --> 00:08:04,633
我們增加一個，就是這樣

223
00:08:04,633 --> 00:08:06,800
但是現在我們需要告訴該session去


224
00:08:06,800 --> 00:08:08,300
返回我們的任務

225
00:08:08,300 --> 00:08:10,633
為了給定的URL，所以我們可以建立一些

226
00:08:10,633 --> 00:08:12,633
類似stub的機制

227
00:08:12,633 --> 00:08:16,000
所以 stub URL 配上一個任務

228
00:08:16,000 --> 00:08:20,633
對，我們該如何建立那個 stub URL 

229
00:08:20,633 --> 00:08:23,500
配上任務，並且該任務是一個 SessionData

230
00:08:23,500 --> 00:08:25,033
Task（任務）

231
00:08:25,033 --> 00:08:28,000
我們需要有一些集合來

232
00:08:28,000 --> 00:08:28,933
模擬

233
00:08:28,933 --> 00:08:31,166
行為，我猜這可能是一種

234
00:08:31,166 --> 00:08:32,066
字典

235
00:08:32,066 --> 00:08:34,933
對，這是一種鍵值的集合

236
00:08:34,933 --> 00:08:35,433
意思

237
00:08:35,433 --> 00:08:38,066
對於特定的URL，我們將會有一個

238
00:08:38,066 --> 00:08:39,433
特定任務

239
00:08:39,433 --> 00:08:40,766
所以我們需要做的是獲取我們的

240
00:08:40,766 --> 00:08:43,033
模擬的URL

241
00:08:43,033 --> 00:08:46,466
等於任務，我喜歡這樣，所以當

242
00:08:46,466 --> 00:08:48,766
生產代碼請求一個任務，我們

243
00:08:48,766 --> 00:08:49,666
可以返回

244
00:08:49,666 --> 00:08:51,900
模擬的任務為URL，如果沒有

245
00:08:51,900 --> 00:08:53,266
我們返回假的

246
00:08:53,266 --> 00:08:56,933
確實，好

247
00:08:56,933 --> 00:08:59,833
預期中的失敗測試，美麗

248
00:08:59,833 --> 00:09:01,433
我們只需要呼叫

249
00:09:01,433 --> 00:09:04,866
繼續並且


250
00:09:04,866 --> 00:09:07,033
好的，我們這裡出現了崩潰，這很好

251
00:09:07,033 --> 00:09:08,366
因為我們回傳了

252
00:09:08,366 --> 00:09:11,033
在第一次測試時一個假的 URLSession

253
00:09:11,033 --> 00:09:11,900
那個並沒有

254
00:09:11,900 --> 00:09:15,600
覆寫 resume，所以我們可以直接覆寫

255
00:09:15,600 --> 00:09:19,033
並什麼也不做，我們再次運行

256
00:09:19,033 --> 00:09:23,333
然後它現在通過了，完美

257
00:09:23,333 --> 00:09:25,266
也就是說如果我們刪掉 resume，我

258
00:09:25,266 --> 00:09:27,333
又會得到一個失敗的測試

259
00:09:27,333 --> 00:09:29,500
看看這，你看，但是這其中

260
00:09:29,500 --> 00:09:31,033
對這些測試的問題是

261
00:09:31,033 --> 00:09:32,933
當我們使用模擬，尤其是

262
00:09:32,933 --> 00:09:34,466
我們不擁有的類別時

263
00:09:34,466 --> 00:09:37,100
看看我們的測試怎麼綁定到

264
00:09:37,100 --> 00:09:38,066
實現上

265
00:09:38,066 --> 00:09:39,666
這裡的這個實現應該是

266
00:09:39,666 --> 00:09:42,300
私有的，我們應該只測試行為

267
00:09:42,300 --> 00:09:44,366
但是因為模擬策略的關係

268
00:09:44,366 --> 00:09:45,500
我們選擇的

269
00:09:45,500 --> 00:09:47,733
我們最後不得不測試每一個

270
00:09:47,733 --> 00:09:48,533
交互

271
00:09:48,533 --> 00:09:50,800
確定哪個 API 正在被調用以及

272
00:09:50,800 --> 00:09:52,700
確定哪些參數在什麼時間被調用

273
00:09:52,700 --> 00:09:54,633
這可能是我們需要的，但那

274
00:09:54,633 --> 00:09:56,466
可能會使測試成對


275
00:09:56,466 --> 00:09:58,133
以生產代碼，所以每次你

276
00:09:58,133 --> 00:09:59,900
想要重構代碼，你會破壞

277
00:09:59,900 --> 00:10:00,700
測試

278
00:10:00,700 --> 00:10:03,033
這可能會是一個問題，測試

279
00:10:03,033 --> 00:10:04,533
正在檢查

280
00:10:04,533 --> 00:10:08,633
確切地說，這些API的實現

281
00:10:08,633 --> 00:10:11,033
我們不希望這樣，正如你所說，我們

282
00:10:11,033 --> 00:10:12,000
寧願

283
00:10:12,000 --> 00:10:14,800
檢查加載

284
00:10:14,800 --> 00:10:15,833
URL的行為

285
00:10:15,833 --> 00:10:18,300
以及完成情況，如果可能的話，如果

286
00:10:18,300 --> 00:10:18,933
可能的話

287
00:10:18,933 --> 00:10:20,533
對，這是可能的，我們將

288
00:10:20,533 --> 00:10:22,533
向你展示，對，我絕對同意

289
00:10:22,533 --> 00:10:24,300
僅僅因為我們不得不

290
00:10:24,300 --> 00:10:27,033
覆寫resume方法

291
00:10:27,033 --> 00:10:30,233
在FakeURLSessionDataTask中

292
00:10:30,233 --> 00:10:32,933
這就向你展示這些API

293
00:10:32,933 --> 00:10:33,600
可能有多麼脆弱

294
00:10:33,600 --> 00:10:36,700
當用於測試目的，而且

295
00:10:36,700 --> 00:10:38,800
僅僅要用於測試的情況下

296
00:10:38,800 --> 00:10:39,733
對

297
00:10:39,733 --> 00:10:42,066
確實，那其他我們正在

298
00:10:42,066 --> 00:10:43,200
不覆寫可能會產生問題

299
00:10:43,200 --> 00:10:45,833
的方法，那可能會導致未來問題

300
00:10:45,833 --> 00:10:47,433
在未來

301
00:10:47,433 --> 00:10:49,333
所以我們需要對此保持警惕，對於

302
00:10:49,333 --> 00:10:51,033
當然，但讓我們先提交

303
00:10:51,033 --> 00:10:54,633
到目前為止運行良好，讓我們這麼做

304
00:10:54,633 --> 00:10:59,666
所以在創建時恢復數據任務

305
00:10:59,666 --> 00:11:02,066
現在，由於我們正在創建替代，我認為

306
00:11:02,066 --> 00:11:03,333
第一個測試

307
00:11:03,333 --> 00:11:06,533
是多餘的，因為我們返回

308
00:11:06,533 --> 00:11:07,266
一個任務

309
00:11:07,266 --> 00:11:09,900
對於stub中特定的URL，我們已經在測試

310
00:11:09,900 --> 00:11:11,266
我們已經在

311
00:11:11,266 --> 00:11:13,433
使用正確的URL調用此方法

312
00:11:13,433 --> 00:11:15,033
所以現在這是不相關的

313
00:11:15,033 --> 00:11:17,333
這是一個好的開始，但我們經常會刪除測試

314
00:11:17,333 --> 00:11:18,366
隨著我們對API的了解增加，我們就不需要

315
00:11:18,366 --> 00:11:21,500
不再需要receivedURLs

316
00:11:21,500 --> 00:11:23,266
對，輕便得多

317
00:11:23,266 --> 00:11:24,466
讓我們看看是否還能通過，太棒了

318
00:11:24,466 --> 00:11:29,200
刪除多餘的測試

319
00:11:29,200 --> 00:11:32,466
非常好，我們終於整理好了API

320
00:11:32,466 --> 00:11:35,666
現在我們實際上可以測試我們關心的行為

321
00:11:35,666 --> 00:11:38,233
現在我們可以實際上測試我們關心的行為

322
00:11:38,233 --> 00:11:39,433
所以從URL獲取失敗

323
00:11:39,433 --> 00:11:43,433
請求錯誤，讓我們首先處理錯誤

324
00:11:43,433 --> 00:11:47,033
請求錯誤，讓我們首先處理錯誤

325
00:11:47,033 --> 00:11:47,733
首先


326
00:11:47,733 --> 00:11:49,200
我總是喜歡從錯誤開始

327
00:11:49,200 --> 00:11:51,433
對，我也是，傷心的路徑

328
00:11:51,433 --> 00:11:53,333
先解決它們，以後就不需要

329
00:11:53,333 --> 00:11:54,633
再來思考它們了

330
00:11:54,633 --> 00:11:57,666
所以我覺得這個設定非常相似，所以

331
00:11:57,666 --> 00:11:58,933
讓我複製這個

332
00:11:58,933 --> 00:12:01,200
但現在我想要停止的不是task

333
00:12:01,200 --> 00:12:02,366
我要停止的是錯誤

334
00:12:02,366 --> 00:12:04,800
對，就是這樣，我們需要停止的就是

335
00:12:04,800 --> 00:12:05,600
那個錯誤而且

336
00:12:05,600 --> 00:12:08,066
確保我們使用的

337
00:12:08,066 --> 00:12:09,200
就是那個錯誤

338
00:12:09,200 --> 00:12:13,600
我們可以使用任何錯誤

339
00:12:13,600 --> 00:12:16,066
所以我在這還是需要有task

340
00:12:16,066 --> 00:12:17,266
因為第一次的測試

341
00:12:17,266 --> 00:12:19,600
但我可以給它一個預設值，我也可以給

342
00:12:19,600 --> 00:12:21,266
錯誤一個預設的值

343
00:12:21,266 --> 00:12:23,900
預設為nil就好，然後我們

344
00:12:23,900 --> 00:12:25,900
需要找個方式把

345
00:12:25,900 --> 00:12:28,133
task跟錯誤結合，我們可以

346
00:12:28,133 --> 00:12:29,333
使用元組或是

347
00:12:29,333 --> 00:12:32,233
簡單的結構體，我們可以設置為私有的嗎

348
00:12:32,233 --> 00:12:32,866
可以的

349
00:12:32,866 --> 00:12:36,133
我們稱之為stub，它有一個任務，這是一個URL

350
00:12:36,133 --> 00:12:36,800
Session

351
00:12:36,800 --> 00:12:39,666
DataTask，它會有一個錯誤，這個是一個

352
00:12:39,666 --> 00:12:40,700
可選項

353
00:12:40,700 --> 00:12:43,733
錯誤。好的，現在我們持有

354
00:12:43,733 --> 00:12:46,800
stubs，讓我們將它包裹起來

355
00:12:46,800 --> 00:12:50,366
任務，錯誤

356
00:12:50,366 --> 00:12:52,466
好，現在我們需要知道我們是否有一個

357
00:12:52,466 --> 00:12:53,600
任務在裡面，所以

358
00:12:53,600 --> 00:12:57,733
我們可以使用一個 if let stub 或者 guard,是的

359
00:12:57,733 --> 00:13:00,700
然後我們返回 stub.task，然後我們

360
00:13:00,700 --> 00:13:01,666
完畢

361
00:13:01,666 --> 00:13:04,933
用以及，數據為空，響應為空

362
00:13:04,933 --> 00:13:09,900
錯誤就是stub的錯誤

363
00:13:09,900 --> 00:13:11,666
現在問題來了，我們是否該

364
00:13:11,666 --> 00:13:13,100
完畢

365
00:13:13,100 --> 00:13:15,500
在另一種情況下也這麼做對的，我們永遠不

366
00:13:15,500 --> 00:13:17,100
希望那樣的事發生，所以我們可以使用

367
00:13:17,100 --> 00:13:18,533
一個guard let 代替

368
00:13:18,533 --> 00:13:21,200
好的，我們可以留下一個好消息或者

369
00:13:21,200 --> 00:13:22,466
一個好的崩潰

370
00:13:22,466 --> 00:13:25,100
是的，因為那是在

371
00:13:25,100 --> 00:13:26,366
測試中的開發者錯誤

372
00:13:26,366 --> 00:13:28,633
所以如果我們沒有stub，我希望能夠

373
00:13:28,633 --> 00:13:30,133
留下一個消息


374
00:13:30,133 --> 00:13:35,833
所以無法找到給定網址的存根

375
00:13:35,833 --> 00:13:38,933
完美，我認為這就是我們所需要的

376
00:13:38,933 --> 00:13:41,666
我們的間諜，繼續進行測試。那麼我們預期

377
00:13:41,666 --> 00:13:42,366
接下來會怎樣呢？

378
00:13:42,366 --> 00:13:44,466
我們需要取得結果並且

379
00:13:44,466 --> 00:13:46,300
確定我們得到了錯誤。

380
00:13:46,300 --> 00:13:48,366
對，所以首先我們需要

381
00:13:48,366 --> 00:13:49,900
完成塊。

382
00:13:49,900 --> 00:13:53,033
對，所以現在 get

383
00:13:53,033 --> 00:13:55,500
from URL 需要完成塊

384
00:13:55,500 --> 00:13:56,133
而且

385
00:13:56,133 --> 00:14:00,466
我們返回一個 HTTPClientResult

386
00:14:00,466 --> 00:14:05,433
對，我們可以引入這個模組

387
00:14:05,433 --> 00:14:09,433
讓我們看看，所以當然這個測試

388
00:14:09,433 --> 00:14:10,633
現在需要忽略

389
00:14:10,633 --> 00:14:13,833
這個值

390
00:14:13,833 --> 00:14:16,066
現在我們可以研究我們是否得到了 

391
00:14:16,066 --> 00:14:18,000
我們期望的結果

392
00:14:18,000 --> 00:14:21,433
所以如果我們解開結果，我們期望

393
00:14:21,433 --> 00:14:22,866
得到一個失敗

394
00:14:22,866 --> 00:14:26,000
帶有我們想要的錯誤，

395
00:14:26,000 --> 00:14:26,466
一個 NSError

396
00:14:26,466 --> 00:14:29,666
所以我們可以將其與給定的

397
00:14:29,666 --> 00:14:31,833
錯誤進行比較

398
00:14:31,833 --> 00:14:34,233
那是剛創建的，對吧？

399
00:14:34,233 --> 00:14:35,033
否則的話

400
00:14:35,033 --> 00:14:38,800
我們希望它失敗，別的結果都會是

401
00:14:38,800 --> 00:14:42,133
錯誤，所以期待失敗

402
00:14:42,133 --> 00:14:45,833
但得到錯誤

403
00:14:45,833 --> 00:14:49,600
的結果，好的

404
00:14:49,600 --> 00:14:51,833
但這是一個異步塊，對吧

405
00:14:51,833 --> 00:14:52,866
所以我們更應

406
00:14:52,866 --> 00:14:54,933
確保我們進入這個塊，並且

407
00:14:54,933 --> 00:14:56,233
就如我們在前一集顯示的，我們可以

408
00:14:56,233 --> 00:14:56,933
使用

409
00:14:56,933 --> 00:15:01,666
期望等待完成

410
00:15:01,666 --> 00:15:05,333
好的，所以我們可以在我們

411
00:15:05,333 --> 00:15:08,533
斷言值之後完成，我們可以等待

412
00:15:08,533 --> 00:15:10,233
期望超時

413
00:15:10,233 --> 00:15:13,166
一應該足夠，超過足夠理應

414
00:15:13,166 --> 00:15:15,266
可以做到，對

415
00:15:15,266 --> 00:15:17,333
我們應該會得到一個失敗的測試，希望如此

416
00:15:17,333 --> 00:15:20,233
希望如此

417
00:15:20,233 --> 00:15:23,333
我們做到了，我們從未進入這個塊

418
00:15:23,333 --> 00:15:25,600
很好，那現在是時候呼叫

419
00:15:25,600 --> 00:15:27,100
完成

420
00:15:27,100 --> 00:15:29,600
搭配錯誤和最後的

421
00:15:29,600 --> 00:15:30,533
參數

422
00:15:30,533 --> 00:15:32,800
在data task 完成塊中是

423
00:15:32,800 --> 00:15:34,133
可選的

424
00:15:34,133 --> 00:15:37,266
所以我們需要解封裝它，對我們需要

425
00:15:37,266 --> 00:15:39,100
逃逸的完成條件

426
00:15:39,100 --> 00:15:43,433
也一樣，好的

427
00:15:43,433 --> 00:15:45,100
對，這需要被包裹在一個

428
00:15:45,100 --> 00:15:48,533
failure result中

429
00:15:48,533 --> 00:15:52,233
好的，現在通過了，太棒了

430
00:15:52,233 --> 00:15:56,466
傳到git上面好了，所以我們提交吧

431
00:15:56,466 --> 00:16:00,000
傳遞失敗與錯誤

432
00:16:00,000 --> 00:16:03,100
在請求錯誤中

433
00:16:03,100 --> 00:16:05,666
就這樣，所以我認為現在是時候

434
00:16:05,666 --> 00:16:07,266
刪除那些URLSession了

435
00:16:07,266 --> 00:16:10,000
模擬，我對它們沒有信心

436
00:16:10,000 --> 00:16:10,866
對它們

437
00:16:10,866 --> 00:16:13,500
接下來自然的步驟就是

438
00:16:13,500 --> 00:16:14,700
顯然使用

439
00:16:14,700 --> 00:16:16,700
協議是對的，有一些

440
00:16:16,700 --> 00:16:17,900
權衡，但是

441
00:16:17,900 --> 00:16:21,166
一個得到是關於協議

442
00:16:21,166 --> 00:16:24,466
我們只在乎特定的行為

443
00:16:24,466 --> 00:16:26,233
這個帶有URL完成的數據任務

444
00:16:26,233 --> 00:16:27,500
處理器，對的

445
00:16:27,500 --> 00:16:29,900
不管那裡的其他方法

446
00:16:29,900 --> 00:16:31,500
所以這是一種常用技術

447
00:16:31,500 --> 00:16:33,833
人們一直在用它，

448
00:16:33,833 --> 00:16:35,333
完全是複製

449
00:16:35,333 --> 00:16:38,533
準確的API並放在協議中

450
00:16:38,533 --> 00:16:40,233
對，所以在生產中我們會有個

451
00:16:40,233 --> 00:16:42,000
比如說的協議

452
00:16:42,000 --> 00:16:45,100
HTTPSession

453
00:16:45,100 --> 00:16:47,500
我們只定義了一種方法，因此我們

454
00:16:47,500 --> 00:16:48,800
消除了問題

455
00:16:48,800 --> 00:16:50,533
有一堆我們需要關心的，並且

456
00:16:50,533 --> 00:16:52,066
需要覆蓋的方法

457
00:16:52,066 --> 00:16:52,866
超載

458
00:16:52,866 --> 00:16:54,533
所以我們可以保證生產代碼

459
00:16:54,533 --> 00:16:56,933
只能看到這個方法

460
00:16:56,933 --> 00:16:58,866
所以我們只需要模擬這個方法，並且

461
00:16:58,866 --> 00:17:00,133
我們不需要關心其他的

462
00:17:00,133 --> 00:17:00,866
方法

463
00:17:00,866 --> 00:17:04,700
是的，所以如果我們現在把URLSession

464
00:17:04,700 --> 00:17:07,733
換成HTTPSession

465
00:17:07,733 --> 00:17:10,933
這應該是一個容易的轉變

466
00:17:10,933 --> 00:17:13,833
於是這將會是一個遵從HTTPSession的

467
00:17:13,833 --> 00:17:15,900
HTTPSessionSpy

468
00:17:15,900 --> 00:17:17,433
所以它不需要再覆蓋

469
00:17:17,433 --> 00:17:20,933
它只需要來自協議的實現

470
00:17:20,933 --> 00:17:24,066
好的，但我們這裡仍然有一個問題

471
00:17:24,066 --> 00:17:26,400
我們仍在使用URLSessionData

472
00:17:26,400 --> 00:17:27,166
任務

473
00:17:27,166 --> 00:17:30,400
對，它有一堆方法，所以

474
00:17:30,400 --> 00:17:34,066
我們可以用同樣的方法創建我們自己的

475
00:17:34,066 --> 00:17:37,200
只有一個方法的HTTPSessionTask


476
00:17:37,200 --> 00:17:40,766
繼續，讓我們製作HTTPSession

477
00:17:40,766 --> 00:17:45,266
返回任務

478
00:17:45,266 --> 00:17:47,100
所以我們可以用協議

479
00:17:47,100 --> 00:17:52,633
在每個地方替換資料任務

480
00:17:52,633 --> 00:17:55,733
並且不再需要重寫

481
00:17:55,733 --> 00:18:00,766
只需要實施它

482
00:18:00,766 --> 00:18:03,333
所以現在我們只需要在

483
00:18:03,333 --> 00:18:05,266
測試中使用間諜

484
00:18:05,266 --> 00:18:08,300
對，我認為這樣應該就可以了

485
00:18:08,300 --> 00:18:11,433
簡單，所以我們更換了子類

486
00:18:11,433 --> 00:18:12,233
策略

487
00:18:12,233 --> 00:18:14,633
以一個基於協議的策略來

488
00:18:14,633 --> 00:18:16,700
模擬URLSession

489
00:18:16,700 --> 00:18:18,700
你對此感覺如何？我認為這是

490
00:18:18,700 --> 00:18:20,633
一種改進，原因是

491
00:18:20,633 --> 00:18:22,633
隱藏了我們不關心的所有URL

492
00:18:22,633 --> 00:18:24,000
Session的細節

493
00:18:24,000 --> 00:18:26,700
現在我們可以限制我們擁有的API

494
00:18:26,700 --> 00:18:27,600
進入點

495
00:18:27,600 --> 00:18:30,233
但我們對產品代碼增添了一些瑣碎之處

496
00:18:30,233 --> 00:18:31,100
我們有這些額外的協議，

497
00:18:31,100 --> 00:18:33,100
協議與原本的界面完全一致，

498
00:18:33,100 --> 00:18:35,733
在我看來這是一種麻煩的預兆，因為我們

499
00:18:35,733 --> 00:18:37,900
引進了這兩種新的類型，

500
00:18:37,900 --> 00:18:40,000
組成完全一樣的接口。

501
00:18:40,000 --> 00:18:42,533
只為了測試這些

502
00:18:42,533 --> 00:18:44,533
並不是意義上要

503
00:18:44,533 --> 00:18:46,000
立即使用的抽象化

504
00:18:46,000 --> 00:18:49,666
而是其他客戶端現在抽象化

505
00:18:49,666 --> 00:18:52,866
為了測試，我不喜歡那樣

506
00:18:52,866 --> 00:18:55,333
嗯，這是一種有效的解決方案，對，我以前用過

507
00:18:55,333 --> 00:18:56,633
它

508
00:18:56,633 --> 00:18:59,266
對，這可行，我傾向於甚至

509
00:18:59,266 --> 00:19:00,133
提交這個

510
00:19:00,133 --> 00:19:02,633
我認為這是一點點的改進

511
00:19:02,633 --> 00:19:04,533
改進了我們的測試，但我認為它

512
00:19:04,533 --> 00:19:06,000
讓我們的生產代碼變得更

513
00:19:06,000 --> 00:19:07,733
複雜了，它應該的

514
00:19:07,733 --> 00:19:10,133
所以這裡的權衡我不確定

515
00:19:10,133 --> 00:19:10,933
如果我

516
00:19:10,933 --> 00:19:13,600
願不願意做，但我願意提交

517
00:19:13,600 --> 00:19:15,500
看看會發生什麼

518
00:19:15,500 --> 00:19:18,766
我同意，所以重構

519
00:19:18,766 --> 00:19:22,000
URLSession 子類別

520
00:19:22,000 --> 00:19:25,100
使用基於協議的

521
00:19:25,100 --> 00:19:28,766
模擬，太好了。所以我們談論

522
00:19:28,766 --> 00:19:32,000
端到端測試，我們展示了子類別

523
00:19:32,000 --> 00:19:32,633
模擬

524
00:19:32,633 --> 00:19:34,700
基於協議的模擬，現在我們想要

525
00:19:34,700 --> 00:19:36,133
來展示另一個選擇

526
00:19:36,133 --> 00:19:39,200
我在測試 HTTP時常常傾向使用的

527
00:19:39,200 --> 00:19:39,900
客戶端

528
00:19:39,900 --> 00:19:42,133
這種策略將保持我們的

529
00:19:42,133 --> 00:19:43,333
生產代碼整潔

530
00:19:43,333 --> 00:19:45,900
並使我們的測試更解耦於

531
00:19:45,900 --> 00:19:47,033
生產代碼

532
00:19:47,033 --> 00:19:49,333
絕對，我們不會模仿，而是將使用

533
00:19:49,333 --> 00:19:50,633
stubbing

534
00:19:50,633 --> 00:19:52,933
攔截網絡請求並

535
00:19:52,933 --> 00:19:53,733
返回

536
00:19:53,733 --> 00:19:56,000
stubbed 值，Foundation framework中有一種類型

537
00:19:56,000 --> 00:19:57,600
可以幫助我們

538
00:19:57,600 --> 00:19:58,133
實現這點

539
00:19:58,133 --> 00:20:01,266
URLProtocol APIs，對

540
00:20:01,266 --> 00:20:05,600
或者之前稱為 NSURLProtocol

541
00:20:05,600 --> 00:20:06,933
讓我們看看這個東西是

542
00:20:06,933 --> 00:20:09,200
如何運作的。每次我們執行一個 URL

543
00:20:09,200 --> 00:20:10,866
請求

544
00:20:10,866 --> 00:20:13,033
幕後的是

545
00:20:13,033 --> 00:20:14,933
有一個 URL 加載系統

546
00:20:14,933 --> 00:20:17,600
處理 URL 請求，作為

547
00:20:17,600 --> 00:20:18,300
這個 URL

548
00:20:18,300 --> 00:20:20,633
加載系統的一部分，有一種稱為

549
00:20:20,633 --> 00:20:21,733
URLProtocol

550
00:20:21,733 --> 00:20:23,733
的類別，它是繼承自

551
00:20:23,733 --> 00:20:25,033
NSObject的抽象類別

552
00:20:25,033 --> 00:20:28,233
如果我們創建我們自己的 URLProtocol

553
00:20:28,233 --> 00:20:30,766
子類型，並註冊，我們就可以開始

554
00:20:30,766 --> 00:20:31,666
攔截

555
00:20:31,666 --> 00:20:34,633
URL 請求，例如我們有 HTTP 

556
00:20:34,633 --> 00:20:36,933
協議，我們有 HTTPS 協議，但我們 

557
00:20:36,933 --> 00:20:38,400
可以創建我們自己的協議，我們自己的

558
00:20:38,400 --> 00:20:39,600
定制協議

559
00:20:39,600 --> 00:20:42,300
這多酷啊，是的，這是一個鮮為人知的

560
00:20:42,300 --> 00:20:42,766
部分

561
00:20:42,766 --> 00:20:45,033
可以說，它不是

562
00:20:45,033 --> 00:20:46,866
很知名的，你可以做一些 

563
00:20:46,866 --> 00:20:49,333
相當棘手的東西，你為什麼要這麼做

564
00:20:49,333 --> 00:20:51,200
嗯，這裡有幾個案例我 

565
00:20:51,200 --> 00:20:52,000
剛說的一個

566
00:20:52,000 --> 00:20:54,133
自訂 URL 協議，也許你正在

567
00:20:54,133 --> 00:20:55,500
嘗試與一個有自訂協議的服務器通訊 

568
00:20:55,500 --> 00:20:57,333
同樣，我們可以用它來實現本地 

569
00:20:57,333 --> 00:21:00,400
緩存系統

570
00:21:00,400 --> 00:21:01,333
我們可以使用它來獲取

571
00:21:01,333 --> 00:21:03,333
用於分析目的的一些數據 

572
00:21:03,333 --> 00:21:04,700
例如，我們進行了多少請求 

573
00:21:04,700 --> 00:21:06,466
或者甚至分析請求花費的時間

574
00:21:06,466 --> 00:21:08,633
或者我們攔截的時間

575
00:21:08,633 --> 00:21:10,866
請求時間，並且我們攔截

576
00:21:10,866 --> 00:21:13,666
處理中的任何URL請求

577
00:21:13,666 --> 00:21:14,466
應用程式

578
00:21:14,466 --> 00:21:16,533
我們只需實現一些

579
00:21:16,533 --> 00:21:17,666
抽象方法

580
00:21:17,666 --> 00:21:19,833
的URLProtocol類別，即使

581
00:21:19,833 --> 00:21:21,433
它被稱為URLProtocol

582
00:21:21,433 --> 00:21:24,233
這是一個類別，所以關鍵是

583
00:21:24,233 --> 00:21:25,100
在我們的情況下

584
00:21:25,100 --> 00:21:27,833
我們實際上可以創建一個URL的子類

585
00:21:27,833 --> 00:21:28,533
Protocol

586
00:21:28,533 --> 00:21:31,333
實現我們的stub行為, 以便我們可以

587
00:21:31,333 --> 00:21:33,500
在測試期間攔截你的請求

588
00:21:33,500 --> 00:21:35,433
並以stub請求完成，所以我們

589
00:21:35,433 --> 00:21:37,333
實際上從來沒有去雲端

590
00:21:37,333 --> 00:21:39,833
準確的說，這樣會使它更快並且

591
00:21:39,833 --> 00:21:40,533
可靠

592
00:21:40,533 --> 00:21:42,300
我們消除了網路連接的不穩定性，並且我們可以隱藏那些

593
00:21:42,300 --> 00:21:44,000
詳情

594
00:21:44,000 --> 00:21:44,700
從我們的產品代碼以及

595
00:21:44,700 --> 00:21:47,733
測試代碼將永遠不知道我們是否正在

596
00:21:47,733 --> 00:21:49,433
使用URLSession

597
00:21:49,433 --> 00:21:50,766
或者其他的抓取URLs的機制

598
00:21:50,766 --> 00:21:54,466
準確的說，我們可能正在使用框架AF

599
00:21:54,466 --> 00:21:57,100
Networking

600
00:21:57,100 --> 00:21:58,066
或者URLSessions或者甚至是傳統的


602
00:22:01,200 --> 00:22:03,900
URLConnections或其他可能

603
00:22:03,900 --> 00:22:04,400
出現的事物

604
00:22:04,400 --> 00:22:07,500
等等，讓我們來做這個

605
00:22:07,500 --> 00:22:09,666
好的，讓我們重構我們的測試用例以使用

606
00:22:09,666 --> 00:22:11,266
URL stub

607
00:22:11,266 --> 00:22:13,733
首先，讓我們去除

608
00:22:13,733 --> 00:22:14,466
協議

609
00:22:14,466 --> 00:22:17,666
並讓編譯器引導我們

610
00:22:17,666 --> 00:22:21,900
我需要把URLSession

611
00:22:21,900 --> 00:22:23,100
放回去，因為我們不打算模擬

612
00:22:23,100 --> 00:22:25,733
這個，我們甚至可以給它一個預設值

613
00:22:25,733 --> 00:22:28,066
對，那是共享的URLSession

614
00:22:28,066 --> 00:22:29,333
所以我們不需要模擬

615
00:22:29,333 --> 00:22:32,233
一個session，我很開心這麼做

616
00:22:32,233 --> 00:22:33,433
我们也不需要一个任务

617
00:22:33,433 --> 00:22:35,200
我们不需要停止一个任务，因为

618
00:22:35,200 --> 00:22:36,466
我们并没有测试实现

619
00:22:36,466 --> 00:22:37,033
再者，

620
00:22:37,033 --> 00:22:39,833
我认为我们甚至不需要这个测试

621
00:22:39,833 --> 00:22:41,266
它无关紧要，我们不希望再模拟

622
00:22:41,266 --> 00:22:42,866
了

623
00:22:42,866 --> 00:22:45,266
好的，所以在这个测试中，我们不再需要

624
00:22:45,266 --> 00:22:46,300
一个session.

625
00:22:46,300 --> 00:22:48,066
但我們仍需要停止 URL 與

626
00:22:48,066 --> 00:22:49,666
錯誤，但是現在這將是我們的

627
00:22:49,666 --> 00:22:50,300
URL

628
00:22:50,300 --> 00:22:52,933
ProtocolStub，我們不需要給它

629
00:22:52,933 --> 00:22:55,600
一個會話

630
00:22:55,600 --> 00:22:59,500
所以現在這個間諜將成為我們的ProtocolStub

631
00:22:59,500 --> 00:23:02,466
繼承自URLProtocol，再次明確一次

632
00:23:02,466 --> 00:23:04,000
再說一次讓事情變得明確

633
00:23:04,000 --> 00:23:06,400
這裡我們正在繼承URLProtocol，這是

634
00:23:06,400 --> 00:23:07,500
一個類

635
00:23:07,500 --> 00:23:09,600
如你們所見，URL protocol是一個類

636
00:23:09,600 --> 00:23:11,333
源自NSObject的继承

637
00:23:11,333 --> 00:23:14,866
是的，别被名称所迷惑

638
00:23:14,866 --> 00:23:17,333
我們不再需要任務了，我們

639
00:23:17,333 --> 00:23:18,466
不需要這個任務

640
00:23:18,466 --> 00:23:22,000
在這裡，我們需要錯誤訊息

641
00:23:22,000 --> 00:23:23,833
而我們也不再需要data task方法

642
00:23:23,833 --> 00:23:25,266
任何更多的

643
00:23:25,266 --> 00:23:27,900
我們來刪除這些無關緊要的模擬，是的，他們

644
00:23:27,900 --> 00:23:29,333
是不相關的

645
00:23:29,333 --> 00:23:32,133
看啊，好美的，那麼如我們所說，這裡有一些

646
00:23:32,133 --> 00:23:34,000
我們需要實現的方法

647
00:23:34,000 --> 00:23:36,466
如果你子類別化了URLProtocol類別

648
00:23:36,466 --> 00:23:37,900
首先，

649
00:23:37,900 --> 00:23:41,033
有一個類方法canInit

650
00:23:41,033 --> 00:23:44,933
帶有request且返回一個布林值

651
00:23:44,933 --> 00:23:47,833
所以，如果我們在這個方法中返回真，

652
00:23:47,833 --> 00:23:49,266
意味著我們可以處理這個請求

653
00:23:49,266 --> 00:23:50,933
現在我們有責任去

654
00:23:50,933 --> 00:23:52,400
完成請求是成功還是失敗

655
00:23:52,400 --> 00:23:54,466
也就說我們攔截了這個請求

656
00:23:54,466 --> 00:23:55,733
我們對它的命運有掌控權，

657
00:23:55,733 --> 00:23:59,100
對吧？

658
00:23:59,100 --> 00:24:00,700
我們如何知道我們可不可以處理

659
00:24:00,700 --> 00:24:02,766
這個請求呢？我們可以獲取URL

660
00:24:02,766 --> 00:24:05,100
從請求中獲取

661
00:24:05,100 --> 00:24:08,300
如果有的話，如果沒有

662
00:24:08,300 --> 00:24:10,700
在請求中的URL，我們就不能處理它

663
00:24:10,700 --> 00:24:11,833
所以讓我們返回假吧

664
00:24:11,833 --> 00:24:14,766
否則，我們需要檢查是否有一個

665
00:24:14,766 --> 00:24:15,333
stub

666
00:24:15,333 --> 00:24:18,766
對於那個URL，所以我們可以返回真

667
00:24:18,766 --> 00:24:21,733
如果我們有的話，否則我們返回假。所以如果

668
00:24:21,733 --> 00:24:22,533
這個是nil

669
00:24:22,533 --> 00:24:24,533
我們將返回假，如果這個

670
00:24:24,533 --> 00:24:26,233
不是空值我們將返回真

671
00:24:26,233 --> 00:24:28,066
這表示我們有一個替身代碼

672
00:24:28,066 --> 00:24:32,633
這當然現在是靜態變數

673
00:24:32,633 --> 00:24:34,866
這也是靜態替身方法

674
00:24:34,866 --> 00:24:35,733
因為你可以看到

675
00:24:35,733 --> 00:24:38,866
canInit作為一個類方法被調用

676
00:24:38,866 --> 00:24:41,033
所以我們還沒有一個實例

677
00:24:41,033 --> 00:24:42,866
URL加載系統

678
00:24:42,866 --> 00:24:46,233
只有在我們能處理該請求時才實例化我們的URLProtocolStub

679
00:24:46,233 --> 00:24:49,200
所以到這一點我們還沒有實例

680
00:24:49,200 --> 00:24:50,466
到現在為止。

681
00:24:50,466 --> 00:24:52,000
還沒有

682
00:24:52,000 --> 00:24:55,100
接下來我們需要重寫另一個類

683
00:24:55,100 --> 00:24:56,400
方法

684
00:24:56,400 --> 00:25:00,700
canonicalRequest for request 

685
00:25:00,700 --> 00:25:03,900
我們需要返回一個URLRequest

686
00:25:03,900 --> 00:25:05,033
由於我們不希望做任何事情

687
00:25:05,033 --> 00:25:07,900
對於這個請求我們可以直接返回它

688
00:25:07,900 --> 00:25:10,466
最後開始加載，這是一個

689
00:25:10,466 --> 00:25:11,600
實例方法

690
00:25:11,600 --> 00:25:13,733
這意味著框架已經接受了

691
00:25:13,733 --> 00:25:15,266
我們將處理這個請求

692
00:25:15,266 --> 00:25:16,933
現在它將呼喚我們說

693
00:25:16,933 --> 00:25:18,700
現在是你開始加載的時間

694
00:25:18,700 --> 00:25:20,400
這個URL

695
00:25:20,400 --> 00:25:23,600
所以再次，我們需要得到請求的URL

696
00:25:23,600 --> 00:25:25,200
請求

697
00:25:25,200 --> 00:25:28,933
請求是一個實例變量

698
00:25:28,933 --> 00:25:32,000
然後我們需要獲得我們的存根

699
00:25:32,000 --> 00:25:34,933
對於該URL，否則我們無法

700
00:25:34,933 --> 00:25:36,233
做我們只是返回

701
00:25:36,233 --> 00:25:38,933
是的，所以在我們完成之前

702
00:25:38,933 --> 00:25:40,066
帶有一個錯誤

703
00:25:40,066 --> 00:25:41,833
因為我們正在製作一個錯誤的存根

704
00:25:41,833 --> 00:25:43,733
我們可以在這裡做完全一樣的事情

705
00:25:43,733 --> 00:25:47,033
所以如果我們有一個錯誤我們需要告訴

706
00:25:47,033 --> 00:25:48,400
URL加載系統

707
00:25:48,400 --> 00:25:50,866
一個錯誤發生了，我們

708
00:25:50,866 --> 00:25:51,500
這樣做

709
00:25:51,500 --> 00:25:54,066
是通過使用URLProtocol的另一個實例屬性

710
00:25:54,066 --> 00:25:55,600
URLProtocol

711
00:25:55,600 --> 00:25:57,600
就是client，如你所見

712
00:25:57,600 --> 00:25:59,500
進行通訊的物件是protocol 

713
00:25:59,500 --> 00:26:01,200
與URL加載系統进行通信


714
00:26:01,200 --> 00:26:03,433
所以這個客戶端有一堆方法

715
00:26:03,433 --> 00:26:04,466
其中之一

716
00:26:04,466 --> 00:26:07,666
是告訴URL加載系統

717
00:26:07,666 --> 00:26:10,700
我們以錯誤結束

718
00:26:10,700 --> 00:26:12,866
完成後我們需要呼叫

719
00:26:12,866 --> 00:26:14,300
客戶端

720
00:26:14,300 --> 00:26:18,133
並告訴它我們已完成加載

721
00:26:18,133 --> 00:26:19,833
我們需要實施的最後一個方法是

722
00:26:19,833 --> 00:26:21,266
stopLoading

723
00:26:21,266 --> 00:26:23,833
所以我們沒有邏輯實施

724
00:26:23,833 --> 00:26:25,333
因此我們什麼也不做

725
00:26:25,333 --> 00:26:27,500
對，如果我們不實現它，那麼

726
00:26:27,500 --> 00:26:28,466
我們將在運行時崩潰

727
00:26:28,466 --> 00:26:30,766
這是一個代表性的

728
00:26:30,766 --> 00:26:31,900
抽象類別實例

729
00:26:31,900 --> 00:26:34,533
對，所以這就是所有

730
00:26:34,533 --> 00:26:35,666
我們需要的實施

731
00:26:35,666 --> 00:26:38,533
現在在測試中我們

732
00:26:38,533 --> 00:26:39,433
需要在URL加載

733
00:26:39,433 --> 00:26:42,133
系統中註冊該存根

734
00:26:42,133 --> 00:26:42,633
系統

735
00:26:42,633 --> 00:26:45,100
並如我們之前所演示，我們使用

736
00:26:45,100 --> 00:26:46,066
該協定

737
00:26:46,066 --> 00:26:49,100
註冊類URLStub

738
00:26:49,100 --> 00:26:51,600
並在測試完成後我們需要

739
00:26:51,600 --> 00:26:52,933
去

740
00:26:52,933 --> 00:26:55,200
取消註冊，因為我們不想

741
00:26:55,200 --> 00:26:56,000
進行stubbing

742
00:26:56,000 --> 00:26:58,866
其他測試請求，這看起來像是

743
00:26:58,866 --> 00:27:00,000
一個好候選

744
00:27:00,000 --> 00:27:02,700
移至setUp and tearDown的一對

745
00:27:02,700 --> 00:27:03,600
方法

746
00:27:03,600 --> 00:27:05,733
但由於我們只有一個測試我會

747
00:27:05,733 --> 00:27:06,700
樂於將它保留

748
00:27:06,700 --> 00:27:08,300
在這個測試中，現在並移動

749
00:27:08,300 --> 00:27:10,066
註冊/取消註冊

750
00:27:10,066 --> 00:27:12,466
當我們必須確定時，但我們允許的其中一個

751
00:27:12,466 --> 00:27:14,133
改善這裡可以做的是移動

752
00:27:14,133 --> 00:27:15,666
此註冊到

753
00:27:15,666 --> 00:27:18,366
ProtocolStub。然後，我們可以建立一個

754
00:27:18,366 --> 00:27:19,266
靜態的

755
00:27:19,266 --> 00:27:22,533
函數startIntercepting

756
00:27:22,533 --> 00:27:26,133
Requests並且我們也可以有

757
00:27:26,133 --> 00:27:29,200
stopIntercepting

758
00:27:29,200 --> 00:27:33,500
Requests，讓我們能取消註冊

759
00:27:33,500 --> 00:27:36,133
ProtocolStub並且也刪除

760
00:27:36,133 --> 00:27:38,366
stubs

761
00:27:38,366 --> 00:27:40,933
所以現在我們可以換掉註冊

762
00:27:40,933 --> 00:27:42,066
與

763
00:27:42,066 --> 00:27:48,000
開始和停止攔截請求

764
00:27:48,000 --> 00:27:50,133
讓我們現在運行測試，如果它通過的話

765
00:27:50,133 --> 00:27:51,833
這意味著我們正在攔截

766
00:27:51,833 --> 00:27:52,633
請求

767
00:27:52,633 --> 00:27:57,266
相應地並返回錯誤

768
00:27:57,266 --> 00:27:59,433
好極了，它通過了，這意味著我們得到了

769
00:27:59,433 --> 00:28:00,933
一個錯誤，使用

770
00:28:00,933 --> 00:28:03,666
stubbed error與URLProtocolStub

771
00:28:03,666 --> 00:28:05,333
所以現在我們的測試現在使用子類

772
00:28:05,333 --> 00:28:07,733
來模擬任何類型的URLSession

773
00:28:07,733 --> 00:28:09,666
這使我們的生產代碼有可能

774
00:28:09,666 --> 00:28:12,000
在未來被重構，以使用

775
00:28:12,000 --> 00:28:13,733
AFNetworking或者繼續使用新的APIs

776
00:28:13,733 --> 00:28:16,633
從URLSession

777
00:28:16,633 --> 00:28:18,066
或者甚至使用任何種類的機制

778
00:28:18,066 --> 00:28:20,466
用於加載經過URL的方法

779
00:28:20,466 --> 00:28:22,700
網址加載系統

780
00:28:22,700 --> 00:28:23,733
所以我對此感到滿意，太棒了，讓我們

781
00:28:23,733 --> 00:28:26,533
提交

782
00:28:26,533 --> 00:28:28,366
重構URLSession模擬

783
00:28:28,366 --> 00:28:32,233
使用URLProtocol的策略

784
00:28:32,233 --> 00:28:36,000
stubs以刪除測試耦合

785
00:28:36,000 --> 00:28:39,833
和URLSession

786
00:28:39,833 --> 00:28:43,033
類型，對，就是這樣

787
00:28:43,033 --> 00:28:47,033
所以我們有一個失敗的

788
00:28:47,033 --> 00:28:49,900
請求場景

789
00:28:49,900 --> 00:28:50,866
帶有錯誤是一個有效的路徑，這意味著

790
00:28:50,866 --> 00:28:53,333
我們嘗試執行一個請求

791
00:28:53,333 --> 00:28:55,033
但是出了點錯，但在一個

792
00:28:55,033 --> 00:28:56,633
但事情出問題了。

793
00:28:56,633 --> 00:28:58,133
在前一集，我們展示了

794
00:28:58,133 --> 00:29:01,266
一張包含所有案例的表格，這些案例能夠

795
00:29:01,266 --> 00:29:01,733
被

796
00:29:01,733 --> 00:29:05,733
三種選擇類型表示

797
00:29:05,733 --> 00:29:07,900
這意味著我們有一大堆無效的

798
00:29:07,900 --> 00:29:09,500
案例，一個錯誤

799
00:29:09,500 --> 00:29:12,000
並不是一個無效的案例，雖然那是個

800
00:29:12,000 --> 00:29:13,100
悲觀的路徑

801
00:29:13,100 --> 00:29:16,133
所以為了更明確地說，這裡的情況是

802
00:29:16,133 --> 00:29:19,833
數據是空的，response

803
00:29:19,833 --> 00:29:22,866
也是空的，我們有一個error值，這是個

804
00:29:22,866 --> 00:29:24,866
有效的情況，但這是悲觀的路徑

805
00:29:24,866 --> 00:29:26,466
我喜歡在

806
00:29:26,466 --> 00:29:28,466
測試中更明確，就像我們在表格中有的那樣

807
00:29:28,466 --> 00:29:30,466
就在這裡

808
00:29:30,466 --> 00:29:34,300
所以要停止這個，我們需要數據

809
00:29:34,300 --> 00:29:38,000
響應，它是一個URLResponse

810
00:29:38,000 --> 00:29:40,000
和Error，我們不需要預設

811
00:29:40,000 --> 00:29:41,100
的值

812
00:29:41,100 --> 00:29:45,333
嗯，這應該就夠了

813
00:29:45,333 --> 00:29:48,466
所以我們將數據和響應

814
00:29:48,466 --> 00:29:50,766
傳給初始化器，在啟動

815
00:29:50,766 --> 00:29:51,666
加載時

816
00:29:51,666 --> 00:29:56,300
我們可以檢查是否有數據


817
00:29:56,300 --> 00:30:00,233
我們可以告訴客戶我們已經載入了

818
00:30:00,233 --> 00:30:04,933
這些數據，如果我們有回應

819
00:30:04,933 --> 00:30:08,300
我們可以告訴客戶我們已經

820
00:30:08,300 --> 00:30:09,033
收到

821
00:30:09,033 --> 00:30:11,433
一個回應，並且此情況下的快取策略

822
00:30:11,433 --> 00:30:12,766
比如說不允許，我們不想要

823
00:30:12,766 --> 00:30:13,433
去快取

824
00:30:13,433 --> 00:30:16,633
對，我們不擔心那個，好的

825
00:30:16,633 --> 00:30:21,666
讓我們運行這個，並且它仍然通過

826
00:30:21,666 --> 00:30:23,733
非常完美，並且它更清晰，我更喜歡

827
00:30:23,733 --> 00:30:25,100
這樣的方式

828
00:30:25,100 --> 00:30:28,933
讓我們提交並添加新數據

829
00:30:28,933 --> 00:30:32,466
以及新回應至請求

830
00:30:32,466 --> 00:30:37,266
錯誤的測試案例以使設置過程

831
00:30:37,266 --> 00:30:40,933
更直接 看起來很不錯

832
00:30:40,933 --> 00:30:42,633
好的，我們在這個節目中已經完成了很多工作

833
00:30:42,633 --> 00:30:44,766
我認為我們終於找到了

834
00:30:44,766 --> 00:30:47,500
我們想要用於stubbing的答案

835
00:30:47,500 --> 00:30:48,366
請求

836
00:30:48,366 --> 00:30:50,533
我們不想要使用端對端測試

837
00:30:50,533 --> 00:30:51,500
在這個階段

838
00:30:51,500 --> 00:30:54,300
我們不想要使用subclassing 或者

839
00:30:54,300 --> 00:30:56,000
基於協議的模仿


840
00:30:56,000 --> 00:30:57,900
我們找到了一種保持我們的測試

841
00:30:57,900 --> 00:31:00,066
與實現解耦的方法

842
00:31:00,066 --> 00:31:01,500
並且也保持我們的生產

843
00:31:01,500 --> 00:31:03,266
實現不依賴於

844
00:31:03,266 --> 00:31:05,833
測試或協議或任何類型的

845
00:31:05,833 --> 00:31:06,300
模擬

846
00:31:06,300 --> 00:31:09,200
機制並查看更多一些

847
00:31:09,200 --> 00:31:10,066
偏僻的

848
00:31:10,066 --> 00:31:12,300
Foundation的地方我認為

849
00:31:12,300 --> 00:31:13,200
這很重要

850
00:31:13,200 --> 00:31:16,300
URL加載系統是

851
00:31:16,300 --> 00:31:17,900
所有專業開發人員可能

852
00:31:17,900 --> 00:31:19,600
應該知道的東西並且

853
00:31:19,600 --> 00:31:22,066
應該知道如何使用並利用

854
00:31:22,066 --> 00:31:23,433
根據情況來決定

855
00:31:23,433 --> 00:31:25,500
同意，所以在下一集我們將

856
00:31:25,500 --> 00:31:27,200
完成這個實現

857
00:31:27,200 --> 00:31:29,200
通過檢查所有無效情況並

858
00:31:29,200 --> 00:31:30,533
成功的情況

859
00:31:30,533 --> 00:31:45,999
好的，下次見，再見所有人，再見
