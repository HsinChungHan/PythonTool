

1
00:00:01,333 --> 00:00:03,166
你好 Mike，嘿，Caio

2
00:00:03,166 --> 00:00:05,733
所以今天我們來談談關於分解

3
00:00:05,733 --> 00:00:06,233
程式碼

4
00:00:06,233 --> 00:00:09,333
變成模組好嗎？更多模組化

5
00:00:09,333 --> 00:00:11,333
設計在這裡，所以讓我們使用相同的

6
00:00:11,333 --> 00:00:13,100
上次的示例

7
00:00:13,100 --> 00:00:15,033
我們創建了一個FeedViewController

8
00:00:15,033 --> 00:00:16,700
它參考了一個 FeedLoader

9
00:00:16,700 --> 00:00:17,733
協議

10
00:00:17,733 --> 00:00:19,166
然後我們有兩種類型那

11
00:00:19,166 --> 00:00:21,733
實現該協議，好吧，三種類型

12
00:00:21,733 --> 00:00:24,400
我們有 RemoteFeedLoader 和 Local

13
00:00:24,400 --> 00:00:25,266
FeedLoader

14
00:00:25,266 --> 00:00:26,866
然後我們有一個把兩者組合的

15
00:00:26,866 --> 00:00:28,633
我們說過了，

16
00:00:28,633 --> 00:00:31,266
我們通過使用這些不同的顏色

17
00:00:31,266 --> 00:00:33,333
將它們分解成模組，這意味著

18
00:00:33,333 --> 00:00:35,833
這裡有五個模組，其中四個

19
00:00:35,833 --> 00:00:36,633
是我們可以控制的，還有一個是

20
00:00:36,633 --> 00:00:38,800
UIKit

21
00:00:38,800 --> 00:00:39,900
我認為我們可以放大一點來演示一下

22
00:00:39,900 --> 00:00:42,633
這裡的模組化情況，我們開始吧

23
00:00:42,633 --> 00:00:44,366
一個更清楚的示例就是

24
00:00:44,366 --> 00:00:47,033
模組化的實現，所以讓我們從UIKit開始，

25
00:00:47,033 --> 00:00:49,733
這是一個簡單的例子

26
00:00:49,733 --> 00:00:52,066
所以這是UIKit，讓我們暫時忘記 

27
00:00:52,066 --> 00:00:54,133
類型，讓我們來思考模塊

28
00:00:54,133 --> 00:00:57,266
對，準確地說，UIKit上面我們有

29
00:00:57,266 --> 00:00:58,000
一個ViewController

30
00:00:58,000 --> 00:00:59,500
你會添加什麼類型的模塊到

31
00:00:59,500 --> 00:01:01,166
ViewController呢，對，我認為這個問題

32
00:01:01,166 --> 00:01:02,466
簡單，那就是UI

33
00:01:02,466 --> 00:01:05,666
模塊，好的，所以如果我們稱視圖

34
00:01:05,666 --> 00:01:08,300
為UI模塊，那麼是否有意義

35
00:01:08,300 --> 00:01:10,000
把FeedLoader協議

36
00:01:10,000 --> 00:01:13,333
作為一個UI元素，我認為這取決於

37
00:01:13,333 --> 00:01:16,066
FeedLoader在那裡代表了什麼，

38
00:01:16,066 --> 00:01:17,600
它代表一種行為，

39
00:01:17,600 --> 00:01:21,200
UI需要這種行為，就像一個功能，

40
00:01:21,200 --> 00:01:24,000
所以我想我們可以說是的，

41
00:01:24,000 --> 00:01:24,866
這也許是可能的，

42
00:01:24,866 --> 00:01:27,266
但再次，也許它可以位於

43
00:01:27,266 --> 00:01:28,400
它自己的模塊。

44
00:01:28,400 --> 00:01:30,700
但現在他們的顏色和

45
00:01:30,700 --> 00:01:32,000
在上一集中是一樣的，所以

46
00:01:32,000 --> 00:01:33,100
讓我們假定這個

47
00:01:33,100 --> 00:01:36,133
協議或介面就是一個

48
00:01:36,133 --> 00:01:38,133
我們正定義一個

49
00:01:38,133 --> 00:01:39,266
我們想要的行為

50
00:01:39,266 --> 00:01:41,433
但是我們還沒有並且我們希望另一個

51
00:01:41,433 --> 00:01:42,766
模塊來實現它

52
00:01:42,766 --> 00:01:45,500
好的，所以這代表一個邊界，對吧

53
00:01:45,500 --> 00:01:46,533
它是一個入口

54
00:01:46,533 --> 00:01:48,700
點或者甚至是一個出口點，消息從哪裡

55
00:01:48,700 --> 00:01:49,600
發出去

56
00:01:49,600 --> 00:01:51,900
進出，並且這是一個

57
00:01:51,900 --> 00:01:53,200
將模塊分開的點，這就是

58
00:01:53,200 --> 00:01:54,700
依賴反轉

59
00:01:54,700 --> 00:01:56,766
通過在前一個回合中引入這個協議，我們展示了如何

60
00:01:56,766 --> 00:01:58,766
UI停止依賴於具體的 Feed

61
00:01:58,766 --> 00:02:01,033
加載器，並且 Feed加载器不知道

62 
00:02:01,033 --> 00:02:03,100
關於 UI

63 
00:02:03,100 --> 00:02:04,366
對，所以這就是一個入口點

64 
00:02:04,366 --> 00:02:07,433
對 Feed

65 
00:02:07,433 --> 00:02:08,133
特徵，對，確實如此，所以我們稱之為

66 
00:02:08,133 --> 00:02:10,700
Feed 

67 
00:02:10,700 --> 00:02:11,833
特徵接口，對，我們可以在這裡有一堆

68 
00:02:11,833 --> 00:02:14,233
方法，在這裡我們可以有一堆接口

69 
00:02:14,233 --> 00:02:15,566
由外部

70 
00:02:15,566 --> 00:02:16,866
模塊來實現

71 
00:02:16,866 --> 00:02:18,533
這將由外部的

72 
00:02:18,533 --> 00:02:20,400
模塊來實現，所以在這種情況下我們有 Feed


73
00:02:20,400 --> 00:02:22,866
Loader，但我們可以有一個FeedItem

74
00:02:22,866 --> 00:02:26,233
結構作為傳遞資料的模型

75
00:02:26,233 --> 00:02:26,866
在各處

76
00:02:26,866 --> 00:02:30,000
沒錯，從模塊到模塊，所以Feed Feature

77
00:02:30,000 --> 00:02:31,033
接口是

78
00:02:31,033 --> 00:02:34,233
一堆功能，協定

79
00:02:34,233 --> 00:02:37,033
以及數據，只是這個時候它恰好在

80
00:02:37,033 --> 00:02:37,566
這一點

81
00:02:37,566 --> 00:02:39,833
它在與UI同一個模塊中生活

82
00:02:39,833 --> 00:02:40,633
我認為那是

83
00:02:40,633 --> 00:02:43,333
在我們頭腦中更好的視覺化方式

84
00:02:43,333 --> 00:02:44,633
可能是因為

85
00:02:44,633 --> 00:02:47,333
現在的RemoteFeedLoader依賴於

86
00:02:47,333 --> 00:02:48,133
一個Feed Feature

87
00:02:48,133 --> 00:02:51,833
而不是一個UI interface  

88
00:02:51,833 --> 00:02:54,866
沒錯，那麼這個RemoteFeedLoader是什麼呢？

89
00:02:54,866 --> 00:02:57,333
對，因此我們知道它有某種

90
00:02:57,333 --> 00:02:58,233
的互動

91
00:02:58,233 --> 00:03:02,466
與網絡，所以我們可以命名它為

92
00:03:02,466 --> 00:03:05,333
API模塊的組件，對，所以

93
00:03:05,333 --> 00:03:07,200
它就像是Feed API模塊

94
00:03:07,200 --> 00:03:09,733
例如，是的，而且LocalFeed

95
00:03:09,733 --> 00:03:10,700
Loader

96
00:03:10,700 --> 00:03:12,800
它與持久性有關，我很樂意

97
00:03:12,800 --> 00:03:14,866
將其命名為Database或類似的東西

98
00:03:14,866 --> 00:03:15,666
就像那樣

99
00:03:15,666 --> 00:03:19,033
對，一個儲存庫或資料庫

100
00:03:19,033 --> 00:03:20,800
對，然後我們有類型

101
00:03:20,800 --> 00:03:22,633
組成這兩者

102
00:03:22,633 --> 00:03:25,500
對，這是一個composer，我們

103
00:03:25,500 --> 00:03:26,633
通常組成

104
00:03:26,633 --> 00:03:29,100
類型在Main模塊裡，這是好

105
00:03:29,100 --> 00:03:30,766
主意，因為所有的箭頭

106
00:03:30,766 --> 00:03:33,666
都來自這個模塊，並且沒有

107
00:03:33,666 --> 00:03:34,533
箭頭

108
00:03:34,533 --> 00:03:38,000
指向這個模塊，所以Main

109
00:03:38,000 --> 00:03:41,033
我認為是一個很好的例子，對

110
00:03:41,033 --> 00:03:43,500
我們可以創建一個Adapter模塊或者我們

111
00:03:43,500 --> 00:03:45,266
可以創建一個Composer

112
00:03:45,266 --> 00:03:47,566
模塊或者我們可以只在Main裡留下它

113
00:03:47,566 --> 00:03:48,466
就這樣

114
00:03:48,466 --> 00:03:51,033
對，我們應該明白這些模塊可以包含

115
00:03:51,033 --> 00:03:52,400
許多組件，對，它只不過

116
00:03:52,400 --> 00:03:54,700
剛好我們展示了

117
00:03:54,700 --> 00:03:57,200
一個例子只有一個組件，一個類

118
00:03:57,200 --> 00:04:00,466
在每個模塊，但實際上他們可以

119
00:04:00,466 --> 00:04:02,933
包含很多

120
00:04:02,933 --> 00:04:04,633
有一堆

121
00:04:04,633 --> 00:04:06,400
對，Main模塊可以擁有App

122
00:04:06,400 --> 00:04:08,066
例如代理人


123
00:04:08,066 --> 00:04:09,900
你可以有許多工廠及

124
00:04:09,900 --> 00:04:12,133
組裝器，你也可以有組合器，

125
00:04:12,133 --> 00:04:14,933
轉接器，對，完全正確，API模組

126
00:04:14,933 --> 00:04:15,900
可以有

127
00:04:15,900 --> 00:04:18,933
服務，URLSessions，服務，

128
00:04:18,933 --> 00:04:20,633
數據庫可以有Core Data

129
00:04:20,633 --> 00:04:22,466
依賴，或是

130
00:04:22,466 --> 00:04:25,666
Realm，並且Feed功能組件

131
00:04:25,666 --> 00:04:27,333
可以有許多介面，正如我們

132
00:04:27,333 --> 00:04:29,166
提到的，還有Feed模型，

133
00:04:29,166 --> 00:04:31,600
對，這就是一種非常常見的方式

134
00:04:31,600 --> 00:04:32,466
組合，

135
00:04:32,466 --> 00:04:34,233
應用程式，如果你正在分解

136
00:04:34,233 --> 00:04:36,133
模塊，是的，我同意

137
00:04:36,133 --> 00:04:38,800
但可能某一刻我們會說，嗯，我

138
00:04:38,800 --> 00:04:40,400
想要有一個AppKit

139
00:04:40,400 --> 00:04:42,466
應用程式，同時使用那些

140
00:04:42,466 --> 00:04:43,500
其他種類，

141
00:04:43,500 --> 00:04:45,333
可能某一點我們會說，嗯，我們

142
00:04:45,333 --> 00:04:46,933
需要分離Feed

143
00:04:46,933 --> 00:04:49,333
特性與具體的UI，因為

144
00:04:49,333 --> 00:04:51,500
這個UI是一個UIKit

145
00:04:51,500 --> 00:04:54,833
使用者介面，所以你可能最終會

146
00:04:54,833 --> 00:04:56,400
有一個

147
00:04:56,400 --> 00:04:59,100
新的模組，Feed功能模組

148
00:04:59,100 --> 00:05:00,866
在那裡我們擁有所有的介面

149
00:05:00,866 --> 00:05:03,100
和共享模型，但重要的是要

150
00:05:03,100 --> 00:05:04,066
說明這個

151
00:05:04,066 --> 00:05:05,666
Feed Feature模塊並不依賴於任何

152
00:05:05,666 --> 00:05:07,666
其他模塊，那裡沒有箭頭

153
00:05:07,666 --> 00:05:08,866
從這裡出來

154
00:05:08,866 --> 00:05:11,100
只有箭頭指向它，這是邊界

155
00:05:11,100 --> 00:05:12,066
模塊

156
00:05:12,066 --> 00:05:15,900
完全正確。現在我們可以擁有不同的UI

157
00:05:15,900 --> 00:05:18,000
並且能夠按需要來組裝這些

158
00:05:18,000 --> 00:05:19,733
模塊

159
00:05:19,733 --> 00:05:22,866
在紙上看起來很好，但

160
00:05:22,866 --> 00:05:26,466
這不是每天的使用情境

161
00:05:26,466 --> 00:05:29,100
但是，不一定要那樣

162
00:05:29,100 --> 00:05:29,733
為了

163
00:05:29,733 --> 00:05:32,700
創建這樣的架構

164
00:05:32,700 --> 00:05:33,733
因為

165
00:05:33,733 --> 00:05:37,666
像你說的，這樣的設計使我們能夠

166
00:05:37,666 --> 00:05:41,900
在不知道系統其餘部分的情況下

167
00:05:41,900 --> 00:05:44,400
更換模塊或組件而不

168
00:05:44,400 --> 00:05:46,233
依賴於系統的其餘部分

169
00:05:46,233 --> 00:05:49,166
並能進行隔離測試，沒錯 沒錯

170
00:05:49,166 --> 00:05:50,233
完全正確的

171
00:05:50,233 --> 00:05:53,600
使我們能夠進行隔離測試並且

172
00:05:53,600 --> 00:05:55,333
我們可以在不同的地方重複利用這些

173
00:05:55,333 --> 00:05:56,866
應用程式

174
00:05:56,866 --> 00:05:59,333
但這並不是通常的使用情況

175
00:05:59,333 --> 00:06:00,866
通常你只有一個應用程式

176
00:06:00,866 --> 00:06:04,133
而它是iOS或僅限於macOS

177
00:06:04,133 --> 00:06:06,933
你並不需要重複使用

178
00:06:06,933 --> 00:06:08,233
在其他應用程式中你不需要

179
00:06:08,233 --> 00:06:09,433
有使用這些的需求

180
00:06:09,433 --> 00:06:12,233
進入其他平台，那麼還有其他

181
00:06:12,233 --> 00:06:13,666
方式我們可以組織這個，我們不需要

182
00:06:13,666 --> 00:06:15,900
從這種級別的分離開始

183
00:06:15,900 --> 00:06:18,300
這可能是一種極端的情況，其中

184
00:06:18,300 --> 00:06:19,666
所有東西都被分解

185
00:06:19,666 --> 00:06:21,833
在單獨的模塊中，但這裡的重點是

186
00:06:21,833 --> 00:06:23,900
有可能做到

187
00:06:23,900 --> 00:06:26,000
如果有這需求，它應該能

188
00:06:26,000 --> 00:06:27,666
很容易地適應

189
00:06:27,666 --> 00:06:30,800
但是一個簡單得多的应用程式

190
00:06:30,800 --> 00:06:33,433
例如 API，Database 和

191
00:06:33,433 --> 00:06:34,800
功能介面

192
00:06:34,800 --> 00:06:37,266
和模型在同一模塊中，你

193
00:06:37,266 --> 00:06:39,500
可以選擇分離 UI

194
00:06:39,500 --> 00:06:41,833
對，所以在這裡我們有 API，

195
00:06:41,833 --> 00:06:43,666
Database 和 Feed Feature

196
00:06:43,666 --> 00:06:46,700
滿載紅色的模組，表示他們

197
00:06:46,700 --> 00:06:47,100
都

198
00:06:47,100 --> 00:06:48,800
在相同的模組中，在同一個模組中

199
00:06:48,800 --> 00:06:50,400
基本上就是這樣，沒錯

200
00:06:50,400 --> 00:06:52,700
然後 UI 對此有依賴關係

201
00:06:52,700 --> 00:06:53,833
Feed Feature

202
00:06:53,833 --> 00:06:56,133
這可能會產生一些耦合

203
00:06:56,133 --> 00:06:57,500
特別是 API 和

204
00:06:57,500 --> 00:06:58,400
這邊的 Database

205
00:06:58,400 --> 00:07:00,700
這個圖表並未顯示出來，但是它

206
00:07:00,700 --> 00:07:02,700
有可能實際上是這樣

207
00:07:02,700 --> 00:07:06,233
只要你不添加依賴關係

208
00:07:06,233 --> 00:07:07,033
在這裡

209
00:07:07,033 --> 00:07:10,300
正確，或者反過來也說得通

210
00:07:10,300 --> 00:07:11,666
如你所說，你可以創建一些

211
00:07:11,666 --> 00:07:13,566
這裡不需要的耦合

212
00:07:13,566 --> 00:07:15,566
也許你的 UI 不需要一個 database

213
00:07:15,566 --> 00:07:17,033
但只要箭頭

214
00:07:17,033 --> 00:07:18,700
指向相同的方向並與

215
00:07:18,700 --> 00:07:20,533
同一級別的抽象

216
00:07:20,533 --> 00:07:23,166
你仍然能夠需要時進行分解

217
00:07:23,166 --> 00:07:24,633
如果在某一點你想重用該

218
00:07:24,633 --> 00:07:26,633
API 的另一個應用，你只需要將其移動

219
00:07:26,633 --> 00:07:27,433
到另一個

220
00:07:27,433 --> 00:07:29,033
框架，然後如果有需要


221
00:07:29,033 --> 00:07:30,933
要分享數據庫，您同樣這麼做

222
00:07:30,933 --> 00:07:33,033
然後你回到這裡，我們應該能夠

223
00:07:33,033 --> 00:07:33,833
能夠繼續

224
00:07:33,833 --> 00:07:38,633
從同一模組的所有事物

225
00:07:38,633 --> 00:07:40,533
正確設置您的模組，然後你可以

226
00:07:40,533 --> 00:07:41,733
甚至決定把

227
00:07:41,733 --> 00:07:43,433
甚至一個 Composer 都放在同一模組中

228
00:07:43,433 --> 00:07:45,333
例如，然後你就沒有 Main

229
00:07:45,333 --> 00:07:46,133
模組

230
00:07:46,133 --> 00:07:48,466
或者可能 UI 就是這個案例中的 Main 模組

231
00:07:48,466 --> 00:07:49,900
因為它將直接組成

232
00:07:49,900 --> 00:07:52,000
那些直接類型

233
00:07:52,000 --> 00:07:54,400
或者你可以有同一模組的所有東西

234
00:07:54,400 --> 00:07:56,000
除了 UIKit，因為我們

235
00:07:56,000 --> 00:07:56,633
不擁有

236
00:07:56,633 --> 00:08:00,133
UIKit，對，這就是

237
00:08:00,133 --> 00:08:03,266
像他們所說的單體應用程序的情況

238
00:08:03,266 --> 00:08:04,000
對

239
00:08:04,000 --> 00:08:06,633
對，這是一個單體，但它依然很好地

240
00:08:06,633 --> 00:08:08,533
進行了區分，這意味著我們可以分解這個

241
00:08:08,533 --> 00:08:10,000
單體，按需要进行

242
00:08:10,000 --> 00:08:12,066
我會建議人們從這裡開始

243
00:08:12,066 --> 00:08:13,500
可能在這裡保持所有東西在

244
00:08:13,500 --> 00:08:14,633
同一模組中

245
00:08:14,633 --> 00:08:16,933
但保持邏輯的區分

246
00:08:16,933 --> 00:08:17,900
關注點

247
00:08:17,900 --> 00:08:20,000
所以如果你需要把它拆解

248
00:08:20,000 --> 00:08:21,333
這很容易，所以大型單體結構

249
00:08:21,333 --> 00:08:22,300
monolith

250
00:08:22,300 --> 00:08:24,000
並沒有什麼不對，只要你保持你的類型模組化

251
00:08:24,000 --> 00:08:25,900
在大型單體結構內，而且，如我們在

252
00:08:25,900 --> 00:08:27,266
上一集中見到的，你有相同的

253
00:08:27,266 --> 00:08:28,233
代碼量，

254
00:08:28,233 --> 00:08:30,466
你只是將它們拆分成小

255
00:08:30,466 --> 00:08:32,700
類或結構體或函數，

256
00:08:32,700 --> 00:08:35,100
並在它們之間保持乾淨的介面

257
00:08:35,100 --> 00:08:36,533
對，確實。

258
00:08:36,533 --> 00:08:38,766
然而，在這種大型單體結構的

259
00:08:38,766 --> 00:08:40,766
方法中最大的缺點，我想這是一種

260
00:08:40,766 --> 00:08:41,566
偏好問題，但

261
00:08:41,566 --> 00:08:43,500
如果你正在創建一個iOS項目，你將

262
00:08:43,500 --> 00:08:45,266
必須看模擬器，

263
00:08:45,266 --> 00:08:48,300
而，老實說，這讓我感到困擾，要透過

264
00:08:48,300 --> 00:08:49,100
測試

265
00:08:49,100 --> 00:08:51,333
API組件或數據庫組件

266
00:08:51,333 --> 00:08:52,633
透過模擬器，

267
00:08:52,633 --> 00:08:55,433
而不是將Mac作為一個測試

268
00:08:55,433 --> 00:08:56,366
目標並擁有

269
00:08:56,366 --> 00:08:58,866
你說過，我們可以快速進行單元測試，如果

270
00:08:58,866 --> 00:09:00,233
我們有一個Database

271
00:09:00,233 --> 00:09:03,433
模組並沒有包含在iOS目標中

272
00:09:03,433 --> 00:09:06,066
我們可以直接執行它，不需要模擬器，對嗎？

273
00:09:06,066 --> 00:09:07,033
就是這樣

274
00:09:07,033 --> 00:09:08,366
我們可以直接進行測試，也不需要

275
00:09:08,366 --> 00:09:11,200
模擬器，是的，APIs也是一樣的

276
00:09:11,200 --> 00:09:13,100
以及所有不需要

277
00:09:13,100 --> 00:09:16,700
UI的型別，沒錯，若能直接測試那些型別將更好，

278
00:09:16,700 --> 00:09:19,100
而不用模擬器

279
00:09:19,100 --> 00:09:20,933
但如果他們存在於一個iOS目標中

280
00:09:20,933 --> 00:09:23,266
要進行測試，你需要開啟一個

281
00:09:23,266 --> 00:09:24,133
模擬器

282
00:09:24,133 --> 00:09:27,500
這個過程可能需要花費三到五倍的時間，

283
00:09:27,500 --> 00:09:30,066
或者更多

284
00:09:30,066 --> 00:09:34,133
這樣的成本是很高的，會累積起來

285
00:09:34,133 --> 00:09:36,133
所以是有權衡的，您極有可能可以

286
00:09:36,133 --> 00:09:37,266
從這樣開始

287
00:09:37,266 --> 00:09:39,500
如果你看到需要更快的測試

288
00:09:39,500 --> 00:09:41,500
這可能是

289
00:09:41,500 --> 00:09:44,366
對某些人立即進行的，那麼你可以

290
00:09:44,366 --> 00:09:45,200
直接


291
00:09:45,200 --> 00:09:48,133
用這些邊界提取你的程式碼

292
00:09:48,133 --> 00:09:49,100
並且

293
00:09:49,100 --> 00:09:51,433
有好的源碼依賴關係但你

294
00:09:51,433 --> 00:09:53,666
也增加了一些維護

295
00:09:53,666 --> 00:09:55,500
獨立框架的負擔絕對的

296
00:09:55,500 --> 00:09:56,700
絕對的那是

297
00:09:56,700 --> 00:09:59,266
那嘛那嘛其中一個取捨所以

298
00:09:59,266 --> 00:10:00,366
那就是說

299
00:10:00,366 --> 00:10:02,633
組成類型的一種方法在獨立的

300
00:10:02,633 --> 00:10:04,633
模組中你可以有所有的類型在

301
00:10:04,633 --> 00:10:05,666
一個模組之中

302
00:10:05,666 --> 00:10:07,500
但只要它們分開你的

303
00:10:07,500 --> 00:10:09,033
monolith仍然

304
00:10:09,033 --> 00:10:11,666
能夠被需要的時候將測試和分解

305
00:10:11,666 --> 00:10:12,300
你可以

306
00:10:12,300 --> 00:10:14,366
將這些類型移至獨立模組以便

307
00:10:14,366 --> 00:10:16,133
易用性與可測試性

308
00:10:16,133 --> 00:10:19,266
為了更快的測試或者是為了任何原因

309
00:10:19,266 --> 00:10:20,533
你需要移動它們

310
00:10:20,533 --> 00:10:23,666
但為什麼很少看到應用程序他們

311
00:10:23,666 --> 00:10:24,300
是

312
00:10:24,300 --> 00:10:28,066
可以組合或分解,在我看來

313
00:10:28,066 --> 00:10:29,266
我認為是因為

314
00:10:29,266 --> 00:10:32,366
這更難做需要一個深入的

315
00:10:32,366 --> 00:10:33,900
學習曲線在那裡

316
00:10:33,900 --> 00:10:36,866
我們經常看到開發者希望

317
00:10:36,866 --> 00:10:38,066
控制

318
00:10:38,066 --> 00:10:40,933
對他們的組件以及參考

319
00:10:40,933 --> 00:10:42,000
組件

320
00:10:42,000 --> 00:10:44,366
在其他組件內部沒有好的

321
00:10:44,366 --> 00:10:45,433
分隔

322
00:10:45,433 --> 00:10:47,833
像依賴注入，初始化器

323
00:10:47,833 --> 00:10:49,333
在這種情況下你知道

324
00:10:49,333 --> 00:10:52,000
強制不可變性所以使用

325
00:10:52,000 --> 00:10:53,200
具體類型

326
00:10:53,200 --> 00:10:56,133
你會感覺更有控制力，甚至擁有

327
00:10:56,133 --> 00:10:57,433
程序碼

328
00:10:57,433 --> 00:10:58,700
感覺你更有控制力

329
00:10:58,700 --> 00:11:00,133
因為你可以逐行看到什麼

330
00:11:00,133 --> 00:11:00,700
正在發生

331
00:11:00,700 --> 00:11:02,133
但一旦你開始使用動態

332
00:11:02,133 --> 00:11:05,033
調度並開始命名界面

333
00:11:05,033 --> 00:11:07,200
和閉包，人們開始害怕

334
00:11:07,200 --> 00:11:08,366
是的，絕對是

335
00:11:08,366 --> 00:11:10,866
所以對於未受過訓練的人來說，這可能

336
00:11:10,866 --> 00:11:12,533
更難以抽象思考

337
00:11:12,533 --> 00:11:15,833
例如，在函數中調用一個閉包

338
00:11:15,833 --> 00:11:16,700
函數

339
00:11:16,700 --> 00:11:18,933
而不是擁有一個隱含的依賴性

340
00:11:18,933 --> 00:11:20,300
讓我們說一個單例

341
00:11:20,300 --> 00:11:22,800
並調用單例的函數

342
00:11:22,800 --> 00:11:24,133
直接

343
00:11:24,133 --> 00:11:26,466
這可能會讓他們

344
00:11:26,466 --> 00:11:28,700
擁有一種我們常見的架構

345
00:11:28,700 --> 00:11:31,833
在 iOS 應用程序中，我們會有 UI

346
00:11:31,833 --> 00:11:33,833
與具體模型層進行對話，

347
00:11:33,833 --> 00:11:35,900
這可能是 ViewModel 或者是 Presenter

348
00:11:35,900 --> 00:11:37,266
然後直接與另一個

349
00:11:37,266 --> 00:11:39,600
具體的 API 或者是具體的 Database 對話，

350
00:11:39,600 --> 00:11:40,933
它可能是單例，或者可以是

351
00:11:40,933 --> 00:11:42,700
插件，但它們是具體存在的，

352
00:11:42,700 --> 00:11:44,533
並且組裝的不太容易。

353
00:11:44,533 --> 00:11:45,733
你可能會有一次

354
00:11:45,733 --> 00:11:47,833
通過子類化注入不同行為的機會，

355
00:11:47,833 --> 00:11:49,200
但是

356
00:11:49,200 --> 00:11:52,000
你將會在 Model 層看見 UIKit的元素，

357
00:11:52,000 --> 00:11:52,800
甚至可能

358
00:11:52,800 --> 00:11:54,800
在 API 或 Database 層看見像

359
00:11:54,800 --> 00:11:56,133
UIImages 的 UIKit 元素，

360
00:11:56,133 --> 00:11:58,633
它們並沒有清晰的分隔。

361
00:11:58,633 --> 00:12:00,000
有時候你會看到 UI

362
00:12:00,000 --> 00:12:02,533
直接從 Database 中取得資料，

363
00:12:02,533 --> 00:12:04,133
或者是從 API。

364
00:12:04,133 --> 00:12:05,733
而我們常常會看見 UI

365
00:12:05,733 --> 00:12:07,733
元素訪問

366
00:12:07,733 --> 00:12:09,100
databases 和 APIs 

367
00:12:09,100 --> 00:12:12,066
建議為了方便或者更快，

368
00:12:12,066 --> 00:12:14,300
在許多時候可能是較便捷或更快的途徑。

369
00:12:14,300 --> 00:12:16,933
但你很快地失去了所

370
00:12:16,933 --> 00:12:18,533
希望在一開始就能控制的

371
00:12:18,533 --> 00:12:19,333
控制權

372
00:12:19,333 --> 00:12:22,000
是的，我認為在這個範例中

373
00:12:22,000 --> 00:12:23,433
問題在於沒有適當的

374
00:12:23,433 --> 00:12:24,466
通訊方式

375
00:12:24,466 --> 00:12:27,100
在這些模塊之間，並沒有

376
00:12:27,100 --> 00:12:29,200
預定義的通訊頻道也許

377
00:12:29,200 --> 00:12:30,000
他們將會是

378
00:12:30,000 --> 00:12:32,366
雙向或單向的

379
00:12:32,366 --> 00:12:34,133
在Model和

380
00:12:34,133 --> 00:12:36,300
UI或者是UI和Model之間的溝通

381
00:12:36,300 --> 00:12:38,933
API和Model，Database和

382
00:12:38,933 --> 00:12:39,666
Model

383
00:12:39,666 --> 00:12:42,000
所以我們將看到元件被

384
00:12:42,000 --> 00:12:44,300
引用在各種地方，UI在

385
00:12:44,300 --> 00:12:46,633
Database或者是Database在

386
00:12:46,633 --> 00:12:47,733
UI

387
00:12:47,733 --> 00:12:51,200
這可能會創造出緊密耦合以及



388
00:12:51,200 --> 00:12:54,533
混淆和僵化隨著進行

389
00:12:54,533 --> 00:12:57,433
所謂的spaghetti architecture是的並且

390
00:12:57,433 --> 00:12:58,233
公平地說

391
00:12:58,233 --> 00:12:59,833
你仍然可以有一個具體的

392
00:12:59,833 --> 00:13:02,133
架構在沒有spaghetti

393
00:13:02,133 --> 00:13:05,266
如果你保持層次分離的話


394
00:13:05,266 --> 00:13:07,200
像這樣可能對多數的

395
00:13:07,200 --> 00:13:08,866
applications來說是有效的

396
00:13:08,866 --> 00:13:10,800
當然，這也取決於你使用的application

397
00:13:10,800 --> 00:13:12,700
我正在工作的如果是非常簡單的

398
00:13:12,700 --> 00:13:14,466
我可能會先從這樣開始

399
00:13:14,466 --> 00:13:16,466
但我知道如何從這種

400
00:13:16,466 --> 00:13:18,066
architecture

401
00:13:18,066 --> 00:13:21,033
轉變到更模塊化的方式，我會根據需要進行這種轉變

402
00:13:21,033 --> 00:13:22,633
這得由測試和compiler支持

403
00:13:22,633 --> 00:13:24,633
使用測試和compiler支持

404
00:13:24,633 --> 00:13:26,000
compiler

405
00:13:26,000 --> 00:13:27,833
所以從這樣開始並無不妥

406
00:13:27,833 --> 00:13:29,266
或者擁有一種架構

407
00:13:29,266 --> 00:13:31,033
它可能是超級monolithic的，然後根據需要分解它

408
00:13:31,033 --> 00:13:32,533
按需分解它

409
00:13:32,533 --> 00:13:34,800
您不必從一個非常

410
00:13:34,800 --> 00:13:36,300
模塊化的application開始

411
00:13:36,300 --> 00:13:38,066
另外，模塊化的application並不意味著

412
00:13:38,066 --> 00:13:40,300
它必須是复杂的

413
00:13:40,300 --> 00:13:43,100
對，這可十分重要，如果我們遵循

414
00:13:43,100 --> 00:13:43,666
好的

415
00:13:43,666 --> 00:13:45,900
原則，我們可以結束使用相當

416
00:13:45,900 --> 00:13:47,500
優秀的architecture

417
00:13:47,500 --> 00:13:48,700
我見過那些代碼庫，它們是

418
00:13:48,700 --> 00:13:50,700
monolithic的，並且非常具體

419
00:13:50,700 --> 00:13:51,333
但他們

420
00:13:51,333 --> 00:13:54,366
容易改變，他們容易處理

421
00:13:54,366 --> 00:13:55,900
他們被測試過，你只需要

422
00:13:55,900 --> 00:13:57,100
理解平衡點，你需要

423
00:13:57,100 --> 00:13:58,533
理解你試圖解決的問題

424
00:13:58,533 --> 00:14:00,466
並為此提供解決方案

425
00:14:00,466 --> 00:14:02,633
是的，這是最重要的

426
00:14:02,633 --> 00:14:03,600
要記住的事情

427
00:14:03,600 --> 00:14:06,933
在建築或設計上不存在至高無上的標準，

428
00:14:06,933 --> 00:14:09,166
你需要依據你的需求來做調整

429
00:14:09,166 --> 00:14:10,800
依你的需求來製定，

430
00:14:10,800 --> 00:14:13,033
就像我的朋友常說的，你不能

431
00:14:13,033 --> 00:14:13,833
兩隻腳

432
00:14:13,833 --> 00:14:16,133
塞進一雙鞋裡。你需要

433
00:14:16,133 --> 00:14:17,266
根據自己的

434
00:14:17,266 --> 00:14:20,800
需求進行量身打造，但這確實

435
00:14:20,800 --> 00:14:22,633
很難，所以我的

436
00:14:22,633 --> 00:14:25,100
建議是學習不同的方法

437
00:14:25,100 --> 00:14:26,700
因為你知道的越多，你解決問題的

438
00:14:26,700 --> 00:14:28,866
選擇就越多

439
00:14:28,866 --> 00:14:30,866
我們遇到問題，然後我們找解決方案

440
00:14:30,866 --> 00:14:32,133
我們不會只


441
00:14:32,133 --> 00:14:36,300
較小的價值，是的，絕對的，例如

442
00:14:36,300 --> 00:14:39,500
回到我們的超模塊化方法

443
00:14:39,500 --> 00:14:41,266
您可以再有另一個模塊

444
00:14:41,266 --> 00:14:43,600
是組裝者、建造者或工廠

445
00:14:43,600 --> 00:14:45,500
將所有東西組織在一起，哇

446
00:14:45,500 --> 00:14:47,500
有很多破折號和很多

447
00:14:47,500 --> 00:14:48,466
箭頭在那裡

448
00:14:48,466 --> 00:14:51,033
看起來可能複雜，但當你

449
00:14:51,033 --> 00:14:52,366
將這個轉譯成程式碼

450
00:14:52,366 --> 00:14:54,633
四行程式碼、兩行程式碼或者

451
00:14:54,633 --> 00:14:55,666
一行程式碼

452
00:14:55,666 --> 00:14:58,000
其實並不困難，它質樸，它可以

453
00:14:58,000 --> 00:14:59,900
達到相同層次的分離

454
00:14:59,900 --> 00:15:02,533
通過遵循OO原理或功能

455
00:15:02,533 --> 00:15:03,433
原理

456
00:15:03,433 --> 00:15:06,466
是的，我百分之一百同意你，這可能

457
00:15:06,466 --> 00:15:09,733
看起來複雜，但實際上並不，它簡單

458
00:15:09,733 --> 00:15:12,533
並值得你們自己去試

459
00:15:12,533 --> 00:15:13,500
驗證

460
00:15:13,500 --> 00:15:15,166
所以我認為就這樣，我們將會

461
00:15:15,166 --> 00:15:27,100
下次再見