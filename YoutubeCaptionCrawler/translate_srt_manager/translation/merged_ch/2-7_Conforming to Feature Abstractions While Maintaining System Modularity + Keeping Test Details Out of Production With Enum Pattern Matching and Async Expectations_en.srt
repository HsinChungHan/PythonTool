

1
00:00:01,266 --> 00:00:03,500
你好 Mike，嘿 Caio，所以在上一次

2
00:00:03,500 --> 00:00:04,766
我們已經完成了

3
00:00:04,766 --> 00:00:06,700
RemoteFeedLoader 的實現，然後

4
00:00:06,700 --> 00:00:08,700
現在該讓它符合

5
00:00:08,700 --> 00:00:11,033
在 FeedFeature module 中的 

6
00:00:11,033 --> 00:00:12,000
FeedLoader 的協議

7
00:00:12,000 --> 00:00:14,466
對，所以 FeedLoader 協議有一個

8
00:00:14,466 --> 00:00:15,100
函數就是

9
00:00:15,100 --> 00:00:17,433
帶有結束條款的load，以及 LoadFeed

10
00:00:17,433 --> 00:00:18,133
的結果

11
00:00:18,133 --> 00:00:20,800
不錯，而我們的實作也類似

12
00:00:20,800 --> 00:00:22,933
但我們是使用

13
00:00:22,933 --> 00:00:26,000
在這裡的 Result 類型並配合我們自己的 domain

14
00:00:26,000 --> 00:00:28,933
特定的 Error 類型，但是

15
00:00:28,933 --> 00:00:30,933
FeedLoader 的 Error 類型只是一個

16
00:00:30,933 --> 00:00:34,233
Swift 的 Error 協議，這可能會引起

17
00:00:34,233 --> 00:00:35,266
一些問題

18
00:00:35,266 --> 00:00:37,900
我們可以把 FeedLoader 的 Error 類型

19
00:00:37,900 --> 00:00:39,033
移到 FeedFeatures module 

20
00:00:39,033 --> 00:00:42,300
這樣就把這個 API 

21
00:00:42,300 --> 00:00:44,633
實現的細節暴露在共享的

22
00:00:44,633 --> 00:00:45,500
特性模塊中

23
00:00:45,500 --> 00:00:48,633
我並不喜歡這樣，因為 Feed 

24
00:00:48,633 --> 00:00:49,266
功能

25
00:00:49,266 --> 00:00:51,833
是一種不明確的模塊，它並不知道該錯誤是否會

26
00:00:51,833 --> 00:00:52,866
創建

27
00:00:52,866 --> 00:00:55,333
連接性，無效數據意即來源於

28
00:00:55,333 --> 00:00:56,300
API

29
00:00:56,300 --> 00:00:59,333
或是來自於本地資料庫或未來

30
00:00:59,333 --> 00:01:00,533
的實作碼

31
00:01:00,533 --> 00:01:02,700
對吧，所以我們不希望有任何

32
00:01:02,700 --> 00:01:04,633
對Feed Feature的知識

33
00:01:04,633 --> 00:01:07,833
關於這些錯誤的來源尚未確定

34
00:01:07,833 --> 00:01:09,266
也許在未來我們會

35
00:01:09,266 --> 00:01:10,933
察覺到有一些相似性

36
00:01:10,933 --> 00:01:12,400
我們可以創建一個針對

37
00:01:12,400 --> 00:01:14,400
Feed Feature的

38
00:01:14,400 --> 00:01:16,066
特定錯誤模組。但我現在還沒有

39
00:01:16,066 --> 00:01:16,700
足夠的信心

40
00:01:16,700 --> 00:01:20,533
還是要去做嗎？所以這會讓我們

41
00:01:20,533 --> 00:01:24,000
採用LoadFeedResult嗎？

42
00:01:24,000 --> 00:01:28,066
讓我們看看，首先這是公開的

43
00:01:28,066 --> 00:01:29,033
方法

44
00:01:29,033 --> 00:01:34,300
所以我們需要讓它公開

45
00:01:34,300 --> 00:01:37,600
我們稱之為成功和失敗

46
00:01:37,600 --> 00:01:39,666
但這裡是成功和錯誤，我覺得我

47
00:01:39,666 --> 00:01:41,666
比較偏好失敗這個名稱

48
00:01:41,666 --> 00:01:45,900
對，我同意。但如今既然

49
00:01:45,900 --> 00:01:49,033
LoadFeedResult揭示了Swift Error

50
00:01:49,033 --> 00:01:49,666
協定

51
00:01:49,666 --> 00:01:51,600
我們需要給予它更多類型

52
00:01:51,600 --> 00:01:53,266
這裡需要更多資訊，對嗎？

53
00:01:53,266 --> 00:01:56,066
所以這個錯誤是域級別的錯誤

54
00:01:56,066 --> 00:01:59,666
適用於RemoteFeedLoader

55
00:01:59,666 --> 00:02:02,933
現在FeedItemsMapper正在使用

56
00:02:02,933 --> 00:02:05,433
RemoteFeedLoader.Result，對吧？

57
00:02:05,433 --> 00:02:08,000
我認為我們可以通過使用型別

58
00:02:08,000 --> 00:02:08,633
別名

59
00:02:08,633 --> 00:02:12,066
來解決這個問題，所以我們可以使這個Result

60
00:02:12,066 --> 00:02:13,500
類型只是一個型別別名

61
00:02:13,500 --> 00:02:16,233
為LoadFeedResult，所以其他

62
00:02:16,233 --> 00:02:18,033
正在使用Remote的組件

63
00:02:18,033 --> 00:02:19,833
FeedLoader.Result還能繼續

64
00:02:19,833 --> 00:02:22,933
正常工作，這就是抽象

65
00:02:22,933 --> 00:02:26,133
好的，我們解決了返回問題，但現在

66
00:02:26,133 --> 00:02:27,433
我們還需要添加一些

67
00:02:27,433 --> 00:02:29,666
類型資訊，對，需要一些

68
00:02:29,666 --> 00:02:32,233
指引

69
00:02:32,233 --> 00:02:34,000
好的，看來我們解決了所有的

70
00:02:34,000 --> 00:02:36,066
生產模組的問題

71
00:02:36,066 --> 00:02:38,400
現在在測試文件中我們也有一些

72
00:02:38,400 --> 00:02:39,733
問題

73
00:02:39,733 --> 00:02:41,833
對，我們需要在那裡給錯誤更多指引

74
00:02:41,833 --> 00:02:43,500
對於錯誤

75
00:02:43,500 --> 00:02:46,000
我們正在使用assert equal，這將會

76
00:02:46,000 --> 00:02:46,866
強制我們的

77
00:02:46,866 --> 00:02:50,066
enum成為Equatable，但Error

78
00:02:50,066 --> 00:02:51,500
是通用的，我們不知道如果

79
00:02:51,500 --> 00:02:54,400
傳遞的error是否符合Equatable

80
00:02:54,400 --> 00:02:55,200
對吧

81
00:02:55,200 --> 00:02:57,833
一個解決方案是使用generics

82
00:02:57,833 --> 00:02:58,300
在此

83
00:02:58,300 --> 00:03:01,500
對，並有我們自己的generic type

84
00:03:01,500 --> 00:03:03,833
現在我們可以在此創建一個擴展

85
00:03:03,833 --> 00:03:05,333
在LoadFeedResult上

86
00:03:05,333 --> 00:03:08,466
當Error是Equatable時，如果

87
00:03:08,466 --> 00:03:09,566
Error是Equatable，

88
00:03:09,566 --> 00:03:11,333
這也可以是Equatable，並且

89
00:03:11,333 --> 00:03:13,033
編譯器可以合成Equatable

90
00:03:13,033 --> 00:03:14,133
為我們實現

91
00:03:14,133 --> 00:03:16,633
這非常好，但現在我們需要

92
00:03:16,633 --> 00:03:18,000
在此處攜帶類型信息

93
00:03:18,000 --> 00:03:20,133
什麼類型的Error呢? 我並不

94
00:03:20,133 --> 00:03:22,233
知道，我希望錯誤是generic的，

95
00:03:22,233 --> 00:03:25,733
所以我們也可以在協議中定義我們自己的相關

96
00:03:25,733 --> 00:03:26,766
類型。

97
00:03:26,766 --> 00:03:28,933
是的，這開始變得有點亂。

98
00:03:28,933 --> 00:03:30,866
沒錯，說得好簡單，至少這樣。

99
00:03:30,866 --> 00:03:33,100
尤其是對於尚未使用的實作來說

100
00:03:33,100 --> 00:03:34,533
還未被使用的

101
00:03:34,533 --> 00:03:38,766
是的，所以我們現在可以定義

102
00:03:38,766 --> 00:03:41,333
我們的LoadFeedResult與我們的領域

103
00:03:41,333 --> 00:03:42,466
錯誤類型

104
00:03:42,466 --> 00:03:44,766
我們可以直接使用結果的類型別名在

105
00:03:44,766 --> 00:03:47,433
返回類型中

106
00:03:47,433 --> 00:03:49,833
並且現在已經通過，並且有了這些類型

107
00:03:49,833 --> 00:03:51,500
別名和泛型

108
00:03:51,500 --> 00:03:54,000
錯誤類型，我認為我們甚至可以放棄

109
00:03:54,000 --> 00:03:54,633
我們的

110
00:03:54,633 --> 00:03:58,633
額外類型資訊，我們添加的對

111
00:03:58,633 --> 00:04:00,766
在這裡你可能也可以做同樣的事情

112
00:04:00,766 --> 00:04:02,133
因為類型現在已經

113
00:04:02,133 --> 00:04:05,733
已註釋，所以這是一個可行的解決方案

114
00:04:05,733 --> 00:04:07,900
但是看這個，我們只是讓

115
00:04:07,900 --> 00:04:09,500
LoadFeedResult可比較

116
00:04:09,500 --> 00:04:11,433
因為試驗，這是

117
00:04:11,433 --> 00:04:12,866
生產代碼

118
00:04:12,866 --> 00:04:15,666
對，確實如此，我們不得不添加這些

119
00:04:15,666 --> 00:04:17,100
關聯類型

120
00:04:17,100 --> 00:04:20,700
泛型類型，類型限制和

121
00:04:20,700 --> 00:04:22,466
我認為這很多地複雜化了我們的

122
00:04:22,466 --> 00:04:24,633
生產代碼，絕對是的

123
00:04:24,633 --> 00:04:26,800
我們限制了我們的類型和我們的

124
00:04:26,800 --> 00:04:28,133
代碼僅僅因為

125
00:04:28,133 --> 00:04:30,933
的測試，我不是很喜歡那個

126
00:04:30,933 --> 00:04:32,866
生產代碼並無需求比對

127
00:04:32,866 --> 00:04:34,066
讓它變為 Equatable 的必要

128
00:04:34,066 --> 00:04:35,900
嗯，但既然它能過測試，我們應該

129
00:04:35,900 --> 00:04:37,100
提交並重新思考這個

130
00:04:37,100 --> 00:04:37,900
實現方式

131
00:04:37,900 --> 00:04:40,000
確實，我同意這是有效的

132
00:04:40,000 --> 00:04:41,166
解決方案，所以

133
00:04:41,166 --> 00:04:43,500
我認為我們應該提交並嘗試找到

134
00:04:43,500 --> 00:04:44,466
更好的一種

135
00:04:44,466 --> 00:04:46,066
順便問一下，你有注意到自己

136
00:04:46,066 --> 00:04:47,900
並不需要變更任何測試嗎？

137
00:04:47,900 --> 00:04:50,466
對，所以讓我們給 Swift 的型別

138
00:04:50,466 --> 00:04:52,800
推斷道一聲讚賞

139
00:04:52,800 --> 00:04:56,933
所以用預設值替換 RemoteFeedLoader.

140
00:04:56,933 --> 00:05:01,266
的結果列舉與之前預定義的

141
00:05:01,266 --> 00:05:04,800
LoadFeedResult 列舉

142
00:05:04,800 --> 00:05:08,233
由 Feed 模塊開始這是

143
00:05:08,233 --> 00:05:11,833
準備遵循 FeedLoader 的資訊交換協定

144
00:05:11,833 --> 00:05:15,500
所以這應該足夠我們讓

145
00:05:15,500 --> 00:05:18,633
RemoteFeedLoader 遵循 Loader 協定

146
00:05:18,633 --> 00:05:20,533
將 RemoteFeedLoader 符合

147
00:05:20,533 --> 00:05:23,033
Loader 協議的需求

148
00:05:23,033 --> 00:05:24,800
這樣就完美了，讓我們提交這個吧

149
00:05:24,800 --> 00:05:26,400
嗯，確定。

150
00:05:26,400 --> 00:05:30,233
這就是我們的目標, 對吧？我們已經達到了

151
00:05:30,233 --> 00:05:33,500
讓RemoteFeedLoader遵從

152
00:05:33,500 --> 00:05:37,666
FeedLoader的協議

153
00:05:37,666 --> 00:05:39,333
我們已經完成本集的目標了。

154
00:05:39,333 --> 00:05:40,533
但是我們並不滿意

155
00:05:40,533 --> 00:05:41,900
實現的方式，對吧。

156
00:05:41,900 --> 00:05:43,900
或者我並不滿意實現的方式。

157
00:05:43,900 --> 00:05:45,833
對，我也不滿意。

158
00:05:45,833 --> 00:05:48,866
但是我們堅持同樣的原則，

159
00:05:48,866 --> 00:05:51,166
就是我們在測試驅動開發中所做的。

160
00:05:51,166 --> 00:05:52,300
到目前為止，

161
00:05:52,300 --> 00:05:54,933
讓它先運行，然後讓它變得更好

162
00:05:54,933 --> 00:05:56,233
或者讓它跑得更快

163
00:05:56,233 --> 00:05:58,700
優化，我認為這就是同樣的情況。

164
00:05:58,700 --> 00:05:59,433
就這個案例而言，

165
00:05:59,433 --> 00:06:02,300
我們已經讓它運作了，如果我們回到

166
00:06:02,300 --> 00:06:03,666
我們的圖表，

167
00:06:03,666 --> 00:06:06,400
我們可以將正確的箭頭從

168
00:06:06,400 --> 00:06:07,333
Feed API

169
00:06:07,333 --> 00:06:10,866
連接到Feed Feature，這樣就做到了，

170
00:06:10,866 --> 00:06:12,800
所以我們想做的就是移除這些

171
00:06:12,800 --> 00:06:14,866
類型約束，我們只是因為

172
00:06:14,866 --> 00:06:16,700
Equatable的要求

173
00:06:16,700 --> 00:06:17,900
在我們的測試中才有這個條件。

174
00:06:17,900 --> 00:06:20,066
所以如果你能消除這個Equatable

175
00:06:20,066 --> 00:06:21,433
的需求

176
00:06:21,433 --> 00:06:23,166
我們應該能夠去除

177
00:06:23,166 --> 00:06:24,800
通用約束

178
00:06:24,800 --> 00:06:26,700
就是這個目標了，這是一個新

179
00:06:26,700 --> 00:06:29,333
的目標，那麼讓我們看看在哪裡會出問題

180
00:06:29,333 --> 00:06:32,000
正如我們預料的，在 assert

181
00:06:32,000 --> 00:06:32,866
equals中

182
00:06:32,866 --> 00:06:34,533
對，關鍵是我們將不再

183
00:06:34,533 --> 00:06:35,900
獲取結果來進行比較

184
00:06:35,900 --> 00:06:38,133
而是將數值進行

185
00:06:38,133 --> 00:06:39,500
解包

186
00:06:39,500 --> 00:06:41,900
將結果類型進行解包並比較值

187
00:06:41,900 --> 00:06:42,633
內部的

188
00:06:42,633 --> 00:06:45,500
結果，對，所以現在沒有獲取結果

189
00:06:45,500 --> 00:06:46,866
的選項了

190
00:06:46,866 --> 00:06:50,400
我們在這裡得到的是接收到的

191
00:06:50,400 --> 00:06:54,233
結果，而我們也有一個預期的

192
00:06:54,233 --> 00:06:56,633
結果，對，我們需要將它們進行比較

193
00:06:56,633 --> 00:06:58,066
所以我們需要進行解包

194
00:06:58,066 --> 00:07:00,233
枚舉，對，兩者都是，我們能在這裡

195
00:07:00,233 --> 00:07:01,900
使用模式匹配，這是一種

196
00:07:01,900 --> 00:07:02,633
很好的

197
00:07:02,633 --> 00:07:04,466
Swift特性，所以我們可以結合這些


198
00:07:04,466 --> 00:07:05,833
在 switch 語句中的兩個

199
00:07:05,833 --> 00:07:07,833
並在此處使用模式匹配

200
00:07:07,833 --> 00:07:09,166
當解包時

201
00:07:09,166 --> 00:07:11,100
兩者都是成功，意味著

202
00:07:11,100 --> 00:07:13,500
它們匹配了他們的案例

203
00:07:13,500 --> 00:07:16,000
所以我們在成功案例中會得到

204
00:07:16,000 --> 00:07:17,900
receivedItems

205
00:07:17,900 --> 00:07:22,700
和右邊的 expectedItems

206
00:07:22,700 --> 00:07:27,166
然後我們可以比較它們

207
00:07:27,166 --> 00:07:29,500
就是這樣，這就是成功的情況

208
00:07:29,500 --> 00:07:31,833
對，但我們也有

209
00:07:31,833 --> 00:07:34,933
失敗的情況，我們收到一個

210
00:07:34,933 --> 00:07:38,633
錯誤和預期的

211
00:07:38,633 --> 00:07:41,500
錯誤，我們做了類似的事情， 我們可以

212
00:07:41,500 --> 00:07:42,800
只是比較兩者

213
00:07:42,800 --> 00:07:46,133
receivedError 和 expectedError 但

214
00:07:46,133 --> 00:07:48,466
也許我們預期成功，但是我們

215
00:07:48,466 --> 00:07:50,466
卻敗了，或者我們預期失敗

216
00:07:50,466 --> 00:07:51,166
我們卻成功了

217
00:07:51,166 --> 00:07:53,100
所以我們需要有個默認的

218
00:07:53,100 --> 00:07:55,166
案例，這意味著案例不

219
00:07:55,166 --> 00:07:55,833
匹配

220
00:07:55,833 --> 00:07:58,533
我們應該直接失敗，我們

221
00:07:58,533 --> 00:08:01,166
總是預期在那裡會有失敗

222
00:08:01,166 --> 00:08:04,633
所以預期的結果和預期的

223
00:08:04,633 --> 00:08:08,000
我們收到的結果

224
00:08:08,000 --> 00:08:11,100
您也可以新增檔案作為結果

225
00:08:11,100 --> 00:08:13,100
並且包含行數，從而獲得一個好的

226
00:08:13,100 --> 00:08:15,166
正確位置的錯誤訊息

227
00:08:15,166 --> 00:08:17,033
這非常美妙，但由於這是

228
00:08:17,033 --> 00:08:18,233
非同步的

229
00:08:18,233 --> 00:08:20,400
我們需要一種方式確保我們已經獲得了

230
00:08:20,400 --> 00:08:21,733
在這個封閉中的內容

231
00:08:21,733 --> 00:08:24,300
並且也確保我們只進行一次，而

232
00:08:24,300 --> 00:08:25,566
我們可以通過以下方法達成相同的行為

233
00:08:25,566 --> 00:08:26,466
使用

234
00:08:26,466 --> 00:08:29,500
預期，這是XCTestCase上的一個好用的功能

235
00:08:29,500 --> 00:08:31,433
XCTestCase

236
00:08:31,433 --> 00:08:35,433
等待加載完成就是我們的訊息

237
00:08:35,433 --> 00:08:38,466
我們將要履行這一点

238
00:08:38,466 --> 00:08:41,333
無論結果如何我們都只需要

239
00:08:41,333 --> 00:08:42,633
等待

240
00:08:42,633 --> 00:08:46,533
有一個時間限制的期待

241
00:08:46,533 --> 00:08:49,266
現在讓我們運行這個測試，好了現在它

242
00:08:49,266 --> 00:08:50,366
通過了，我們不再需要

243
00:08:50,366 --> 00:08:52,766
Equatable，因為

244
00:08:52,766 --> 00:08:54,066
我們斷言這件事的方式是

245
00:08:54,066 --> 00:08:55,266
實際上是解壓縮它

246
00:08:55,266 --> 00:08:57,200
在我們的測試模組中我們有一些更多的代碼

247
00:08:57,200 --> 00:08:58,466
測試模組

248
00:08:58,466 --> 00:09:01,200
但我們簡化了我們的生產代碼，所以

249
00:09:01,200 --> 00:09:01,666
經常

250
00:09:01,666 --> 00:09:04,000
這在

251
00:09:04,000 --> 00:09:06,000
我認為這種情況下是個好的折衷

252
00:09:06,000 --> 00:09:06,366
因為它

253
00:09:06,366 --> 00:09:08,866
讓生產代碼變得複雜，這

254
00:09:08,866 --> 00:09:10,300
對我來說像是個好康頭

255
00:09:10,300 --> 00:09:12,800
基本上跟我們所有新增的

256
00:09:12,800 --> 00:09:14,366
約束相比根本微不足道

257
00:09:14,366 --> 00:09:17,100
即使我們根本沒有使用它們，保持

258
00:09:17,100 --> 00:09:19,033
相同的行為也在確認這件事

259
00:09:19,033 --> 00:09:20,800
該指令被調用，因為如果我們沒有

260
00:09:20,800 --> 00:09:22,366
滿足這個期望，我們就會在這裡

261
00:09:22,366 --> 00:09:23,500
發生失敗

262
00:09:23,500 --> 00:09:25,666
對，我們也在解包並且

263
00:09:25,666 --> 00:09:26,533
檢測值

264
00:09:26,533 --> 00:09:28,866
在結果中，如果它們不

265
00:09:28,866 --> 00:09:31,200
符合，我們也會得到一個失敗，

266
00:09:31,200 --> 00:09:34,000
一個很好的訊息告訴我們

267
00:09:34,000 --> 00:09:34,800
確實

268
00:09:34,800 --> 00:09:37,033
問題在哪裡，所以我對

269
00:09:37,033 --> 00:09:38,466
這件事感到滿意，這就是折衷，

270
00:09:38,466 --> 00:09:40,800
也許將來我們會有所有

271
00:09:40,800 --> 00:09:42,300
的關聯型別


272
00:09:42,300 --> 00:09:44,233
和通用類型，然後我們就可以

273
00:09:44,233 --> 00:09:45,500
簡化我們的測試

274
00:09:45,500 --> 00:09:47,600
但只有在這是生產代碼的

275
00:09:47,600 --> 00:09:48,800
需求時才行

276
00:09:48,800 --> 00:09:52,633
好的，讓我們提交

277
00:09:52,633 --> 00:09:54,800
我們還需要去除這些類型

278
00:09:54,800 --> 00:09:55,733
限制，但是

279
00:09:55,733 --> 00:09:58,000
我們的測試已通過，沒有警告，讓我們

280
00:09:58,000 --> 00:09:59,266
提交是的

281
00:09:59,266 --> 00:10:02,866
所以移除LoadFeedResult

282
00:10:02,866 --> 00:10:06,533
從生產中移除Equatable一致性

283
00:10:06,533 --> 00:10:09,600
因為它只用於測試

284
00:10:09,600 --> 00:10:13,433
那就是這樣了

285
00:10:13,433 --> 00:10:15,733
我認為現在是時候去除

286
00:10:15,733 --> 00:10:17,666
那些通用的東西了

287
00:10:17,666 --> 00:10:20,000
讓我們看看如果我們移除這些，我們也可以

288
00:10:20,000 --> 00:10:21,033
移除

289
00:10:21,033 --> 00:10:24,633
相關聯的類型

290
00:10:24,633 --> 00:10:26,700
所以我們可以去除類型註釋

291
00:10:26,700 --> 00:10:28,233
在這裡，我們將不得不更明確地

292
00:10:28,233 --> 00:10:29,666
定義我們的類型

293
00:10:29,666 --> 00:10:33,100
使用我們的類型

294
00:10:33,100 --> 00:10:35,833
這也是一種折衷，因為

295
00:10:35,833 --> 00:10:36,466
由於

296
00:10:36,466 --> 00:10:39,100
我們在Result中使用的Swift通用Error類型

297
00:10:39,100 --> 00:10:39,833
這是一個enum 

298
00:10:39,833 --> 00:10:42,933
好的，測試同樣進行

299
00:10:42,933 --> 00:10:45,433
讓我們在這裡添加一些類型註釋

300
00:10:45,433 --> 00:10:50,700
來幫助編譯器

301
00:10:50,700 --> 00:10:53,666
而我們也需要對這個進行轉型，對，而且

302
00:10:53,666 --> 00:10:54,800
我們能做到

303
00:10:54,800 --> 00:10:57,100
透過使用模式匹配的功能，它將

304
00:10:57,100 --> 00:10:58,533
會將它們解開來

305
00:10:58,533 --> 00:11:01,433
只有在你能將它們轉型的時候，否則它會

306
00:11:01,433 --> 00:11:01,900
變成

307
00:11:01,900 --> 00:11:03,900
預設為錯誤，因為它們需要

308
00:11:03,900 --> 00:11:05,333
匹配，太棒了

309
00:11:05,333 --> 00:11:07,333
好的，所以這就是使用

310
00:11:07,333 --> 00:11:09,266
泛型 Swift Error 的折衷方案

311
00:11:09,266 --> 00:11:10,800
也許你需要添加一點

312
00:11:10,800 --> 00:11:12,366
更多的類型信息來幫助

313
00:11:12,366 --> 00:11:13,100
編譯器

314
00:11:13,100 --> 00:11:15,600
但我認為這絕對值得，現在

315
00:11:15,600 --> 00:11:16,466
我們可以重新考慮這個

316
00:11:16,466 --> 00:11:19,100
在將來，可能會回滾，我們

317
00:11:19,100 --> 00:11:19,500
有自由

318
00:11:19,500 --> 00:11:21,733
這樣做，這是我們擁有 git

319
00:11:21,733 --> 00:11:22,800
的主要原因之一

320
00:11:22,800 --> 00:11:27,333
確實，讓我們提交移除來自

321
00:11:27,333 --> 00:11:30,466
LoadFeedResult 的泛型錯誤類型來簡化

322
00:11:30,466 --> 00:11:34,133
類型約束，就是這樣


324
00:11:39,500 --> 00:11:41,500
我看到你那邊添加的錯誤

325
00:11:41,500 --> 00:11:42,800
這些對吧

326
00:11:42,800 --> 00:11:44,066
我認為我們可以將它們簡化一點

327
00:11:44,066 --> 00:11:46,233
也許我們可以創建一個輔助

328
00:11:46,233 --> 00:11:47,100
函數

329
00:11:47,100 --> 00:11:48,933
所以取代 .failure 我們可以說

330
00:11:48,933 --> 00:11:50,300
失敗

331
00:11:50,300 --> 00:11:53,333
我們可以回到只傳遞

332
00:11:53,333 --> 00:11:54,800
枚舉的情況

333
00:11:54,800 --> 00:11:58,800
對，沒錯

334
00:11:58,800 --> 00:12:01,500
所以我們可以有我們的私有工廠

335
00:12:01,500 --> 00:12:02,633
方法

336
00:12:02,633 --> 00:12:06,133
帶有錯誤的失敗，並返回

337
00:12:06,133 --> 00:12:08,466
結果，對，這是一個結果然後我們

338
00:12:08,466 --> 00:12:09,200
只是

339
00:12:09,200 --> 00:12:12,066
用那個錯誤創建結果，對

340
00:12:12,066 --> 00:12:14,366
我們來看看測試是否通過

341
00:12:14,366 --> 00:12:17,033
對，我喜歡它，我認為這是一種很好清理

342
00:12:17,033 --> 00:12:17,833
方式

343
00:12:17,833 --> 00:12:20,300
好的，這讀起來很好，期望sut出現一個失敗

344
00:12:20,300 --> 00:12:21,600
當某事發生時，出現無效數據

345
00:12:21,600 --> 00:12:24,466
對，好棒

346
00:12:24,466 --> 00:12:25,100
讓我們提交簡化類型

347
00:12:25,100 --> 00:12:28,800
使用輔助函數的聲明

348
00:12:28,800 --> 00:12:31,900
我想這就是了，對吧

349
00:12:31,900 --> 00:12:35,666
是的，我對結果非常滿意

350
00:12:35,666 --> 00:12:38,133
好的，我很滿意結果


352
00:12:39,100 --> 00:12:41,666
我對結果非常滿意，是的， 

353
00:12:41,666 --> 00:12:42,233
事實上，

354
00:12:42,233 --> 00:12:44,300
我們擺脫了這些約束，是的，

355
00:12:44,300 --> 00:12:45,500
這讓我很開心。

356
00:12:45,500 --> 00:12:47,900
你也可以將 FeedLoader

357
00:12:47,900 --> 00:12:50,133
協議公開，這樣它就可以被

358
00:12:50,133 --> 00:12:52,066
其他模組實現。只是剛好

359
00:12:52,066 --> 00:12:53,666
這一切都在同一個模組中

360
00:12:53,666 --> 00:12:54,366
這一刻。

361
00:12:54,366 --> 00:12:57,666
是的，這是一個好抓取點。所以讓

362
00:12:57,666 --> 00:13:00,700
FeedLoader 協議

363
00:13:00,700 --> 00:13:04,233
公開，就這樣。

364
00:13:04,233 --> 00:13:05,733
RemoteFeedLoader 現在符合

365
00:13:05,733 --> 00:13:07,600
FeedLoader，我們只需要去

366
00:13:07,600 --> 00:13:08,300
實現

367
00:13:08,300 --> 00:13:11,433
一個 HTTPClient，太棒了。好了，

368
00:13:11,433 --> 00:13:12,533
感謝你的觀看，

369
00:13:12,533 --> 00:13:14,233
我們下一集再見。

370
00:13:14,233 --> 00:13:25,733
再見，大家。
