

1
00:00:01,100 --> 00:00:03,033
哈囉 Mike，嘿 Caio

2
00:00:03,033 --> 00:00:04,933
所以在上一集我們把我們的

3
00:00:04,933 --> 00:00:07,600
生產代碼移出了測試目標

4
00:00:07,600 --> 00:00:09,900
然後我們改進了我們的斷言，不再

5
00:00:09,900 --> 00:00:11,266
僅檢查被捕獲的值，

6
00:00:11,266 --> 00:00:11,833
捕獲的值

7
00:00:11,833 --> 00:00:14,000
還有看它們被捕獲了多少次，

8
00:00:14,000 --> 00:00:15,733
透過使用陣列。

9
00:00:15,733 --> 00:00:18,533
對的，好，現在該開始

10
00:00:18,533 --> 00:00:20,533
思考客戶端的回應了，

11
00:00:20,533 --> 00:00:22,866
因為到目前為止我們只發送了訊息

12
00:00:22,866 --> 00:00:25,033
但沒有預期回傳任何東西。

13
00:00:25,033 --> 00:00:28,000
讓我們從錯誤案例開始，什麼

14
00:00:28,000 --> 00:00:28,633
情況會發生

15
00:00:28,633 --> 00:00:30,700
當客戶端出現錯誤時

16
00:00:30,700 --> 00:00:31,666
對的那麼

17
00:00:31,666 --> 00:00:34,633
當客戶端失敗時，我們希望傳遞一個

18
00:00:34,633 --> 00:00:35,433
錯誤。

19
00:00:35,433 --> 00:00:39,033
所以當客戶端錯誤時，傳遞錯誤

20
00:00:39,033 --> 00:00:42,300
對的，因為當HTTPClient失敗時，

21
00:00:42,300 --> 00:00:44,066
就代表我們有某種

22
00:00:44,066 --> 00:00:45,333
連接問題。

23
00:00:45,333 --> 00:00:48,066
對的，確切地說，所以如果我們有我們的 sut 和

24
00:00:48,066 --> 00:00:49,900
客戶端。

25
00:00:49,900 --> 00:00:52,800
我們稱呼這為載入，我們希望有一個輸出

26
00:00:52,800 --> 00:00:53,600
基本上來說

27
00:00:53,600 --> 00:00:55,600
而由於回呼函數是非同步的

28
00:00:55,600 --> 00:00:57,100
我們將傳遞一個完成區塊

29
00:00:57,100 --> 00:00:59,666
對，傳遞到FeedLoader，我喜歡這樣

30
00:00:59,666 --> 00:01:00,533
而我們將得到

31
00:01:00,533 --> 00:01:02,633
比如說一個錯誤，我們希望

32
00:01:02,633 --> 00:01:03,600
捕捉這個錯誤

33
00:01:03,600 --> 00:01:06,933
所以，capturedError等於錯誤

34
00:01:06,933 --> 00:01:10,000
所以讓我們定義我們的capturedError，

35
00:01:10,000 --> 00:01:11,333
這裡的型態是？

36
00:01:11,333 --> 00:01:13,266
我們現在先用Error就好了，我們

37
00:01:13,266 --> 00:01:14,933
有一些編譯器警告，為何我們不

38
00:01:14,933 --> 00:01:16,133
開始解決這些警告

39
00:01:16,133 --> 00:01:18,633
首先，load並未收到

40
00:01:18,633 --> 00:01:20,066
一個完成區塊

41
00:01:20,066 --> 00:01:23,266
所讓我們來做這個

42
00:01:23,266 --> 00:01:26,066
並且我們期待回傳一個Error，

43
00:01:26,066 --> 00:01:27,333
而由於我們不希望破壞

44
00:01:27,333 --> 00:01:29,600
其它測試，現讓我們就給它

45
00:01:29,600 --> 00:01:31,033
一個預設的閉包就好了 

46
00:01:31,033 --> 00:01:34,466
這是Swift的一個不錯功能，好的


47
00:01:34,466 --> 00:01:36,466
編譯器的錯誤消失了，我們繼續吧

48
00:01:36,466 --> 00:01:38,400
我們是否希望這個Error 

49
00:01:38,400 --> 00:01:40,066
僅僅是一個通用協定，或者我們應該

50
00:01:40,066 --> 00:01:42,133
給它一個更好的定義

51
00:01:42,133 --> 00:01:44,533
對，我認為我們應該這麼做，如果

52
00:01:44,533 --> 00:01:45,666
客戶端出錯

53
00:01:45,666 --> 00:01:47,266
我們將定義它為

54
00:01:47,266 --> 00:01:48,700
連接錯誤

55
00:01:48,700 --> 00:01:50,866
那麼我們為什麼不定義我們自己的Error

56
00:01:50,866 --> 00:01:53,100
類型，它甚至可以在

57
00:01:53,100 --> 00:01:56,233
RemoteFeedLoader裡面，對，它可以是一個

58
00:01:56,233 --> 00:01:59,500
公共枚舉，好的，所以公共枚舉

59
00:01:59,500 --> 00:02:02,233
Error，對，並且我喜歡這將如何讀取

60
00:02:02,233 --> 00:02:02,700
稍後

61
00:02:02,700 --> 00:02:05,900
這是一個RemoteFeedloader.Error類型，並且

62
00:02:05,900 --> 00:02:07,333
它需要符合

63
00:02:07,333 --> 00:02:09,033
Error，並且由於他們擁有相同的名稱

64
00:02:09,033 --> 00:02:11,000
我們需要給它命名空間

65
00:02:11,000 --> 00:02:14,400
Swift.Error，太好了，案例

66
00:02:14,400 --> 00:02:17,666
名稱將是連接性，這很有意義

67
00:02:17,666 --> 00:02:20,533
這是一個連接錯誤，對，所以現在這

68
00:02:20,533 --> 00:02:24,066
應該是 RemoteFeedLoader.Error

69
00:02:24,066 --> 00:02:28,066
我們預期這個會回傳 Error

70
00:02:28,066 --> 00:02:32,300
所以我們可以斷定捕捉到的錯誤是

71
00:02:32,300 --> 00:02:36,133
一個連接失敗的錯誤，而且編譯器

72
00:02:36,133 --> 00:02:37,033
正在告訴我們我們並沒有在這個範疇內使用過

73
00:02:37,033 --> 00:02:38,866
client

74
00:02:38,866 --> 00:02:40,133
但我們必須通知 client 失敗了

75
00:02:40,133 --> 00:02:41,566
好吧，我們可以模擬一個 client，這是一種

76
00:02:41,566 --> 00:02:43,333
方法

77
00:02:43,333 --> 00:02:45,733
好的，所以我們並沒有這個功能，

78
00:02:45,733 --> 00:02:46,800
但我們可以實踐它像這樣，

79
00:02:46,800 --> 00:02:48,233
比如說使 client.error 

80
00:02:48,233 --> 00:02:49,800
等於，我們只是測試一下，

81
00:02:49,800 --> 00:02:50,933
NSError 也好

82
00:02:50,933 --> 00:02:54,700
比如說我們測試代碼零

83
00:02:54,700 --> 00:02:59,266
好的，你現在可以在這裡設置一個錯誤

84
00:02:59,266 --> 00:03:02,800
選擇性的，所以這就是我們測試中所想要的

85
00:03:02,800 --> 00:03:06,233
設置，但是現在我們並沒有其他方法可以讓 HTTP

86
00:03:06,233 --> 00:03:08,466
Client 告訴

87
00:03:08,466 --> 00:03:10,700
RemoteFeedLoader 發生了錯誤

88
00:03:10,700 --> 00:03:11,666
所以讓我們運行這個測試

89
00:03:11,666 --> 00:03:13,200
了解一下。

91
00:03:14,933 --> 00:03:18,633
並且希望我們看到一個失敗的測試

92
00:03:18,633 --> 00:03:21,833
我們怎樣可以從

93
00:03:21,833 --> 00:03:23,566
客戶端傳送一個錯誤到RemoteFeedLoader,而我

94
00:03:23,566 --> 00:03:24,866
認為我們可以使用閉包

95
00:03:24,866 --> 00:03:27,833
對，使用相同的技術完成

96
00:03:27,833 --> 00:03:29,500
帶有一個錯誤

97
00:03:29,500 --> 00:03:31,200
但是哪一種錯誤?我不想要

98
00:03:31,200 --> 00:03:33,200
傳送與RemoteFeed相同的錯誤

99
00:03:33,200 --> 00:03:34,866
Loader，因為這個錯誤現在

100
00:03:34,866 --> 00:03:36,633
在實施的範疇之內

101
00:03:36,633 --> 00:03:38,000
對HTTPClient的實施

102
00:03:38,000 --> 00:03:41,566
絕對的，這個錯誤是一個HTTP

103
00:03:41,566 --> 00:03:44,066
種類的錯誤，所以應該有自己的

104
00:03:44,066 --> 00:03:44,866
類型存在

105
00:03:44,866 --> 00:03:46,533
那麼RemoteFeedLoader在做什麼呢

106
00:03:46,533 --> 00:03:48,633
是將客戶端的錯誤

107
00:03:48,633 --> 00:03:50,766
映射為在此情況下的領域錯誤

108
00:03:50,766 --> 00:03:51,833
連接性

109
00:03:51,833 --> 00:03:54,933
對，來自HTTP

110
00:03:54,933 --> 00:03:57,733
領域的一個錯誤，如我們看到的，當沒有

111
00:03:57,733 --> 00:03:58,866
連接性的時候

112
00:03:58,866 --> 00:04:01,266
我們傳送一個領域錯誤給

113
00:04:01,266 --> 00:04:02,800
那就是無連接性的領域錯誤

114
00:04:05,100 --> 00:04:08,000
那麼讓我們進行這種逃脫並且這個

115
00:04:08,000 --> 00:04:10,700
也應該是逃脫的

116
00:04:10,700 --> 00:04:13,833
我們現在需要傳遞閉包，所以

117
00:04:13,833 --> 00:04:15,500
這裡我們得到客戶端

118
00:04:15,500 --> 00:04:18,366
錯誤，但我們希望完成我們的

119
00:04:18,366 --> 00:04:22,066
自有範疇的錯誤，是的，連接性

120
00:04:22,066 --> 00:04:26,833
但是現在我們的特務需要實現新的

121
00:04:26,833 --> 00:04:28,233
方法

122
00:04:28,233 --> 00:04:30,466
現在如果我們有一個錯誤

123
00:04:30,466 --> 00:04:31,333
對

124
00:04:31,333 --> 00:04:34,466
我們調用完成錯誤的結果

125
00:04:34,466 --> 00:04:39,900
在特工身上，這樣應該就可以了

126
00:04:39,900 --> 00:04:43,033
好，測試通過，慢慢進步中

127
00:04:43,033 --> 00:04:47,266
那讓我們提交一下，當客戶端出錯時會出現連接性錯誤

128
00:04:47,266 --> 00:04:51,266
很好，我認為我們可以做一些清理工作

129
00:04:51,266 --> 00:04:53,833
在閉包中我們不需要為

130
00:04:53,833 --> 00:04:54,300
這裡

131
00:04:54,300 --> 00:04:56,133
錯誤定義名稱，我們可以直接使用

132
00:04:56,133 --> 00:04:58,300
在閉包，我們可以只用

133
00:04:58,300 --> 00:04:59,333
美元符號

134
00:04:59,333 --> 00:05:02,866
0另外一個可以改進的地方是

135
00:05:02,866 --> 00:05:04,066
而不是使用

136
00:05:04,066 --> 00:05:05,900
可選並捕獲它，我們可以做

137
00:05:05,900 --> 00:05:07,500
和我們所做的相同技術

138
00:05:07,500 --> 00:05:09,500
requestedURLs並且使用一個陣列

139
00:05:09,500 --> 00:05:11,166
的錯誤來保證我們只

140
00:05:11,166 --> 00:05:13,266
收到一個錯誤

141
00:05:13,266 --> 00:05:16,066
所以現在我們只需附加收到的錯誤

142
00:05:16,066 --> 00:05:18,633
然後最後我們可以比較

143
00:05:18,633 --> 00:05:21,600
capturedErrors僅為一個錯誤

144
00:05:21,600 --> 00:05:22,866
且它是一個連接性

145
00:05:22,866 --> 00:05:25,833
錯誤，對，這看起來不錯，好的

146
00:05:25,833 --> 00:05:26,700
提交

147
00:05:26,700 --> 00:05:29,900
對，我們保證我們

148
00:05:29,900 --> 00:05:33,433
只接收一個錯誤

149
00:05:33,433 --> 00:05:36,866
太棒了，所以我們在這裡做了一個選擇

150
00:05:36,866 --> 00:05:39,733
去假設(client)儘管我們的

151
00:05:39,733 --> 00:05:40,466
client

152
00:05:40,466 --> 00:05:44,466
是一個間諜，對，所以我們現在混合了概念

153
00:05:44,466 --> 00:05:44,866
現在

154
00:05:44,866 --> 00:05:48,066
假設和捕捉值，對

155
00:05:48,066 --> 00:05:49,833
從這裡的測試觀點，我們

156
00:05:49,833 --> 00:05:52,233
在我們調用load之前假設，但那

157
00:05:52,233 --> 00:05:54,000
不反映這種行為的異步性質

158
00:05:54,000 --> 00:05:56,633
確實，所以我會

159
00:05:56,633 --> 00:05:58,133
更喜歡保留我們的間諜

160
00:05:58,133 --> 00:06:00,933
只是捕獲數據，而不是

161
00:06:00,933 --> 00:06:01,900
將它假設

162
00:06:01,900 --> 00:06:04,300
具有一些行為，我們可以這麼做，通過

163
00:06:04,300 --> 00:06:06,133
捕捉完成塊，並且它的

164
00:06:06,133 --> 00:06:06,466
向上

165
00:06:06,466 --> 00:06:09,666
由我們在測試範疇內來調用那

166
00:06:09,666 --> 00:06:12,800
完成塊，好的，如何這麼呢

167
00:06:12,800 --> 00:06:16,000
所以我們可以通過創建我們的客戶端

168
00:06:16,000 --> 00:06:20,000
錯誤，並調用我們將捕捉的完成塊

169
00:06:20,000 --> 00:06:21,900
我們將捕捉，例如我們

170
00:06:21,900 --> 00:06:23,266
有完成

171
00:06:23,266 --> 00:06:25,500
數組，並我們希望第一個，我們

172
00:06:25,500 --> 00:06:27,166
可以用客戶端錯誤調用它

173
00:06:27,166 --> 00:06:30,400
錯誤，好的，讓我們去我們的間諜

174
00:06:30,400 --> 00:06:33,333
取代錯誤，我們可以添加我們的

175
00:06:33,333 --> 00:06:34,466
完成

176
00:06:34,466 --> 00:06:38,133
數組將持有

177
00:06:38,133 --> 00:06:43,266
所有的完成塊傳遞

178
00:06:43,266 --> 00:06:45,900
因此我們添加了所接收的完成，我們

179
00:06:45,900 --> 00:06:48,133
不再需要錯誤了

180
00:06:48,133 --> 00:06:50,400
我們不在存根裡，我們不

181
00:06:50,400 --> 00:06:52,133
有行為，我們只累加

182
00:06:52,133 --> 00:06:54,066
我們接收到的所有屬性，讓我們運行

183
00:06:54,066 --> 00:06:56,133
這個測試

184
00:06:56,133 --> 00:06:58,133
並且它通過了，我們絕對應該

185
00:06:58,133 --> 00:06:59,500
在這裡提及如何

186
00:06:59,500 --> 00:07:03,500
程式碼的順序由排列部分變更為

187
00:07:03,500 --> 00:07:07,066
先前的動作部分

188
00:07:07,066 --> 00:07:09,100
client.error stub

189
00:07:09,100 --> 00:07:12,400
是排列範疇的一部分，

190
00:07:12,400 --> 00:07:14,466
現在 client.completions 屬於

191
00:07:14,466 --> 00:07:15,500
動作部分

192
00:07:15,500 --> 00:07:18,300
這是行動，這很有意義

193
00:07:18,300 --> 00:07:19,500
當客戶端

194
00:07:19,500 --> 00:07:22,066
以錯誤完成時，我們希望

195
00:07:22,066 --> 00:07:22,800
載入也完成錯誤，所以我

196
00:07:22,800 --> 00:07:24,800
相信這個測試告訴了真相

197
00:07:24,800 --> 00:07:26,533
畢竟完成是在你

198
00:07:26,533 --> 00:07:29,033
呼叫載入之後才會產生的

199
00:07:29,033 --> 00:07:30,066
確實，所以我對此感到滿意，但是現在我

200
00:07:30,066 --> 00:07:32,700
認為這並不易讀

201
00:07:32,700 --> 00:07:34,233
它看起來並不像之前那麼整潔

202
00:07:34,233 --> 00:07:36,533
因為我們需要從一個

203
00:07:36,533 --> 00:07:38,400
陣列中取值

204
00:07:38,400 --> 00:07:38,933
好的，但我們可以解決這個問題

205
00:07:38,933 --> 00:07:41,100
好，讓我們來

206
00:07:41,100 --> 00:07:44,533
提交並嘗試解決這個問題

207
00:07:44,533 --> 00:07:47,900
通過捕獲來替代 stubbing

208
00:07:47,900 --> 00:07:51,166
讓我們看看我們是否能夠

209
00:07:51,166 --> 00:07:51,900
改善 

210
00:07:51,900 --> 00:07:55,266
間諜，如果我們有一種方法

211
00:07:55,266 --> 00:07:58,466
名為complete with，並我們傳遞

212
00:07:58,466 --> 00:08:00,533
我們這邊的客戶，對，那就是

213
00:08:00,533 --> 00:08:02,400
我們所想的，我們希望我們的間諜去

214
00:08:02,400 --> 00:08:04,700
利用錯誤完成，所以在

215
00:08:04,700 --> 00:08:06,633
實現過程中，

216
00:08:06,633 --> 00:08:08,933
我們傳遞錯誤，然後在這裡我們呼叫

217
00:08:08,933 --> 00:08:10,000
完成

218
00:08:10,000 --> 00:08:13,666
在指定位置並調用錯誤

219
00:08:13,666 --> 00:08:15,900
我們甚至可以使下標變為動態

220
00:08:15,900 --> 00:08:17,100
動態

221
00:08:17,100 --> 00:08:20,233
好的，我們可以有一個索引並給它一個

222
00:08:20,233 --> 00:08:23,566
預設值，就像把它預設為零一樣

223
00:08:23,566 --> 00:08:26,400
好的，所以我們獲得的完成塊在

224
00:08:26,400 --> 00:08:27,433
過去的指數

225
00:08:27,433 --> 00:08:29,166
然後我們引用錯誤，讓我們看看

226
00:08:29,166 --> 00:08:32,366
現在看起來如何

227
00:08:32,366 --> 00:08:33,833
它通過了，我認為它現在看起來

228
00:08:33,833 --> 00:08:35,500
更乾淨了，絕對是

229
00:08:35,500 --> 00:08:38,866
所以讓我們提交以改進

230
00:08:38,866 --> 00:08:42,133
與助手的可讀性

231
00:08:42,133 --> 00:08:45,200
方法，我認為我們甚至可以更進一步

232
00:08:45,200 --> 00:08:45,900
更進一步

233
00:08:45,900 --> 00:08:49,900
並可能結合擷取的值


234
00:08:49,900 --> 00:08:52,533
既然我們正在捕捉整個訊息

235
00:08:52,533 --> 00:08:54,366
而不是有兩個不同的陣列

236
00:08:54,366 --> 00:08:57,200
我們可以在一個

237
00:08:57,200 --> 00:08:58,366
元組陣列中捕捉它

238
00:08:58,366 --> 00:09:01,833
例如，我們可以有一個messages陣列

239
00:09:01,833 --> 00:09:04,366
這是已捕捉到的

240
00:09:04,366 --> 00:09:05,200
URL

241
00:09:05,200 --> 00:09:07,500
和完成塊的組合，這就是

242
00:09:07,500 --> 00:09:08,700
get方法的特徵

243
00:09:08,700 --> 00:09:12,066
基本上

244
00:09:12,066 --> 00:09:14,266
現在在get方法中我們可以說

245
00:09:14,266 --> 00:09:15,666
message.append

246
00:09:15,666 --> 00:09:18,066
URL和完成塊，如果將來我們增加了更多的參數到

247
00:09:18,066 --> 00:09:20,133
這個方法中

248
00:09:20,133 --> 00:09:21,100
我們也把它追加到元組中 

249
00:09:21,100 --> 00:09:24,133
對吧

250
00:09:24,133 --> 00:09:27,433
所以現在沒有完全的需求

251
00:09:27,433 --> 00:09:30,066
我們只要用messages陣列

252
00:09:30,066 --> 00:09:30,633
索引

253
00:09:30,633 --> 00:09:33,500
.completion完成該

254
00:09:33,500 --> 00:09:34,233
訊息

255
00:09:34,233 --> 00:09:36,800
然後確實用error完成，並且

256
00:09:36,800 --> 00:09:39,333
我們可以針對requestedURLs做同樣的事

257
00:09:39,333 --> 00:09:41,600
所以我們可以將requestedURLs 製作成

258
00:09:41,600 --> 00:09:43,033
一個已計算的屬性

259
00:09:43,033 --> 00:09:46,633
是的，然後我們返回

260
00:09:46,633 --> 00:09:50,133
messages.map 而我們只得到

261
00:09:50,133 --> 00:09:50,933
URLs

262
00:09:50,933 --> 00:09:53,500
在訊息中，我們不需要

263
00:09:53,500 --> 00:09:54,066
捕捉

264
00:09:54,066 --> 00:09:58,000
URLs 了，我們並沒有破壞

265
00:09:58,000 --> 00:10:00,300
客戶端，那就是我實施

266
00:10:00,300 --> 00:10:01,333
spies 的常規方式

267
00:10:01,333 --> 00:10:03,733
我喜歡捕獲我覺得重要的值

268
00:10:03,733 --> 00:10:04,533
真是太好了

269
00:10:04,533 --> 00:10:07,666
讓我們提交吧

270
00:10:07,666 --> 00:10:11,833
合併 spy 捕捉到的參數

271
00:10:11,833 --> 00:10:15,033
變成一種單一類型，這是一個元組

272
00:10:15,033 --> 00:10:19,266
好的，看起來很乾淨

273
00:10:19,266 --> 00:10:23,333
好的，這次測試又增加了一種

274
00:10:23,333 --> 00:10:25,033
在加載中的完成塊

275
00:10:25,033 --> 00:10:27,266
方法，在以前沒有被使用過

276
00:10:27,266 --> 00:10:29,500
在其他的測試中，現在要破壞

277
00:10:29,500 --> 00:10:30,533
測試我們添加了

278
00:10:30,533 --> 00:10:33,433
一個參數的默認值，但

279
00:10:33,433 --> 00:10:34,800
這其實並不是我們

280
00:10:34,800 --> 00:10:36,366
在生產中想要的行為，我們希望有人總是傳遞

281
00:10:36,366 --> 00:10:37,333
一個完成塊，所以現在我們可以移動

282
00:10:37,333 --> 00:10:39,333
這個默認參數

283
00:10:39,333 --> 00:10:40,700
到測試範疇，好的

284
00:10:40,700 --> 00:10:43,733
這使我們能夠繼續進行

285
00:10:43,733 --> 00:10:46,933
所以這讓我們繼續進行

286
00:10:46,933 --> 00:10:48,800
在生產端載入函數

287
00:10:48,800 --> 00:10:50,700
不需要思考這個

288
00:10:50,700 --> 00:10:52,633
確實，我認為現在是個好時機來做這個

289
00:10:52,633 --> 00:10:54,366
對，讓我們提交它

290
00:10:54,366 --> 00:10:57,900
對，移除預設

291
00:10:57,900 --> 00:11:01,033
為達成的區塊（completion block）刪除預設值，然後移轉至測試。

292
00:11:01,033 --> 00:11:04,533
測試？好的。

293
00:11:04,533 --> 00:11:06,466
那麼下一個行為是什麼？我們來看看需求

294
00:11:06,466 --> 00:11:07,733
瞧瞧條件需求

295
00:11:07,733 --> 00:11:11,733
連接性已完成，現在看無效數據

296
00:11:11,733 --> 00:11:14,133
什麼是無效數據？如果我們看一下

297
00:11:14,133 --> 00:11:14,800
看看

298
00:11:14,800 --> 00:11:17,733
反應，我們會發現我們預期會得到一個

299
00:11:17,733 --> 00:11:19,100
200

300
00:11:19,100 --> 00:11:21,433
從伺服器返回的HTTP響應狀態碼

301
00:11:21,433 --> 00:11:22,233
服務器

302
00:11:22,233 --> 00:11:24,133
好的，我們可以從這裡開始，如果它不是一個

303
00:11:24,133 --> 00:11:25,433
200的反應

304
00:11:25,433 --> 00:11:29,266
那就是一個錯誤

305
00:11:29,266 --> 00:11:32,066
所以我想我會複製 delivers error 測試

306
00:11:32,066 --> 00:11:33,100
Error測試

307
00:11:33,100 --> 00:11:34,800
因為這也是一個錯誤測試，然後

308
00:11:34,800 --> 00:11:36,466
我們改變它，好的

309
00:11:36,466 --> 00:11:40,233
對，因此 delivers error on

310
00:11:40,233 --> 00:11:44,533
非 200 HTTP

311
00:11:44,533 --> 00:11:48,000
回應。好的，所以代替發送一個

312
00:11:48,000 --> 00:11:49,666
現在我們的客戶

313
00:11:49,666 --> 00:11:51,733
我們將要以一個狀態結束

314
00:11:51,733 --> 00:11:52,700
代碼

315
00:11:52,700 --> 00:11:55,833
是的，讓我們說400，那就是

316
00:11:55,833 --> 00:11:56,700
不是200的

317
00:11:56,700 --> 00:11:58,700
但它不再是連接錯誤

318
00:11:58,700 --> 00:12:00,233
是不是，不是

319
00:12:00,233 --> 00:12:03,266
那將會是無效的數據

320
00:12:03,266 --> 00:12:06,700
好的，那讓我們增加我們的案例無效

321
00:12:06,700 --> 00:12:09,733
數據，我們需要實現

322
00:12:09,733 --> 00:12:13,100
用狀態碼完成，對

323
00:12:13,100 --> 00:12:15,900
我們的間諜現在將幫助我們完成

324
00:12:15,900 --> 00:12:17,833
有狀態碼的

325
00:12:17,833 --> 00:12:20,133
是一個整數，讓我們也通過一個

326
00:12:20,133 --> 00:12:20,866
索引

327
00:12:20,866 --> 00:12:24,000
就像以前的信息一樣，所以我們怎麼能

328
00:12:24,000 --> 00:12:25,033
創建一個響應

329
00:12:25,033 --> 00:12:27,900
有一個狀態碼，基金會提供

330
00:12:27,900 --> 00:12:29,833
HTTPURLResponse類型

331
00:12:29,833 --> 00:12:32,700
完美，這就是我們可以使用的標準類型

332
00:12:32,700 --> 00:12:33,833
我們可以使用

333
00:12:33,833 --> 00:12:36,133
URL我們可以從

334
00:12:36,133 --> 00:12:38,066
requestedURLs取得，好吧

335
00:12:38,066 --> 00:12:41,033
在索引處的 requestedURLs ，完美的狀態

336
00:12:41,033 --> 00:12:41,600
代碼

337
00:12:41,600 --> 00:12:44,466
是傳遞給此方法的代碼和

338
00:12:44,466 --> 00:12:45,733
HTTP版本

339
00:12:45,733 --> 00:12:47,733
我不在乎這個，我也不在乎

340
00:12:47,733 --> 00:12:49,100
標頭內容

341
00:12:49,100 --> 00:12:52,133
好的，讓我們來格式化它

342
00:12:52,133 --> 00:12:54,633
然後我們像以前一樣調用我們的

343
00:12:54,633 --> 00:12:55,733
訊息

344
00:12:55,733 --> 00:12:59,033
在索引完成處，我們需要去

345
00:12:59,033 --> 00:12:59,733
完成

346
00:12:59,733 --> 00:13:02,933
與HTTPURLResponse一起完成，是嗎，嗯

347
00:13:02,933 --> 00:13:05,500
但我們還不能這樣做，因為我們需要去

348
00:13:05,500 --> 00:13:06,000
改變一些

349
00:13:06,000 --> 00:13:08,800
東西，因為到目前為止，此客戶端

350
00:13:08,800 --> 00:13:10,300
只能用一個錯誤來完成

351
00:13:10,300 --> 00:13:13,200
所以一種方法是添加

352
00:13:13,200 --> 00:13:14,000
另一個

353
00:13:14,000 --> 00:13:16,300
在錯誤之後的值，如果我有一個

354
00:13:16,300 --> 00:13:17,033
回應

355
00:13:17,033 --> 00:13:18,933
我就不會有錯誤，例如

356
00:13:18,933 --> 00:13:20,300
錯誤是空的

357
00:13:20,300 --> 00:13:22,233
對，但我有一個回應，在

358
00:13:22,233 --> 00:13:24,133
這裡的錯誤情況下我有錯誤，但是我

359
00:13:24,133 --> 00:13:25,033
沒有回應

360
00:13:25,033 --> 00:13:27,433
這是正確的，好的，所以我們開始

361
00:13:27,433 --> 00:13:29,033
添加一些可空值，未來我們可能需要

362
00:13:29,033 --> 00:13:30,533
重新訪問這個問題

363
00:13:30,533 --> 00:13:32,466
但顯然那是目前最簡單的事情

364
00:13:32,466 --> 00:13:34,866
所以現在讓我們加一個URL

365
00:13:34,866 --> 00:13:35,500
回應

366
00:13:35,500 --> 00:13:38,633
也是可選的，好，讓我們解決

367
00:13:38,633 --> 00:13:39,900
編譯器錯誤吧

368
00:13:39,900 --> 00:13:43,433
我們現在得到錯誤結束回應

369
00:13:43,433 --> 00:13:46,933
好的，這問題解決了

370
00:13:46,933 --> 00:13:50,133
在spy中，我們也得到了一個可選的Error

371
00:13:50,133 --> 00:13:54,700
還有一個可選的HTTPURLResponse

372
00:13:54,700 --> 00:13:59,500
在get方法中也是一樣，讓我們執行

373
00:13:59,500 --> 00:14:02,700
測試失敗，完美

374
00:14:02,700 --> 00:14:05,333
期望得到的是無效數據，但卻得到

375
00:14:05,333 --> 00:14:06,533
連接性

376
00:14:06,533 --> 00:14:08,933
因為我們總是用連接性

377
00:14:08,933 --> 00:14:09,733
完成的

378
00:14:09,733 --> 00:14:12,300
錯誤，所以讓我們在那裡添加一些邏輯

379
00:14:12,300 --> 00:14:13,166
解決那個問題

380
00:14:13,166 --> 00:14:15,100
我想這應該很簡單，我們可以

381
00:14:15,100 --> 00:14:17,033
檢查錯誤或檢查回應

382
00:14:17,033 --> 00:14:21,433
對，所以如果回應不是空的

383
00:14:21,433 --> 00:14:24,866
我們就完成無效數據

384
00:14:24,866 --> 00:14:27,733
否則我們完成連接性，我

385
00:14:27,733 --> 00:14:29,433
覺得那應該可以

386
00:14:29,433 --> 00:14:32,700
完美，它通過了，真棒且


387
00:14:32,700 --> 00:14:34,633
只是為了展示它的重要性

388
00:14:34,633 --> 00:14:36,933
捕獲所有錯誤到一個陣列中

389
00:14:36,933 --> 00:14:39,166
如果我將這個connectivity移到

390
00:14:39,166 --> 00:14:41,166
if語句之外，我已經見過這個錯誤

391
00:14:41,166 --> 00:14:44,300
在許多代碼庫中無數次，我們會

392
00:14:44,300 --> 00:14:45,333
得到一個失敗的測試

393
00:14:45,333 --> 00:14:48,366
是的，因為陣列，是的。

394
00:14:48,366 --> 00:14:51,666
正確，如你所見，我們得到了兩個錯誤

395
00:14:51,666 --> 00:14:53,733
我見過許多代碼庫，我們作為開發人員

396
00:14:53,733 --> 00:14:55,733
忘記添加else

397
00:14:55,733 --> 00:14:58,066
我們只是每一次都完成

398
00:14:58,066 --> 00:14:58,933
正確。

399
00:14:58,933 --> 00:15:00,866
所以檢查完成的次數

400
00:15:00,866 --> 00:15:02,633
被調用是重要的，我希望它被

401
00:15:02,633 --> 00:15:03,500
完成

402
00:15:03,500 --> 00:15:06,633
一次且只有一次，每次請求，讓我們執行

403
00:15:06,633 --> 00:15:07,433
測試

404
00:15:07,433 --> 00:15:10,833
並提交

405
00:15:10,833 --> 00:15:14,233
傳遞非法數據

406
00:15:14,233 --> 00:15:18,066
在非200的HTTP

407
00:15:18,066 --> 00:15:21,733
響應上的錯誤，是的，我知道很多

408
00:15:21,733 --> 00:15:22,133
人

409
00:15:22,133 --> 00:15:25,900
現在正在想，你有一個測試

410
00:15:25,900 --> 00:15:28,700
就400情況的測試，那是關於什麼

411
00:15:28,700 --> 00:15:31,733
500怎麼樣？404呢？

412
00:15:31,733 --> 00:15:36,066
201呢？199呢？

413
00:15:36,066 --> 00:15:39,166
對，這些都是好範例，我們能

414
00:15:39,166 --> 00:15:42,533
透過測試這些案例來保護

415
00:15:42,533 --> 00:15:44,933
所以究竟要多少才夠呢？這是個

416
00:15:44,933 --> 00:15:46,233
不錯的問題

417
00:15:46,233 --> 00:15:48,233
我在檢查整數的時候，我喜歡

418
00:15:48,233 --> 00:15:49,733
檢查一個數字

419
00:15:49,733 --> 00:15:52,533
比這個數值小一，再比這個數

420
00:15:52,533 --> 00:15:53,100
值大一。

421
00:15:53,100 --> 00:15:55,433
在幾個情況下。是的，我猜你

422
00:15:55,433 --> 00:15:56,700
可能非常徹底，

423
00:15:56,700 --> 00:15:59,666
也確實檢查所有數值。你可以說從

424
00:15:59,666 --> 00:16:01,166
零到無窮大，

425
00:16:01,166 --> 00:16:04,300
並且你這樣操作了無數次。是的，但我認為

426
00:16:04,300 --> 00:16:07,266
這是一個很好的組合。

427
00:16:07,266 --> 00:16:08,633
對，我也這麼認為。

428
00:16:08,633 --> 00:16:12,233
所以我們逐一查看所有的範例，

429
00:16:12,233 --> 00:16:14,633
然後我們記錄下程式碼。

430
00:16:14,633 --> 00:16:17,100
而且由於我們將錯誤記錄在

431
00:16:17,100 --> 00:16:18,866
一個陣列中，我們想重置這個陣列，

432
00:16:18,866 --> 00:16:21,500
在我們完成後，它被重新配置了。

434
00:16:25,600 --> 00:16:27,900
但我認為這在測試過後的重置

435
00:16:27,900 --> 00:16:29,600
可能會讓【代碼】的讀者感到困惑

436
00:16:29,600 --> 00:16:30,233
代碼

437
00:16:30,233 --> 00:16:32,800
那麼，為何我們不是重置，

438
00:16:32,800 --> 00:16:34,466
而是執行這個

439
00:16:34,466 --> 00:16:37,333
適用於所有情況，然後我們希望

440
00:16:37,333 --> 00:16:38,300
完成

441
00:16:38,300 --> 00:16:43,266
在特定索引處完成客戶的請求

442
00:16:43,266 --> 00:16:45,833
而這個索引可以是【數組】的索引

443
00:16:45,833 --> 00:16:46,933
數組在這裡

444
00:16:46,933 --> 00:16:51,166
所以我們可以列舉我們的範例

445
00:16:51,166 --> 00:16:53,733
然後我們得到索引和代碼

446
00:16:53,733 --> 00:16:57,333
來執行測試

447
00:16:57,333 --> 00:16:59,666
通過了，但這很難閱讀，讓我們

448
00:16:59,666 --> 00:17:00,866
把這個放入一個常數中

449
00:17:00,866 --> 00:17:05,333
並稱之為樣本

450
00:17:05,333 --> 00:17:10,300
再次執行測試，太好了

451
00:17:10,300 --> 00:17:13,333
增加更多的測試聲明

452
00:17:13,333 --> 00:17:18,066
針對不同的HTTP狀態代碼

453
00:17:18,066 --> 00:17:20,066
好的，還有其他我們可以重構的

454
00:17:20,066 --> 00:17:21,566
在這裡產品代碼中

455
00:17:21,566 --> 00:17:24,633
是的，我對這個API非常不滿意

456
00:17:24,633 --> 00:17:26,400
有可選的錯誤

457
00:17:26,400 --> 00:17:30,066
對，對，對，對我來說，問題在於

458
00:17:30,066 --> 00:17:32,866
我們或是有一個錯誤或是一個HTTPURL

459
00:17:32,866 --> 00:17:33,500
反應

460
00:17:33,500 --> 00:17:35,833
到現在為止，我們可以代表一個案例

461
00:17:35,833 --> 00:17:37,266
這裡的兩個都是"nil"

462
00:17:37,266 --> 00:17:39,033
錯誤為"nil"，HTTPURL

463
00:17:39,033 --> 00:17:40,700
反應為"nil"，這應該從來不會

464
00:17:40,700 --> 00:17:41,200
發生

465
00:17:41,200 --> 00:17:43,033
對吧，如果某件事不該發生

466
00:17:43,033 --> 00:17:45,100
它不應該在我們的

467
00:17:45,100 --> 00:17:45,566
代碼中表示

468
00:17:45,566 --> 00:17:48,233
正確，我們允許像這樣的案例

469
00:17:48,233 --> 00:17:48,866
正確

470
00:17:48,866 --> 00:17:52,233
因為錯誤有兩種狀態"nil"

471
00:17:52,233 --> 00:17:55,200
或者有一個值和HTTPURLResponse

472
00:17:55,200 --> 00:17:55,733
在這裡

473
00:17:55,733 --> 00:17:57,833
由於它是可選的，它也有兩種情況

474
00:17:57,833 --> 00:18:00,000
對，"nil"或有值，所以我們可以

475
00:18:00,000 --> 00:18:00,866
在這裡表示

476
00:18:00,866 --> 00:18:04,066
為什麼有四種不同的狀態

477
00:18:04,066 --> 00:18:06,766
當我們可以有兩個時，對，所以我們可以

478
00:18:06,766 --> 00:18:07,833
創建一種新的類型

479
00:18:07,833 --> 00:18:11,433
讓我們將其公開枚舉HTTP

480
00:18:11,433 --> 00:18:15,433
ClientResult，它可能是成功

481
00:18:15,433 --> 00:18:18,466
帶有HTTPURLResponse，對的

482
00:18:18,466 --> 00:18:21,666
或者是出現了帶有Error的失敗，就這麼簡單

483
00:18:21,666 --> 00:18:25,100
現在我們將其限制在兩個分支

484
00:18:25,100 --> 00:18:27,100
我們要麼會得到一個成功

485
00:18:27,100 --> 00:18:28,633
帶有一个response或者是

486
00:18:28,633 --> 00:18:31,100
帶有一個錯誤的失敗，所以現在我們可以

487
00:18:31,100 --> 00:18:32,533
取代選項型

488
00:18:32,533 --> 00:18:36,300
與我們的枚舉型態，現在的代碼現在

489
00:18:36,300 --> 00:18:39,733
只得到一個結果型態，而不是使用

490
00:18:39,733 --> 00:18:42,133
如果語句，我們可以對

491
00:18:42,133 --> 00:18:43,500
結果類型進行切換

492
00:18:43,500 --> 00:18:46,633
所以案例成功

493
00:18:46,633 --> 00:18:50,000
我們暫時先用invalidData來完成

494
00:18:50,000 --> 00:18:52,066
對我知道這聽起來很荒謬，但這就是

495
00:18:52,066 --> 00:18:53,900
我們現在需要的

496
00:18:53,900 --> 00:18:55,733
而对于失敗案例，我们完成带有一个

497
00:18:55,733 --> 00:18:58,066
連接性錯誤

498
00:18:58,066 --> 00:19:00,066
讓我們改變我們的間諜，所以這樣同樣的

499
00:19:00,066 --> 00:19:01,266
在間諜裡面也能做到一樣的事情

500
00:19:01,266 --> 00:19:07,600
我們現在應該使用我們的HTTPClientResult

501
00:19:07,600 --> 00:19:09,200
當我們現在完成的時候，我們不需要

502
00:19:09,200 --> 00:19:10,633
傳遞空值

503
00:19:10,633 --> 00:19:13,266
我們只需要將我們的response包裹在正確的

504
00:19:13,266 --> 00:19:14,233
分支中

505
00:19:14,233 --> 00:19:17,266
對於錯誤，則使用失敗分支，而

506
00:19:17,266 --> 00:19:20,766
對於response，則使用成功分支

507
00:19:20,766 --> 00:19:24,400
很好，因為 HTTPURLResponse 的初始器回傳的是一個 optional

508
00:19:24,400 --> 00:19:27,900
就如你在這裡看到的一樣，我們來強行解包它

509
00:19:27,900 --> 00:19:30,300
因為我們知道這個硬編碼的 HTTPURLResponse

510
00:19:30,300 --> 00:19:32,000
我們正在創建的始終是有效的

511
00:19:32,000 --> 00:19:33,900
所以讓我們運行我們的測試

512
00:19:33,900 --> 00:19:35,200
它通過了，太好了，就讓我們提交吧

513
00:19:35,200 --> 00:19:38,533
所以替換

514
00:19:38,533 --> 00:19:41,733
使用 optional parameters

515
00:19:41,733 --> 00:19:42,766
與帶有成功

516
00:19:42,766 --> 00:19:46,233
和失敗的案例的 enum

517
00:19:46,233 --> 00:19:49,266
我認為這種方式更好

518
00:19:49,266 --> 00:19:52,533
絕對的，我認為我們這集已經講完了

519
00:19:52,533 --> 00:19:55,100
讓我們回顧一下，我們已經前進到檢查 Remote

520
00:19:55,100 --> 00:19:56,400
FeedLoader 的行為那題，這是一個錯誤

521
00:19:56,400 --> 00:19:59,900
我們將客戶端錯誤映射到域級別的錯誤

522
00:19:59,900 --> 00:20:02,000
在這個案子中，其實就是 connectivity error

523
00:20:02,000 --> 00:20:03,833
還有當我們得到一個已知的 200 HTTP response

524
00:20:03,833 --> 00:20:06,233
我們也將它映射為一個域錯誤 invalid

525
00:20:06,233 --> 00:20:08,066
在這個案子，就是 data

526
00:20:08,066 --> 00:20:09,266
最後，我們展示的是如何進行

527
00:20:09,266 --> 00:20:12,400
設計的一種方法


532
00:20:20,466 --> 00:20:24,000
排除你不希望發生的情況的API

533
00:20:24,000 --> 00:20:27,266
在這種情況下你絕不希望發生的事情

534
00:20:27,266 --> 00:20:30,466
移除雙重可選參數

535
00:20:30,466 --> 00:20:34,000
取而代之的是一個枚舉，所以目標是

536
00:20:34,000 --> 00:20:34,466
製作

537
00:20:34,466 --> 00:20:37,266
不能表現的無效路徑，並在

538
00:20:37,266 --> 00:20:38,700
這種情況下，而不是使用

539
00:20:38,700 --> 00:20:41,266
兩個可選的我們有一個兩個

540
00:20:41,266 --> 00:20:41,900
案例的枚舉

541
00:20:41,900 --> 00:20:43,900
所以它是這個還是那個，我們

542
00:20:43,900 --> 00:20:46,066
消除兩種無效狀態

543
00:20:46,066 --> 00:20:48,933
這是一個巨大的勝利，絕對可以想像如果

544
00:20:48,933 --> 00:20:49,433
我們有

545
00:20:49,433 --> 00:20:52,000
第三個可選參數，那麼它

546
00:20:52,000 --> 00:20:53,200
將會是混亂的

547
00:20:53,200 --> 00:20:55,600
是的，我們將可以表現出八種

548
00:20:55,600 --> 00:20:56,866
可能的狀態

549
00:20:56,866 --> 00:20:59,833
因為當我們結合可選項時

550
00:20:59,833 --> 00:21:01,833
可以表示的狀態數量會呈指數增長

551
00:21:01,833 --> 00:21:02,766
指數級的

552
00:21:02,766 --> 00:21:05,033
誰知道這些狀況有多少我們實際上

553
00:21:05,033 --> 00:21:06,300
從不希望發生，可能大多數都是

554
00:21:06,300 --> 00:21:09,600
我們從來不想發生的，可能大部分是對的

555
00:21:09,600 --> 00:21:12,700
正確的，我們也展示了如何進行測試

556
00:21:12,700 --> 00:21:15,733
通過擁有一個簡單的數組來使用樣本

557
00:21:15,733 --> 00:21:18,000
以及在捕捉

558
00:21:18,000 --> 00:21:19,600
spy中的值

559
00:21:19,600 --> 00:21:22,000
和我們的假設行為之間的區別

560
00:21:22,000 --> 00:21:23,200
現行測試

561
00:21:23,200 --> 00:21:25,433
我們選擇捕捉值以保持我們的

562
00:21:25,433 --> 00:21:26,233
spy

563
00:21:26,233 --> 00:21:29,433
清潔而簡單，並保持其純度

564
00:21:29,433 --> 00:21:32,933
沒必要混合那兩者，接下來

565
00:21:32,933 --> 00:21:35,900
我們應開始映射反應

566
00:21:35,900 --> 00:21:36,533
成為

567
00:21:36,533 --> 00:21:40,133
FeedItems，對的，快樂的路徑和處理

568
00:21:40,133 --> 00:21:42,466
映射錯誤也是一樣的，那就是傷心的路徑

569
00:21:42,466 --> 00:21:43,500
對吧

570
00:21:43,500 --> 00:21:45,433
所以，感謝觀看，我們將在

571
00:21:45,433 --> 00:21:59,833
下次見到你，再見，大家。
