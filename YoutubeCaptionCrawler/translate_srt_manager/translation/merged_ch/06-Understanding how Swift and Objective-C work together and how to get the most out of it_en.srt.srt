

1
00:00:01,000 --> 00:00:04,840
大家好，歡迎回到我們的工具系列。

2
00:00:05,720 --> 00:00:08,720
今天我們將探索另一個酷炫主題，

3
00:00:08,720 --> 00:00:13,520
那就是混合使用Objective-C和Swift。

4
00:00:13,520 --> 00:00:16,200
這很重要，因為現在有很多項目

5
00:00:16,200 --> 00:00:18,960
仍然包含Swift和Objective-C的混合。

6
00:00:19,800 --> 00:00:23,100
即使那些只使用Swift的項目，

7
00:00:23,100 --> 00:00:24,640
也會使用系統框架，

8
00:00:24,640 --> 00:00:27,360
這些主要是用Objective-C寫的。

9
00:00:27,360 --> 00:00:32,140
所以，要成為一個全面的Senior iOS開發者，

10
00:00:32,140 --> 00:00:33,580
真的很重要去知道

11
00:00:33,580 --> 00:00:35,960
如何混合這兩種語言，

12
00:00:35,960 --> 00:00:37,780
以及如何最大效益地利用它。

13
00:00:40,460 --> 00:00:44,940
今天的計劃是了解如何使用Clang

14
00:00:44,940 --> 00:00:49,420
或C-Lang和Swift編輯器找到聲明，

15
00:00:51,060 --> 00:00:53,860
以及如何在不同的設置中混合Swift和Objective-C代碼，

16
00:00:53,860 --> 00:00:55,460
在不同的設置中混合他們。

17
00:00:55,460 --> 00:01:00,460
看看我們如何讓我們的Objective-C APIs更加的Swifty，

18
00:01:01,500 --> 00:01:03,300
如果那是一個被接受的詞。

19
00:01:04,980 --> 00:01:08,100
並看看一個常見的問題，

20
00:01:08,100 --> 00:01:10,620
我們如何撰寫 Swift 程式碼

21
00:01:10,620 --> 00:01:12,860
該程式碼使用了所有的語言特性

22
00:01:12,860 --> 00:01:15,440
如果我們需要將此程式碼公開給 Objective-C。

23
00:01:16,420 --> 00:01:18,860
我們將給您一種解決方案的方法。

24
00:01:20,740 --> 00:01:23,180
如同往常，我們將以問答環節作結，

25
00:01:23,180 --> 00:01:26,780
但如果講座期間有問題，

26
00:01:26,780 --> 00:01:30,160
我會嘗試即時回應。

27
00:01:32,260 --> 00:01:34,840
從我們先前講座的快速回顧

28
00:01:34,840 --> 00:01:36,120
關於建置系統。

29
00:01:37,140 --> 00:01:40,020
我們知道 Apple 提供了兩種不同的編譯器

30
00:01:40,020 --> 00:01:41,260
內建於Xcode中。

31
00:01:42,340 --> 00:01:47,340
C-Lang 或 Clang 是針對基於 C 的語言的編譯器

32
00:01:47,340 --> 00:01:51,420
如 C，C++，Objective-C，Objective-C++。

33
00:01:51,420 --> 00:01:54,620
Swift 編譯器是編譯 Swift 程式碼。

34
00:01:56,740 --> 00:01:59,700
了解建置系統的運作方式中的一個重要部分

35
00:01:59,700 --> 00:02:02,960
受兩種編譯器如何協同工作的影響。

36
00:02:04,860 --> 00:02:08,660
Clang 單獨編譯每一個 Objective-C 檔案。

37
00:02:10,860 --> 00:02:13,860
如果你想參照來自其他檔案的類別，

38
00:02:13,860 --> 00:02:18,660
你必須匯入宣告該類別的頁首。

39
00:02:18,660 --> 00:02:21,900
我們將深入探討這些頁首檔案如何運作

40
00:02:21,900 --> 00:02:23,040
在幾分鐘之內，

41
00:02:24,540 --> 00:02:27,040
但我認為你能辨認出語法結構。

42
00:02:30,480 --> 00:02:34,920
相較之下，Swift 過去單獨編譯每個檔案，

43
00:02:35,880 --> 00:02:38,320
但在 Apple 進行多次改進之後

44
00:02:38,320 --> 00:02:39,940
對建置系統，

45
00:02:39,940 --> 00:02:43,240
Swift 編譯器現在能一次編譯多個檔案。

46
00:02:44,300 --> 00:02:47,280
這並不如 Swift

47
00:02:47,280 --> 00:02:49,460
被設計成不需要頁首那麼重要。

48
00:02:50,320 --> 00:02:53,540
這是因為頁首重覆且難以管理。

49
00:02:54,360 --> 00:02:57,100
沒有頁首讓開始變得簡單

50
00:02:57,100 --> 00:03:00,640
使用該語言並避免重複聲明。

51
00:03:02,680 --> 00:03:05,800
然而，這意味著Swift編譯器

52
00:03:05,800 --> 00:03:08,100
需要進行一些額外的記帳。

53
00:03:11,380 --> 00:03:15,340
所以讓我們一如既往的使用我們的EssentialFeed用例庫，

54
00:03:15,340 --> 00:03:18,660
並看看編譯器如何解析聲明

55
00:03:18,660 --> 00:03:21,960
在不同的情境下，以及那個booking View如何運作。

56
00:03:25,860 --> 00:03:29,900
EssentialFeed庫沒有任何Objective-C的程式碼，

57
00:03:29,900 --> 00:03:30,980
但我們將新增一些。

58
00:03:31,820 --> 00:03:35,980
我將開始創立一個叫做Logger的Objective-C類別，

59
00:03:35,980 --> 00:03:38,660
並將其新增到EssentialFeed項目中。

60
00:03:40,200 --> 00:03:43,140
所以我將點擊右鍵在EssentialFeed群組，

61
00:03:43,140 --> 00:03:47,180
設定新檔案，

62
00:03:47,180 --> 00:03:50,420
並在這裡花一些時間

63
00:03:50,420 --> 00:03:52,100
查看檔案模板。

64
00:03:54,740 --> 00:03:59,740
有一個Objective-C檔案模板用於實現，

65
00:04:00,840 --> 00:04:03,440
和一個標題檔案模板用於標頭。

66
00:04:04,820 --> 00:04:09,300
由於沒有Objective-C依賴於結合標頭檔案.h

67
00:04:09,300 --> 00:04:11,940
和實現檔案，m。

68
00:04:11,940 --> 00:04:14,500
這些範本就足夠了。

69
00:04:14,500 --> 00:04:18,380
但也有 CocoaTouch 類範本，

70
00:04:18,380 --> 00:04:22,660
它同時建立標頭

71
00:04:22,660 --> 00:04:25,660
和實作檔案的輔助工具。

72
00:04:25,660 --> 00:04:28,220
為了方便，我們使用這一個。

73
00:04:28,220 --> 00:04:29,540
所以我將雙擊它。

74
00:04:30,620 --> 00:04:33,780
我會輸入我的類別名稱，將會是 Logger。

75
00:04:34,660 --> 00:04:36,940
我們的使用語言將會是 Objective-C。

76
00:04:36,940 --> 00:04:41,940
我們將它放在根目錄。

77
00:04:46,220 --> 00:04:51,220
我們可以立即注意到一些有趣的指令

78
00:04:51,220 --> 00:04:53,860
像是這個 nsassume non-node。

79
00:04:53,860 --> 00:04:55,840
現在，我將先移除它們，

80
00:04:55,840 --> 00:04:57,820
然後我們再稍後討論它們，

81
00:04:57,820 --> 00:05:00,860
因為我們真的想要解釋它們是做什麼的。

82
00:05:02,540 --> 00:05:06,520
所以我們现在有一个简单的 Logger 接口，

83
00:05:06,520 --> 00:05:10,580
它繼承自 NSObject 和實作檔案，

84
00:05:10,580 --> 00:05:11,480
兩者都是空的。

85
00:05:12,820 --> 00:05:15,700
所以 Objective-C 是如何找到宣告的呢

86
00:05:15,700 --> 00:05:18,500
從其他的 Objective-C 檔案裡？

87
00:05:18,500 --> 00:05:22,840
嗯，透過使用標頭(header)並且導入(import)它們。

88
00:05:24,200 --> 00:05:28,040
任何使用 Objective-C 的人都應該對這個非常熟悉。

89
00:05:28,040 --> 00:05:30,620
就是那些在開頭的導入(import)語句

90
00:05:30,620 --> 00:05:34,380
在 .h 或者 .m 的 Objective-C 檔案裡。

91
00:05:34,380 --> 00:05:39,380
標頭檔(header files)是 Objective-C

92
00:05:40,820 --> 00:05:43,500
從 C 和C++ 借來的觀念。

93
00:05:43,500 --> 00:05:45,620
需要了解的重點是，標頭(header)

94
00:05:45,620 --> 00:05:48,140
必須包含我們想向其他檔案揭露的宣告

95
00:05:48,140 --> 00:05:49,620
給其他檔案。

96
00:05:49,620 --> 00:05:53,380
或者換句話說，如果我們想把任何實體

97
00:05:53,380 --> 00:05:55,480
對外揭露給其他檔案或者模組，

98
00:05:55,480 --> 00:05:57,180
我們需要在標頭(header)中宣告它。

99
00:05:58,820 --> 00:06:02,700
當我們提到"實體"，就是指類別、協議，

100
00:06:02,700 --> 00:06:07,400
全局函數，全局變量，枚舉等等。

101
00:06:10,260 --> 00:06:13,420
所以一個實體的宣告包含

102
00:06:13,420 --> 00:06:16,400
該實體的高級簽名，

103
00:06:16,400 --> 00:06:18,940
但沒有具體的實現。

104
00:06:20,660 --> 00:06:22,400
讓我們來看看這個差異。

105
00:06:23,820 --> 00:06:28,820
我將在我的myLogger類別中添加一個名為log的方法。

106
00:06:28,820 --> 00:06:31,420
這是一個簡單的方法，返回值為Void

107
00:06:31,420 --> 00:06:34,420
並接收一個String Message參數。

108
00:06:36,700 --> 00:06:40,700
首先，我們看到Logger類別的宣告，

109
00:06:40,700 --> 00:06:45,700
我們用add interface進行標記，並提到一個子類別

110
00:06:47,220 --> 00:06:49,100
在任何主題中。

111
00:06:49,100 --> 00:06:53,100
還有一個log Message的宣告。

112
00:06:53,100 --> 00:06:58,100
它只包含簽名，但並不包含主體。

113
00:06:59,500 --> 00:07:04,500
現在讓我們添加這個Objective-C檔案的實現。

114
00:07:07,420 --> 00:07:12,420
我為我們的log Message方法增加了實現，

115
00:07:12,420 --> 00:07:15,860
我在header中增加了這個，但我還增加了

116
00:07:15,860 --> 00:07:19,380
一個名為private log的私有函式。

117
00:07:19,380 --> 00:07:24,380
在內部，我們的公開方法調用了私有方法。

118
00:07:25,500 --> 00:07:27,820
我想在這裡強調的是，

119
00:07:27,820 --> 00:07:31,140
一、這次的Logger類別的定義

120
00:07:31,140 --> 00:07:36,140
標記為add implementation存在於.mp檔案中。

121
00:07:36,860 --> 00:07:41,860
然後log函數的主體就是在.mp檔案中的定義

122
00:07:41,860 --> 00:07:46,780
我們只能使用這個.mp檔案，

123
00:07:46,780 --> 00:07:51,780
我們也可以添加其他簽名，

124
00:07:53,140 --> 00:07:57,900
和他們像這樣的定義，比如叫做private log message，

125
00:07:57,900 --> 00:08:01,620
我們不需要將它暴露給其他文件。

126
00:08:03,140 --> 00:08:04,660
現在回到我們的標頭文件。

127
00:08:07,620 --> 00:08:10,260
保持標頭文件盡可能短是最好的實踐方式，

128
00:08:10,260 --> 00:08:12,220
要盡量只包括宣告，

129
00:08:12,220 --> 00:08:15,620
例如類別、方法、協議等實體，

130
00:08:15,620 --> 00:08:18,780
需要與其他文件共享的實體。

131
00:08:18,780 --> 00:08:22,780
你仍然可以在.mp檔案中添加他們的定義，

132
00:08:24,380 --> 00:08:26,580
像我們剛才那樣。

133
00:08:26,580 --> 00:08:28,980
對於頭文件，建議保持

134
00:08:30,500 --> 00:08:33,700
每個頭文件中所需引入的最小數量。

135
00:08:33,700 --> 00:08:38,260
限制引入可以幫助編譯器，

136
00:08:38,260 --> 00:08:42,980
保持引導限制有助於編譯器的運作。

137
00:08:42,980 --> 00:08:45,700
輕鬆解決這些導入以及結果代碼

138
00:08:45,700 --> 00:08:48,460
將是最小的，代碼大小也將是最小的。

139
00:08:52,220 --> 00:08:55,780
我們可以在我們的 .mp 實現中定義更多實體

140
00:08:55,780 --> 00:09:00,780
而不向其他文件公開它們。

141
00:09:01,100 --> 00:09:05,260
於是我將替換我們現有的這個實現

142
00:09:06,540 --> 00:09:08,420
換成一個更複雜的版本。

143
00:09:08,420 --> 00:09:13,420
所以我添加了一個 Logger 類型 enum，帶有兩種情形，

144
00:09:13,940 --> 00:09:15,220
控制台和文件。

145
00:09:16,100 --> 00:09:21,100
我添加了一個，我們就稱之為私有類 Logger helper

146
00:09:21,420 --> 00:09:24,820
不在 .mp 文件之外可見

147
00:09:24,820 --> 00:09:27,820
它有一個類方法清除日誌。

148
00:09:29,580 --> 00:09:33,380
為了清楚說明，我們實際上在呼叫

149
00:09:33,380 --> 00:09:37,100
從我們的 Logger 中對話框清除日誌。

150
00:09:37,100 --> 00:09:41,180
所以每當我們對話記錄器時，我們都清理日誌。

151
00:09:43,020 --> 00:09:46,420
再次，這些新的實體都可用

152
00:09:46,420 --> 00:09:50,060
在我的 .mp 文件裡面，但是它們並未被公開。

153
00:09:50,060 --> 00:09:51,940
他們並不屬於任何標頭檔。

154
00:09:53,980 --> 00:09:56,420
現在我們提到這個術語，導入標頭檔

155
00:09:56,420 --> 00:09:58,780
我想釐清這是什麼意思。

156
00:10:01,900 --> 00:10:06,620
雜湊導入是一種巨集，與其它的非常類似，

157
00:10:06,620 --> 00:10:10,860
來自C, C++的另一種巨集，那就是包含。

158
00:10:10,860 --> 00:10:12,820
它們實際上十分相似。

159
00:10:13,820 --> 00:10:16,340
您將被預編譯器簡單地替換掉

160
00:10:16,340 --> 00:10:20,540
以標頭檔的完全內容

161
00:10:20,540 --> 00:10:24,100
他們指向，就像複製和粘貼一樣。

162
00:10:26,140 --> 00:10:29,020
因此，由於這種情況發生在所有巨集上，

163
00:10:29,020 --> 00:10:31,180
並且是一種遞迴的過程，

164
00:10:31,180 --> 00:10:33,540
這可能導致檔案非常大

165
00:10:33,540 --> 00:10:37,060
當然，潛在的符號重複也是一個問題。

166
00:10:38,900 --> 00:10:40,980
為了讓這點更明瞭，

167
00:10:40,980 --> 00:10:44,620
如果我們去看Foundation標頭檔的定義，

168
00:10:44,620 --> 00:10:49,620
您會發現它實際上導入了像170個其他的標頭檔，

169
00:10:51,060 --> 00:10:52,660
所有這些都有大量的內容。

170
00:10:52,660 --> 00:10:57,140
所以你可以想象當這些宏展開時，簡單的Logger header的大小。

171
00:10:57,140 --> 00:10:59,820
當這些宏展開時。

172
00:10:59,820 --> 00:11:04,820
所以比較這兩者，import macro有點更先進。

173
00:11:06,220 --> 00:11:08,620
它是為Objective-C增加的。

174
00:11:08,620 --> 00:11:11,660
並且它避免了重複的宣告。

175
00:11:11,660 --> 00:11:14,620
如果同一文件被多次導入。

176
00:11:15,500 --> 00:11:17,180
如果你有一個Objective-C的項目，

177
00:11:17,180 --> 00:11:21,540
你可能很多次導入Foundation或UI key。

178
00:11:21,540 --> 00:11:23,460
但是它們仍然能夠運行。

179
00:11:23,460 --> 00:11:26,700
所以你不會因此得到像是重複符號的錯誤。

180
00:11:26,700 --> 00:11:30,220
因為在C中，我們必須更小心，

181
00:11:30,220 --> 00:11:32,180
我會在稍後向你展示。

182
00:11:32,180 --> 00:11:33,580
因為Xcode header File模板

183
00:11:33,580 --> 00:11:37,020
包含這些指示。

184
00:11:37,020 --> 00:11:39,220
所以在時間軸上Objective-C已經進化。

185
00:11:40,740 --> 00:11:43,500
蘋果添加了一種新的導入方式。

186
00:11:43,500 --> 00:11:46,580
它們被稱為語義導入。

187
00:11:46,580 --> 00:11:48,820
他們被稱為語義導入。

188
00:11:48,820 --> 00:11:53,820
他們嘗試取代 hashtag import。

189
00:11:53,820 --> 00:11:54,660
Hashtag import。

190
00:11:56,020 --> 00:12:00,060
他們看起來像在framework的名稱中使用import，

191
00:12:03,540 --> 00:12:04,380
像這樣。

192
00:12:07,380 --> 00:12:11,780
實際上，如果你的grand啟用了模塊建置設置

193
00:12:11,780 --> 00:12:14,860
設置為yes，這是預設設置，

194
00:12:16,340 --> 00:12:21,340
那些hashtag import甚至會被編譯器替換

195
00:12:21,340 --> 00:12:25,940
用at import或這些語義導入。

196
00:12:25,940 --> 00:12:29,620
所以你無需手動轉換，

197
00:12:29,620 --> 00:12:31,620
就能免費得到這個。

198
00:12:33,500 --> 00:12:37,620
因為他們做的是同一件事，我現在先刪除後者。

199
00:12:43,020 --> 00:12:44,820
使用這些語義導入

200
00:12:44,820 --> 00:12:47,180
比常規的導入更有效，

201
00:12:47,180 --> 00:12:48,940
導致建置更快，

202
00:12:48,940 --> 00:12:52,220
尤其是避免了編譯問題。

203
00:12:52,220 --> 00:12:54,500
建置速度更快是因為編譯器

204
00:12:54,500 --> 00:12:56,220
不需要解析頭文件，

205
00:12:57,100 --> 00:12:59,580
它可以依賴模塊映射。

206
00:12:59,580 --> 00:13:02,020
我們將在幾分鐘後討論模組地圖。

207
00:13:04,700 --> 00:13:08,660
您可能會想，Xcode如何找到這些我們在這裡提到的頭文件

208
00:13:08,660 --> 00:13:10,020
我們在這裡提到的？

209
00:13:10,020 --> 00:13:13,660
好吧，結果是它有一個相當複雜的機制

210
00:13:13,660 --> 00:13:16,140
用於定位頭文件。

211
00:13:16,140 --> 00:13:21,140
它使用不同的構建設置，例如頭文件搜尋路徑

212
00:13:24,260 --> 00:13:27,740
或者用戶頭文件搜尋路徑等等，

213
00:13:27,740 --> 00:13:29,380
以及在系統路徑上

214
00:13:29,380 --> 00:13:33,180
系統框架所在位置進行頭文件搜尋。

215
00:13:35,940 --> 00:13:38,060
當你想要分享 Objective-C 的代碼

216
00:13:38,060 --> 00:13:40,460
到另一個模組，

217
00:13:40,460 --> 00:13:42,620
你必須分享該模組的二進制代碼

218
00:13:42,620 --> 00:13:43,980
以及頭文件。

219
00:13:43,980 --> 00:13:48,220
如果沒有每一個頭文件，你的模組的客戶端

220
00:13:48,220 --> 00:13:50,900
無法找到模組內部的聲明，

221
00:13:50,900 --> 00:13:52,700
所以他們無法使用你的類型。

222
00:13:53,700 --> 00:13:58,500
頭文件的分享是通過一個構建階段進行的，

223
00:13:58,500 --> 00:14:02,740
在最近的 Xcode 中，這被稱為頭文件。

224
00:14:02,740 --> 00:14:06,380
或者在以前的版本中它被稱為複製標頭。

225
00:14:06,380 --> 00:14:09,940
如果我們展開它，我們看到三個子類別，

226
00:14:09,940 --> 00:14:13,260
這些就是每個標頭可以具有的三個級別的可見性

227
00:14:13,260 --> 00:14:17,620
公共、私有和專案。

228
00:14:17,620 --> 00:14:18,900
為了理解它們，

229
00:14:18,900 --> 00:14:22,940
我將為其中的每一個創建一個標頭文件

230
00:14:22,940 --> 00:14:24,300
並看看它們的表現。

231
00:14:25,340 --> 00:14:29,540
我們已經注意到專案選項卡包含一個文件，

232
00:14:29,540 --> 00:14:32,740
這就是我們剛剛添加的Logger標頭。

233
00:14:32,740 --> 00:14:34,660
默認情況下，添加任何標頭

234
00:14:34,660 --> 00:14:38,140
將設置專案級別的可見性，

235
00:14:38,140 --> 00:14:39,580
我們將看看這意味著什麼。

236
00:14:39,580 --> 00:14:44,580
現在，我將右鍵點擊，新建文件，

237
00:14:44,580 --> 00:14:46,980
使用標頭文件模板，

238
00:14:46,980 --> 00:14:50,460
我的第一個文件，我將其命名為公共。

239
00:14:51,340 --> 00:14:54,420
我將檢查EssentialFeed目標並點擊創建。

240
00:14:56,100 --> 00:14:59,740
如果我使用右邊的檢查器，

241
00:15:01,580 --> 00:15:04,060
在目標成員裡，我們看到了目標

242
00:15:04,060 --> 00:15:07,700
我們剛剛添加了文件的目標，也就是EssentialFeed，

243
00:15:07,700 --> 00:15:09,780
旁邊還有一個選擇器。

244
00:15:09,780 --> 00:15:12,700
這控制了我剛才提到的可見性。

245
00:15:13,940 --> 00:15:17,100
所以，由於我創建了我的文件，也就是public，

246
00:15:17,100 --> 00:15:20,420
我希望此文件為公開的，所以我會在此處選擇公開。

247
00:15:23,340 --> 00:15:26,020
關於這個文件模板的一個快註。

248
00:15:26,020 --> 00:15:30,380
我先前提到，對於C頭文件，

249
00:15:30,380 --> 00:15:32,980
include指令並不知道

250
00:15:32,980 --> 00:15:35,820
如何避免符號重複。

251
00:15:35,820 --> 00:15:40,100
所以在C, C++的常見做法是用這些指令的包裹器來進行防護，

252
00:15:40,100 --> 00:15:43,100
在包裹器內部包括所有東西。

253
00:15:43,100 --> 00:15:48,100
所以如果public_underscore_H未被定義，則定義它，

254
00:15:48,100 --> 00:15:49,420
然後結束。

255
00:15:49,420 --> 00:15:53,620
在下一個我們會嘗試導入此頭文件的文件中，

256
00:15:53,620 --> 00:15:57,860
我們實際上會發現 public underscore H 已經被定義

257
00:15:57,860 --> 00:15:59,700
並跳過。

258
00:15:59,700 --> 00:16:03,580
這就是它避免重複符號的方式。

259
00:16:03,580 --> 00:16:07,140
所以回到我們的流程，我們加入了一個新的標頭檔案

260
00:16:07,140 --> 00:16:11,580
被稱為 public.H，並將其可見性設為公開。

261
00:16:11,580 --> 00:16:13,740
現在，如果我們回到建構階段，

262
00:16:15,420 --> 00:16:18,620
並讓這個部分看起來更大。

263
00:16:18,620 --> 00:16:22,820
我在公開標頭下看到我的 public.H 文件。

264
00:16:24,220 --> 00:16:28,820
我將建立，所有東西都建立得很好，

265
00:16:28,820 --> 00:16:33,820
我將在衍生數據資料夾上使用找尋器

266
00:16:35,540 --> 00:16:39,740
來檢查我的 EssentialFeed 框架的 Bundle。

267
00:16:39,740 --> 00:16:43,940
我看到有一個新資料夾叫做標頭。

268
00:16:44,820 --> 00:16:47,420
如果我現在查看這個標頭，

269
00:16:47,420 --> 00:16:51,340
我只會看到我剛剛創建的 public.H 文件。

270
00:16:51,340 --> 00:16:53,220
請忽略 EssentialFeed Swift，

271
00:16:53,220 --> 00:16:56,940
我們將在幾分鐘後討論它。

272
00:16:56,940 --> 00:16:57,900
幾分鐘之後。

273
00:17:00,100 --> 00:17:05,100
因此，我的 public header.H  被添加到 headers 文件夾。

274
00:17:09,660 --> 00:17:12,780
所有導入 EssentialFeed 的客戶

275
00:17:12,780 --> 00:17:14,700
都將可以導入此 header

276
00:17:14,700 --> 00:17:17,460
並使用其中的定義。

277
00:17:17,460 --> 00:17:18,380
所以一切都好。

278
00:17:20,700 --> 00:17:25,700
讓我們使用另一個 File，header File，

279
00:17:25,700 --> 00:17:29,140
我們將其命名為 project 的 header File

280
00:17:29,140 --> 00:17:31,260
我也將其添加到我們的 EssentialFeed 

281
00:17:32,300 --> 00:17:35,860
並檢查其可見性設置為 project。

282
00:17:35,860 --> 00:17:40,860
我也可以看到它出現在 project 組下，

283
00:17:43,020 --> 00:17:44,740
現在包含兩個文件。

284
00:17:47,860 --> 00:17:48,700
如果我建構

285
00:17:48,700 --> 00:17:53,700
並回到我的 Bundle

286
00:17:55,500 --> 00:17:57,620
的 EssentialFeed 框架，

287
00:17:57,620 --> 00:18:02,020
我將無法在任何地方找到此 header。

288
00:18:05,540 --> 00:18:08,140
那是因為 project header 不包含在

289
00:18:08,140 --> 00:18:09,660
module Bundle 中。

290
00:18:09,660 --> 00:18:13,500
此介面僅用於當前專案中的實作File

291
00:18:13,500 --> 00:18:15,180
使用。

292
00:18:15,180 --> 00:18:18,060
因此，此標頭內的符號是 NotVisible

293
00:18:18,060 --> 00:18:19,980
客戶端根本看不到，只有你能看到。

294
00:18:25,380 --> 00:18:27,180
第三層級

295
00:18:29,580 --> 00:18:32,020
是私有的。

296
00:18:32,020 --> 00:18:33,140
讓我們來看看這是如何運作的。

297
00:18:33,140 --> 00:18:35,500
我將創建一個名為 private 的標頭File。

298
00:18:35,500 --> 00:18:38,180
我也會將它加到 EssentialFeed

299
00:18:38,180 --> 00:18:40,260
這次我將選擇

300
00:18:40,260 --> 00:18:42,540
私有的目標會員等級。

301
00:18:42,540 --> 00:18:47,540
我會在私有標頭下看到新的標頭。

302
00:18:52,780 --> 00:18:53,620
正在建立，

303
00:18:55,340 --> 00:18:57,380
我們看到新文件夾出現，

304
00:18:57,380 --> 00:18:59,140
名為私有標頭。

305
00:19:01,500 --> 00:19:04,940
私有標頭實際上會被複製到你的Bundle，

306
00:19:04,940 --> 00:19:06,820
但並非去到標頭文件夾，

307
00:19:06,820 --> 00:19:08,980
而是會進到私有標頭文件夾。

308
00:19:08,980 --> 00:19:12,620
私有標頭包含在產品內，

309
00:19:12,620 --> 00:19:14,420
但被標記為私有的。

310
00:19:14,420 --> 00:19:17,660
因此這些符號對所有的客戶都是可見的，

311
00:19:17,660 --> 00:19:19,020
但客戶應該理解

312
00:19:19,020 --> 00:19:20,620
你們不應該使用它們。

313
00:19:22,380 --> 00:19:25,700
你應該始終避免導入私有頭文件

314
00:19:25,700 --> 00:19:27,820
因為這可能導致該模塊將來版本的破壞性變更

315
00:19:27,820 --> 00:19:30,020
在這個模塊的未來版本中。

316
00:19:30,020 --> 00:19:31,460
所以你並不想要與

317
00:19:31,460 --> 00:19:39,700
這些實現細節產生緊密耦合。

318
00:19:39,700 --> 00:19:42,620
現在我們已經看到所有這些潛在的層次，

319
00:19:43,620 --> 00:19:46,340
你正確設置可見性等級對於表達你的意圖

320
00:19:46,340 --> 00:19:49,260
至於你的目標中的每一個頭文件非常重要。

321
00:19:49,260 --> 00:19:51,380
對於所有的Objective-C版本，

322
00:19:51,380 --> 00:19:53,820
共享頭文件就足夠了

323
00:19:53,820 --> 00:19:56,740
用於分發庫或者框架。

324
00:19:56,740 --> 00:20:00,100
客戶將從模塊中導入他們想要的確定的頭文件

325
00:20:00,100 --> 00:20:03,340
並且完成所有操作。

326
00:20:03,340 --> 00:20:06,380
但蘋果創建了一種改進的選項，

327
00:20:07,260 --> 00:20:11,060
目的是將您的Objective-C代碼暴露給其他模塊，

328
00:20:12,900 --> 00:20:16,340
無論是Objective-C還是Swift。

330
00:20:19,100 --> 00:20:22,460
你可以使用 umbrella header 和 module Map。

331
00:20:22,460 --> 00:20:24,700
你可能之前已經聽過這個，

332
00:20:24,700 --> 00:20:30,300
讓我們來解釋他們各自是什麼以及如何運作。

333
00:20:32,420 --> 00:20:34,940
umbrella header 就是主要的 header

334
00:20:34,940 --> 00:20:38,220
給 framework 的 File 使用。

335
00:20:38,220 --> 00:20:41,060
這沒什麼特殊的，只是一個簡單的 header

336
00:20:41,060 --> 00:20:44,500
與 framework 的名稱相同。

337
00:20:44,500 --> 00:20:47,420
所以在我們的範例中，就會是 EssentialFeed.h。

338
00:20:48,860 --> 00:20:53,260
讓我們建立此 header 使其更清晰。

339
00:20:53,260 --> 00:20:58,260
因此，我會建立一個新的 header，我會將它命名為 EssentialFeed。

340
00:20:58,380 --> 00:21:03,380
我將它加入我的目標並點擊建立。

341
00:21:03,620 --> 00:21:08,020
我將刪除這些宏，因為我們不需要它們。

342
00:21:08,020 --> 00:21:19,020
我將導入 EssentialFeed 的公開 header

343
00:21:23,460 --> 00:21:24,620
我們剛剛建立的。

344
00:21:28,300 --> 00:21:33,300
而我也將導入 myLogger.h 並嘗試構建。

345
00:21:33,300 --> 00:21:37,780
哎喲，我犯了一個錯誤，我們看看是為什麼。

346
00:21:40,140 --> 00:21:43,300
我們得到這個「umbrella header EssentialFeed not found」的錯誤。

347
00:21:44,500 --> 00:21:46,740
這是一個相當常見的建構錯誤。

348
00:21:46,740 --> 00:21:49,500
這種情況也發生得頻繁。

349
00:21:49,500 --> 00:21:53,900
我忘了將我的 umbrella header 設為 public。

350
00:21:53,900 --> 00:21:55,500
這一點非常重要。

351
00:21:55,500 --> 00:21:58,700
當試圖編譯這個 umbrella header 時，

352
00:21:58,700 --> 00:22:02,100
Clang 嘗試導入所有這些 header 

353
00:22:02,100 --> 00:22:03,700
而且它們都必須是 public，

354
00:22:04,540 --> 00:22:08,780
但我們的 Logger.h File 沒有設為 public。

355
00:22:11,660 --> 00:22:13,420
所以如果我們將它設為 public，

356
00:22:15,100 --> 00:22:18,180
那麼現在一切應該都能正常運作，沒問題。

357
00:22:20,660 --> 00:22:24,460
所以總結一下，我創建了一個 umbrella header

358
00:22:24,460 --> 00:22:29,180
它的名稱完全與它所屬的 target 相同，

359
00:22:29,180 --> 00:22:31,580
那就是關聯框架 EssentialFeed。

360
00:22:31,580 --> 00:22:36,060
我必須將它設為公開，和裡面所有的導入頭文件

361
00:22:36,060 --> 00:22:40,820
都需要使用公開的頭文件。

362
00:22:42,340 --> 00:22:45,340
這個傘式標頭被用來引入

363
00:22:45,340 --> 00:22:47,500
你想要公開的所有公開標頭。

364
00:22:48,540 --> 00:22:51,500
一個常見的例子是 Foundation.h。

365
00:22:54,260 --> 00:22:58,540
如你所見，它實際上就是一個傘式

366
00:22:58,540 --> 00:23:01,780
就像名字所說的對其他標頭文件來說。

367
00:23:03,060 --> 00:23:08,060
但是這樣做是讓我們可以使用這類型的引入

368
00:23:10,900 --> 00:23:14,540
我們說 import Foundation, Foundation.h

369
00:23:14,540 --> 00:23:17,860
取代必須輸入每種類型的引入

370
00:23:17,860 --> 00:23:22,860
像是 NSString.h, NSArray.h 等等。

371
00:23:26,860 --> 00:23:28,100
我們不必這樣做。

372
00:23:28,100 --> 00:23:32,540
我們只需要使用傘式並取得所有定義。

373
00:23:35,140 --> 00:23:40,140
現在，這就是傘式標頭的樣子。

374
00:23:41,220 --> 00:23:43,620
我們也提到了模塊 Map。

375
00:23:43,620 --> 00:23:45,260
讓我們看看模塊 Map 是什麼。

376
00:23:46,380 --> 00:23:48,460
但模塊 Map 只是一個文字檔案。

377
00:23:49,500 --> 00:23:51,740
默認情況下，這是由Xcode生成的

378
00:23:51,740 --> 00:23:54,500
從描述你的模組的信息

379
00:23:54,500 --> 00:23:56,220
像這個傘型標頭。

380
00:23:56,220 --> 00:24:00,620
如果啟用了定義模組選項，

381
00:24:00,620 --> 00:24:01,580
我們剛剛展示的那一個。

382
00:24:03,900 --> 00:24:06,260
它基本上描述了映射

383
00:24:06,260 --> 00:24:08,100
模組和標頭之間的關係。

384
00:24:09,460 --> 00:24:14,460
作為一個例子，我想看看我們的必要飼料，

385
00:24:14,500 --> 00:24:15,940
生成的模組地圖。

386
00:24:17,220 --> 00:24:19,980
所以為了做到這一點，我將返回到更細節的部分 

387
00:24:21,380 --> 00:24:26,060
並在EssentialFeed框架包裡面，

388
00:24:26,060 --> 00:24:28,380
有一個模組文件夾

389
00:24:28,380 --> 00:24:30,940
裡面，有一個模組模組地圖。

390
00:24:30,940 --> 00:24:33,300
這就是我想要打開的文件。

391
00:24:35,140 --> 00:24:36,740
讓我們來看看。

392
00:24:36,740 --> 00:24:39,900
首先，它定義了框架裡面，

393
00:24:39,900 --> 00:24:42,140
也就是EssentialFeed的范疇。

394
00:24:42,140 --> 00:24:45,220
然後它提到這個框架的傘型標頭

395
00:24:45,220 --> 00:24:48,860
就是EssentialFeed.h。

396
00:24:48,860 --> 00:24:51,780
之後，有一些匯出

397
00:24:51,780 --> 00:24:53,060
和模組定義，

398
00:24:53,060 --> 00:24:56,900
它們基本上說明了所有的標頭

399
00:24:58,300 --> 00:24:59,860
被導入到傘狀頭文件中

400
00:24:59,860 --> 00:25:04,340
將會在一個不同的子模組中結束。

401
00:25:06,340 --> 00:25:09,580
所以我們可以有這樣的細節度，我們將在片刻看到。

402
00:25:13,020 --> 00:25:15,260
另外，還有一個單獨的模組

403
00:25:15,260 --> 00:25:18,140
名為EssentialFeed.Swift，

404
00:25:18,140 --> 00:25:21,220
其中包含我們尚未介紹的文件。

405
00:25:21,220 --> 00:25:22,900
所以現在先忽略它。

406
00:25:30,580 --> 00:25:33,780
共享模組地圖允許你導入模組的特定部分。

407
00:25:33,780 --> 00:25:36,020
導入模組的特定部分。

408
00:25:37,700 --> 00:25:42,700
例如，我們看到的 EssentialFeed.Swift，

409
00:25:42,940 --> 00:25:45,580
或者是系統框架的情況，

410
00:25:45,580 --> 00:25:50,580
我們可以導入它們的子組件。

411
00:25:53,420 --> 00:25:58,420
例如，如果我們可以這樣寫 import Foundation，

412
00:25:58,820 --> 00:26:03,820
我們可以說 Foundation.NSString 或 Foundation.NSArray。

413
00:26:09,060 --> 00:26:12,900
自動完成並不起作用，但是你看到這可以運作。

414
00:26:12,900 --> 00:26:17,900
實際上，讓我們重新開啟這個專案。

415
00:26:20,580 --> 00:26:25,460
有時 Xcode 只是需要重新開機。

416
00:26:31,260 --> 00:26:33,700
對，這次它能夠運行，自動完成。

417
00:26:34,940 --> 00:26:35,780
很好。

418
00:26:38,780 --> 00:26:40,060
所以我們談到的是頭文件

419
00:26:40,060 --> 00:26:45,060
以及系統如何查找頭文件，模組地圖。

420
00:26:46,860 --> 00:26:49,500
我想介紹另外一個概念，

421
00:26:50,420 --> 00:26:52,300
那就是前向聲明。

422
00:26:55,380 --> 00:26:57,500
你可以讓你的專案進行編譯

423
00:26:57,500 --> 00:27:00,380
只需要在各處都使用import（導入）

424
00:27:00,380 --> 00:27:02,780
但請記住，他們並不高效。

425
00:27:05,260 --> 00:27:08,300
如果你為了引用

426
00:27:08,300 --> 00:27:11,220
在那個檔案中的一兩個實體而導入大的頭文件，

427
00:27:11,220 --> 00:27:16,220
或者你沒有仔細並定期清理導入，

428
00:27:16,540 --> 00:27:21,540
這些就會累積起來，你就有一個巨大的檔案需要編譯

429
00:27:24,700 --> 00:27:27,460
即使其中有些導入並不需要。

430
00:27:28,700 --> 00:27:32,380
更不用說，你可能會有循環參考


431
00:27:32,380 --> 00:27:36,500
在你需要引用頭檔案B的頭檔案A的情況下

432
00:27:36,500 --> 00:27:38,980
和引用頭檔案A的頭檔案B。

433
00:27:38,980 --> 00:27:41,020
而這是編譯器無法

434
00:27:41,020 --> 00:27:42,700
自行解決的情況。

435
00:27:44,380 --> 00:27:47,380
所以Clang編譯器提供了更有效的解決方案

436
00:27:47,380 --> 00:27:50,620
來參照來自其他檔案或模塊的實體，

437
00:27:50,620 --> 00:27:53,420
這就是前置聲明。

438
00:27:54,420 --> 00:27:57,100
這些基本上是對編譯器的承諾

439
00:27:57,100 --> 00:27:59,540
一個叢集協議或其他實體

440
00:27:59,540 --> 00:28:02,260
將在另一個文件中被聲明。

441
00:28:04,180 --> 00:28:06,060
而在你只需要參照

442
00:28:06,060 --> 00:28:11,060
一種實體並不在乎所有的細節的情況下，

443
00:28:11,300 --> 00:28:15,100
就像例子中，你需要傳遞一個Logger實例，

444
00:28:15,100 --> 00:28:16,820
但你並不在意那个實例的屬性

445
00:28:16,820 --> 00:28:18,980
或者該實例上的方法，

446
00:28:18,980 --> 00:28:21,740
你可以使用前置聲明代替引入。

447
00:28:25,180 --> 00:28:26,500
要編譯每個檔案，

448
00:28:26,500 --> 00:28:30,980
編譯器不需要解析這些前向聲明。

449
00:28:31,820 --> 00:28:35,100
只需知道它們將在別處被聲明就足夠了。

450
00:28:35,100 --> 00:28:37,820
尋找這些文件並填充正確的聲明

451
00:28:37,820 --> 00:28:39,180
將由鏈接器完成

452
00:28:39,180 --> 00:28:40,940
在編譯過程的最後階段。

453
00:28:40,940 --> 00:28:43,340
再次，我們在詳細描述的事物

454
00:28:43,340 --> 00:28:45,420
在Xcode建構過程的講座中。

455
00:28:45,420 --> 00:28:47,900
所以如果你覺得不合理，你應該檢查一下。

456
00:28:50,860 --> 00:28:52,180
現在讓我們建立一個範例

457
00:28:52,180 --> 00:28:56,380
通過創建一個新的Objective-C類。

458
00:28:57,540 --> 00:28:59,820
這次我將稱之為 log manager。

459
00:29:00,820 --> 00:29:02,380
它不會是一個Singleton，

460
00:29:02,380 --> 00:29:07,380
但再次，讓我們刪除NSAssume指令

461
00:29:15,660 --> 00:29:18,100
因為我們還沒有說它們是什麼。

462
00:29:21,660 --> 00:29:26,660
對於這個類，我想添加一個簡單的方法

463
00:29:26,660 --> 00:29:31,660
該方法允許日誌碼，允許傳遞訊息

464
00:29:32,940 --> 00:29:36,780
並使用 Logger，它應該知道如何紀錄日誌。

465
00:29:38,620 --> 00:29:42,500
現在我立即看到編譯器並不滿意

466
00:29:42,500 --> 00:29:45,140
因為沒有 Logger 類型。

467
00:29:47,460 --> 00:29:52,460
當然我可以通過使用 import Logger.h 來解決這個問題

468
00:29:52,460 --> 00:29:56,380
import Logger.h一切都將恢復正常。

469
00:29:57,620 --> 00:30:02,620
但是我們說過，這個導入實際上將被替換

470
00:30:04,860 --> 00:30:08,900
由預編譯器用我的 Logger.h 的所有內容

471
00:30:09,900 --> 00:30:12,180
而我可能不需要這些細節

472
00:30:12,180 --> 00:30:15,420
因為我只是想傳遞一個 Logger 實例。

473
00:30:15,420 --> 00:30:18,980
所以我可以做的是使用向前聲明

474
00:30:18,980 --> 00:30:23,980
在 class Logger，編譯器仍然滿意。

475
00:30:26,940 --> 00:30:29,780
我知道你們中的一些人在想，

476
00:30:29,780 --> 00:30:32,740
是的，但你沒有添加函數的主體。

477
00:30:32,740 --> 00:30:33,580
讓我們做這個。

478
00:30:37,260 --> 00:30:42,260
所以我將添加主體並呼叫方法 log。

479
00:30:43,740 --> 00:30:46,500
我們之前加了一個Logger。

480
00:30:46,500 --> 00:30:51,180
如果我試圖構建，我會獲得這個錯誤

481
00:30:51,180 --> 00:30:54,500
錯誤信息是Logger是一個前向聲明。

482
00:30:55,900 --> 00:31:00,700
但在實現File.m的案例中

483
00:31:00,700 --> 00:31:04,700
編譯器確實需要知道如何解析這個符號。

484
00:31:04,700 --> 00:31:09,700
所以在.m File的這種情況下，我需要導入標頭文件。

485
00:31:09,700 --> 00:31:14,700
現在它可以運行了。

486
00:31:18,380 --> 00:31:23,380
所以我們已經展示了如何使用@class前向聲明。

487
00:31:23,820 --> 00:31:27,180
還有其他類型的前向聲明

488
00:31:27,180 --> 00:31:30,980
我快速展示一下。

489
00:31:32,300 --> 00:31:34,820
所以我要回到myLogger.h

490
00:31:34,820 --> 00:31:39,820
因為這是我想要堆放我的實體的地方。

491
00:31:40,540 --> 00:31:45,540
我將添加一個空的協議，稱為Logger Protocol。

492
00:31:47,580 --> 00:31:52,580
如果你記得，我們添加了一個enum定義

493
00:31:53,140 --> 00:31:58,140
在Logger.m內，我想把這個移至標頭文件。

494
00:31:58,140 --> 00:32:03,140
所以將其揭露給其他文件，並返回到我的myLogger管理器。

495
00:32:11,220 --> 00:32:14,580
在Logger Protocol的聲明之前

496
00:32:14,580 --> 00:32:18,060
將會是添加Protocol Logger Protocol。

497
00:32:19,740 --> 00:32:23,860
這將允許我使用，

498
00:32:23,860 --> 00:32:28,860
像這樣，它正在引用Logger Protocol。

499
00:32:34,540 --> 00:32:39,540
我也可以為nse enum做一個前向聲明。

500
00:32:39,540 --> 00:32:44,540
為nse enum進行前向聲明，我可以通過。

501
00:33:02,820 --> 00:33:06,260
這就是你如何使用前向聲明。

502
00:33:06,260 --> 00:33:09,540
但有些情況

503
00:33:09,540 --> 00:33:11,820
前向聲明不起作用。

504
00:33:13,140 --> 00:33:18,140
其中一些是使用NSOptions或者在其他案例中，

505
00:33:19,020 --> 00:33:21,580
但我想展示主要情況

506
00:33:21,580 --> 00:33:23,900
我們需要導入的地方。

507
00:33:23,900 --> 00:33:26,340
這是我們試圖進行子類化時。

508
00:33:26,340 --> 00:33:29,140
所以我將創建一個新的CocoaTouch類

509
00:33:29,140 --> 00:33:30,900
我將其命名為File Logger。

510
00:33:30,900 --> 00:33:35,900
我希望我的File Logger能擴展或是繼承Logger。

511
00:33:45,220 --> 00:33:49,540
如果我嘗試像之前一樣在這裡使用我的前向聲明，

512
00:33:50,420 --> 00:33:55,420
我會得到一個錯誤，因為編譯器並不高興

513
00:33:55,420 --> 00:34:00,420
我們只是前向聲明了Logger類。

514
00:34:01,540 --> 00:34:05,460
既然它是繼承，它真的需要知道

515
00:34:05,460 --> 00:34:07,340
所有的簽名，所有的方法

516
00:34:07,340 --> 00:34:09,540
在這個類上都有哪些可用。

517
00:34:09,540 --> 00:34:11,140
所以在這個特殊情況下，

518
00:34:11,140 --> 00:34:15,860
我們必須要匯入Logger.h

519
00:34:17,540 --> 00:34:19,940
在File Logger的標頭檔案中

520
00:34:19,940 --> 00:34:24,940
現在編譯器感到滿意。

521
00:34:29,780 --> 00:34:34,500
所以我們已經涵蓋了Objective-C聲明

522
00:34:34,500 --> 00:34:37,060
從其他Objective-C檔案被找到的方式。

523
00:34:37,060 --> 00:34:40,900
我們已經看到這有可能

524
00:34:40,900 --> 00:34:44,980
透過標頭檔案或是透過前向聲明來完成。

525
00:34:44,980 --> 00:34:49,980
現在，讓我們來看看Swift是如何做到這點的。

526
00:34:57,380 --> 00:35:00,100
所以我將看一下SceneDelegate類別

527
00:35:00,100 --> 00:35:02,060
在EssentialApp模組內部。

528
00:35:04,380 --> 00:35:08,940
我們來看看這個新的Store初始化調用。

529
00:35:11,580 --> 00:35:13,900
當編譯SceneDelegate.Swift，

530
00:35:13,900 --> 00:35:16,020
Swift編譯器將查找新的Store的類型，

531
00:35:16,020 --> 00:35:19,980
初始化它，以便它可以檢查調用。

532
00:35:22,620 --> 00:35:25,580
例如，當編譯器嘗試解析靜態函數時，

533
00:35:25,580 --> 00:35:29,860
也會進行相同的查找

534
00:35:29,860 --> 00:35:33,380
feedComposedWith和以下這些參數

535
00:35:33,380 --> 00:35:34,860
在FeedUIComposer上。

536
00:35:37,900 --> 00:35:42,580
但在它可以做到這一點之前，它需要解析這些文件。

537
00:35:42,580 --> 00:35:47,580
所以我們要看Store.Swift檔案

538
00:35:48,660 --> 00:35:53,660
和FeedUIComposer.Swift檔案

539
00:35:56,300 --> 00:35:59,140
並驗證它們以確保聲明

540
00:35:59,140 --> 00:36:03,580
我們在SceneDelegate Swift中使用的兩個函數

541
00:36:04,420 --> 00:36:05,420
結構良好。

542
00:36:06,500 --> 00:36:08,860
Swift 編譯器足夠智能，只檢查

543
00:36:08,860 --> 00:36:12,260
涉及功能的聲明。

544
00:36:12,260 --> 00:36:15,860
所以它仍需要做一些工作來處理

545
00:36:15,860 --> 00:36:17,940
File的介面部分。

546
00:36:19,060 --> 00:36:21,620
這意味著與Clang不同，

547
00:36:21,620 --> 00:36:25,100
在編譯一個 Swift File 時，Swift 編譯器會解析

548
00:36:25,100 --> 00:36:27,860
該目標中的所有其他 Swift 文件

549
00:36:27,860 --> 00:36:29,780
來檢查與介面使用相關的部分

550
00:36:29,780 --> 00:36:31,580
。

551
00:36:34,660 --> 00:36:39,660
所以回顧一下，Swift 編譯器會解析所有的 Swift 文件

552
00:36:39,660 --> 00:36:44,460
在目標中找到聲明

553
00:36:44,460 --> 00:36:47,380
來自同一模組的 Swift 文件之間。

554
00:36:51,220 --> 00:36:54,980
我提到的兩個文件都在同一模塊中

555
00:36:54,980 --> 00:36:58,820
因為處理我們引用 Swift File

556
00:36:58,820 --> 00:37:00,460
來自另一個模塊的情況有些不同。

557
00:37:00,460 --> 00:37:02,260
讓我們看看它是如何運作的。

558
00:37:04,300 --> 00:37:06,940
如果我們回到我們的SceneDelegate，


559
00:37:06,940 --> 00:37:11,940
例如，我們看到它使用了 URLSession，

560
00:37:12,860 --> 00:37:16,340
HTTPClient 類型，這是在

561
00:37:16,340 --> 00:37:19,300
EssentialFeed 框架中定義的。

562
00:37:19,300 --> 00:37:20,500
所以在另一個模塊裡。

563
00:37:25,540 --> 00:37:27,860
我們提到了模塊，在 Swift 中，模塊

564
00:37:27,860 --> 00:37:31,500
是一種可分發的宣告單位。

565
00:37:31,500 --> 00:37:33,380
而要能使用這些宣告，

566
00:37:33,380 --> 00:37:37,300
你必須導入模塊。

567
00:37:37,300 --> 00:37:40,700
在此例中，導入 EssentialFeed。

568
00:37:44,620 --> 00:37:48,260
在 Xcode 中，任何的 Swift 目標都會產生一個單獨模塊，

569
00:37:48,260 --> 00:37:50,540
包括你的應用目標。

570
00:37:50,540 --> 00:37:55,540
這就是為什麼在你的測試 Bundle，單元測試 Bundle，

571
00:37:58,900 --> 00:38:01,740
你必須導入應用模塊

572
00:38:01,740 --> 00:38:04,300
以便你可以存取它的類型。

573
00:38:08,100 --> 00:38:08,940
像這樣。

574
00:38:11,860 --> 00:38:13,340
所以當導入模塊時，

575
00:38:13,340 --> 00:38:17,060
編譯器會反序列化一個特殊的 Swift 模塊檔案

576
00:38:17,060 --> 00:38:18,980
以檢查你使用時的類型。

577
00:38:21,060 --> 00:38:23,100
我可以給你們示範看看這個樣子。

578
00:38:26,460 --> 00:38:30,180
所以我們注意到EssentialApp Bundle旁邊，

579
00:38:30,180 --> 00:38:33,500
有一個EssentialApp.swiftmodule文件夾。

580
00:38:35,580 --> 00:38:39,820
在這個文件夾裡，有多種擴展名的文件，

581
00:38:39,820 --> 00:38:42,540
但我們關心的是 Swift module 文件。

582
00:38:45,300 --> 00:38:50,260
這些都是模塊聲明的序列化二進制表示形式

583
00:38:50,260 --> 00:38:52,060
的模塊聲明。

584
00:38:53,340 --> 00:38:57,100
這包括公開、內部和私有聲明

585
00:38:57,100 --> 00:39:00,380
因為內部和私有的部分需要做Debugging。

586
00:39:05,460 --> 00:39:09,500
回到Xcode，如果你記得setUp，

587
00:39:09,500 --> 00:39:12,460
你就知道EssentialApp目標

588
00:39:12,460 --> 00:39:14,700
有與庫的二進制文件相連，

589
00:39:14,700 --> 00:39:17,740
隱式依賴於EssentialFeed框架。

590
00:39:19,140 --> 00:39:21,340
因此，Xcode知道要在建立

591
00:39:21,340 --> 00:39:24,700
EssentialApp目標之前先建立EssentialFeed目標。

592
00:39:24,700 --> 00:39:26,780
現在，Xcode使用了一些優化

593
00:39:26,780 --> 00:39:28,220
使其可以平行建構。

594
00:39:28,220 --> 00:39:31,580
所以EssentialApp只會等待生成


595
00:39:31,580 --> 00:39:34,180
EssentialFeed模塊的介面，

596
00:39:34,180 --> 00:39:36,620
而不是等待整個構建完成。

597
00:39:36,620 --> 00:39:39,340
所以，這為你提供了一些免費的并行化。

598
00:39:44,340 --> 00:39:45,540
回到SceneDelegate。

599
00:39:49,380 --> 00:39:51,740
那麼，解決這個初始化器，

600
00:39:51,740 --> 00:39:56,740
URL、session、HTTPClient，會話的初始化器，

601
00:39:56,740 --> 00:39:58,740
Swift編譯器使用介面

602
00:39:58,740 --> 00:40:00,740
從我們剛剛展示的Swift模塊中

603
00:40:01,620 --> 00:40:03,140
解決這個聲明。

604
00:40:08,940 --> 00:40:12,140
所以，總結一下，尋找Swift宣告

605
00:40:12,860 --> 00:40:16,140
來自不同模塊的其他Swift文件，

606
00:40:16,140 --> 00:40:19,860
Swift編譯器依賴於Swift模塊。

607
00:40:19,860 --> 00:40:21,540
Swift模塊。

608
00:40:28,420 --> 00:40:31,340
現在讓我們開始交叉引用。

609
00:40:31,340 --> 00:40:35,820
首先，找到在Swift中使用的Objective-C聲明。

610
00:40:36,940 --> 00:40:39,900
這是至關重要的，因為系統框架大部分

611
00:40:39,900 --> 00:40:41,580
都是用Objective-C編寫的，

612
00:40:42,620 --> 00:40:46,980
包括我們在幾乎所有文件中導入的，

613
00:40:46,980 --> 00:40:50,340
如Foundation或UIKit。


614
00:40:53,460 --> 00:40:57,220
Swift 編譯器嵌入了大部分的 Clang

615
00:40:57,220 --> 00:40:59,660
並將其作為庫使用

616
00:40:59,660 --> 00:41:02,300
直接導入 Objective-C 框架。

617
00:41:03,260 --> 00:41:06,740
那麼 Objective-C 宣告從何而來？

618
00:41:06,740 --> 00:41:08,740
導入器會查看 headers

619
00:41:08,740 --> 00:41:10,820
根據目標的類型。

620
00:41:10,820 --> 00:41:12,380
我們這裡有一些情況。

621
00:41:12,380 --> 00:41:15,700
從 Swift 導入一個 Objective-C 框架時，

622
00:41:17,860 --> 00:41:20,540
導入器在 headers 中找到聲明

623
00:41:20,540 --> 00:41:23,220
以顯示框架的 Clang module Map。

624
00:41:26,420 --> 00:41:31,420
我們之前探討過 Foundation umbrella header，

625
00:41:32,300 --> 00:41:33,900
來看看 Foundation 框架的 module Map 

626
00:41:33,900 --> 00:41:36,100
是什麼樣子。

627
00:41:37,300 --> 00:41:40,300
我將使用 finder 

628
00:41:40,300 --> 00:41:45,300
去磁盤的某個路徑

629
00:41:47,300 --> 00:41:49,500
找到 Foundation 框架的位置。

630
00:41:49,500 --> 00:41:53,540
旁邊的 headers 文件夾旁邊是 module 文件夾。

631
00:41:55,780 --> 00:41:58,220
我們可以探索 module Map

632
00:41:58,220 --> 00:41:59,980
針對Foundation framework。

633
00:42:02,060 --> 00:42:04,460
它與我們剛才看到的有點不同

634
00:42:04,460 --> 00:42:06,580
針對中央 Feed。

635
00:42:06,580 --> 00:42:08,660
它仍然定義一個框架模塊，

636
00:42:08,660 --> 00:42:11,540
但這次它標記為extern C

637
00:42:11,540 --> 00:42:14,420
並作為一個系統框架。

638
00:42:14,420 --> 00:42:16,420
再次，有一個全局頭文件，

639
00:42:16,420 --> 00:42:18,420
就是Foundation頭文件，

640
00:42:18,420 --> 00:42:20,460
相同的輸出和模塊

641
00:42:20,460 --> 00:42:24,620
使系統定義一個子模塊

642
00:42:24,620 --> 00:42:27,820
從每個在全局頭文件中導入的頭文件。

643
00:42:27,820 --> 00:42:43,820
還有一個有趣的例子是它們排除一個頭文件。

644
00:42:43,820 --> 00:42:50,820
所以通過擁有一個全局頭文件和一個模塊地圖，

645
00:42:50,820 --> 00:42:55,420
在Swift中我們可以有具體的導入

646
00:42:55,420 --> 00:43:00,420
像Foundation.nsring 或 Foundation.nsray，

647
00:43:04,340 --> 00:43:06,140
我們在Objective-C中顯示的那個。

648
00:43:09,700 --> 00:43:13,300
所以這是從Swift導入Objective-C框架。

649
00:43:14,540 --> 00:43:18,660
現在讓我們看一個案例，框架是怎麼樣的。

650
00:43:18,660 --> 00:43:21,300
混合使用 Swift 和 Objective-C。

651
00:43:21,300 --> 00:43:24,260
這也剛好是我們的 EssentialFeed 架構的情況。

652
00:43:24,260 --> 00:43:25,940
於是，對於混合使用 Swift 和 Objective-C 的架構，

653
00:43:27,900 --> 00:43:30,780
導入器會在總括標頭中找到聲明。

654
00:43:30,780 --> 00:43:33,860
如你所記得，這是定義公共介面的標頭，

655
00:43:35,060 --> 00:43:36,580
所以透過這種方式，EssentialFeed 架構中的 Swift 程式碼

656
00:43:36,580 --> 00:43:38,580
可以呼叫同一架構中的公共 Objective-C 程式碼。

657
00:43:39,740 --> 00:43:41,260
記得我們剛為 EssentialFeed 架構創建了總括標頭，

658
00:43:41,260 --> 00:43:43,620
既然它導入了 Logger.h 檔案，

659
00:43:43,620 --> 00:43:46,860
那麼 Logger 類就可以從 Swift 存取。

660
00:43:47,900 --> 00:43:52,420
所以作為一個練習，

661
00:43:52,420 --> 00:43:54,420
如果我們走到 LocalFeedImageDataLoader，

662
00:43:55,780 --> 00:43:58,820
並且也許我們想要在執行這個 do catch 之前記錄一下，

663
00:43:58,820 --> 00:44:02,660
我們就能說讓 Logger 等於 Logger。

668
00:44:20,660 --> 00:44:25,660
我們可以用Message Error呼叫日誌。

669
00:44:28,540 --> 00:44:31,820
如果我們建立的一切都沒問題。

670
00:44:34,580 --> 00:44:39,580
再次地，因為EssentialFeed的傘形標頭

671
00:44:40,180 --> 00:44:44,620
導入了定義Logger類的標頭文件。

672
00:44:47,020 --> 00:44:50,580
這裡重要的是傘形標頭的概念

673
00:44:50,580 --> 00:44:52,980
只存在於框架目標中。

674
00:44:52,980 --> 00:44:57,300
它並不存在於應用程序目標或單元測試目標中。

675
00:44:59,580 --> 00:45:01,940
他們有一種相等的東西，

676
00:45:01,940 --> 00:45:03,940
稱為橋接標頭。

677
00:45:06,380 --> 00:45:09,140
因此，在應用程序或單元測試目標中，

678
00:45:09,140 --> 00:45:12,900
您可以將導入項添加到目標的橋接標頭

679
00:45:12,900 --> 00:45:15,940
以允許他們的聲明從Swift被調用。

680
00:45:17,500 --> 00:45:20,100
這個我剛剛提及的橋接標頭

681
00:45:20,100 --> 00:45:23,860
只是一個包含所有聲明的標頭文件

682
00:45:23,860 --> 00:45:27,260
或是我們暴露給Swift的實體的導入。

683
00:45:28,940 --> 00:45:29,940
如我所說，

684
00:45:29,940 --> 00:45:32,980
框架目標並沒有橋接頭。

685
00:45:32,980 --> 00:45:36,460
所以只能二者擇一，不能混合使用。

686
00:45:39,140 --> 00:45:43,300
要看到實例，讓我們來創建一個，

687
00:45:43,300 --> 00:45:48,060
但我們將通過Xcode的自動機制來實現。

688
00:45:48,060 --> 00:45:50,940
我將添加一個Objective-C類

689
00:45:50,940 --> 00:45:54,140
到我的EssentialApp目標中這一次。

690
00:45:54,140 --> 00:45:58,060
再次，使用CocoaTouch類模板。

691
00:45:58,060 --> 00:46:01,060
我將這個命名為String helper並創建。

692
00:46:05,500 --> 00:46:09,380
你可以看到我收到了來自Xcode的提示。

693
00:46:09,380 --> 00:46:12,580
你想要配置一個Objective-C橋接頭文件嗎？

694
00:46:12,580 --> 00:46:16,900
這是因為這是我第一個添加到EssentialApp目標的Objective-C文件，

695
00:46:16,900 --> 00:46:19,540
而Xcode知道為了分享這個代碼到Swift，

696
00:46:19,540 --> 00:46:23,700
我需要創建一個橋接頭文件。

697
00:46:23,700 --> 00:46:27,620
所以讓我們創建一個。


699
00:46:33,380 --> 00:46:36,660
如果我查看這個EssentialApp橋接標頭檔案，

700
00:46:36,660 --> 00:46:40,340
Xcode自動產生的，我看到它是空的。

701
00:46:40,340 --> 00:46:42,940
Xcode使用像是這個名字的樣板，

702
00:46:42,940 --> 00:46:46,140
但是我們可以使用任何名稱給橋接標頭。

703
00:46:46,140 --> 00:46:48,580
重要的是有一個建立設定 

704
00:46:53,860 --> 00:46:55,820
叫做Objective-C橋接標頭

705
00:46:58,340 --> 00:47:03,340
或者是Swift OPC橋接標頭，它包含了這個名字。

706
00:47:03,900 --> 00:47:06,100
所以如果我重新命名我的檔案，

707
00:47:06,100 --> 00:47:09,620
我只需要確定我也更新我的建立設定。

708
00:47:12,380 --> 00:47:14,260
所以回到我們的String helper

709
00:47:14,260 --> 00:47:17,500
我們稍後將看到橋接標頭如何運作。

710
00:47:19,100 --> 00:47:22,260
我要向這個類別新增一些方法

711
00:47:24,380 --> 00:47:26,780
然後我會複製貼上它們。

712
00:47:31,66 --> 00:47:33,340
所以我增加了三種方法。

713
00:47:33,340 --> 00:47:35,420
第一種方法什麼都不做。

714
00:47:35,420 --> 00:47:36,940
它叫做做無動作，


715
00:47:36,940 --> 00:47:39,340
不接受任何參數且返回 Void。

716
00:47:39,340 --> 00:47:42,580
第二種方法返回 Void，

717
00:47:42,580 --> 00:47:46,940
返回 Void，帶一個字串和 CG 點。

718
00:47:46,940 --> 00:47:49,940
第三種會返回 bool

719
00:47:49,940 --> 00:47:52,980
並帶一個字串參數

720
00:47:52,980 --> 00:47:57,860
並使用 NSR 雙指針慣例

721
00:47:57,860 --> 00:47:59,100
返回一個錯誤。

722
00:48:01,740 --> 00:48:06,740
對於導入，我使用特定標頭 CGGeometry，

723
00:48:07,140 --> 00:48:10,100
這就是 CG 點被定義的地方。

724
00:48:10,100 --> 00:48:13,340
我也想要添加主體

725
00:48:13,340 --> 00:48:15,620
所以實現了字串助手。

726
00:48:21,220 --> 00:48:24,980
所以它導入了 字串助手.age。

727
00:48:24,980 --> 00:48:29,980
我們也從 UIKit 導入我們需要的特定標頭

728
00:48:30,660 --> 00:48:32,220
去繪製字串於點。

729
00:48:35,140 --> 00:48:38,580
這只是一個例子。

730
00:48:38,580 --> 00:48:43,340
並且驗證字串方法的主體

731
00:48:43,340 --> 00:48:46,500
檢查長度是否大於零，

732
00:48:46,500 --> 00:48:49,140
我們返回真，否則我們畫出一個錯誤。

733
00:48:49,140 --> 00:48:51,380
這是一個相當簡單的案例。

734
00:48:54,860 --> 00:48:58,340
請注意在Objective-C中有一個慣例

735
00:48:58,340 --> 00:49:01,500
一個像這樣返回bool值的函數

736
00:49:01,500 --> 00:49:03,420
也可以返回一個Error

737
00:49:04,540 --> 00:49:06,580
被認為是失敗的，

738
00:49:06,580 --> 00:49:10,860
即使我們返回false，但沒有提供任何Error。

739
00:49:10,860 --> 00:49:12,660
所以這也是一種錯誤情況。

740
00:49:12,660 --> 00:49:15,820
當你在Swift中使用這些方法時，這一點非常重要。

741
00:49:20,580 --> 00:49:23,260
所以讓我們看看這個程式是否能編譯。

742
00:49:23,260 --> 00:49:25,340
它應該能正常編譯，好的。

743
00:49:27,900 --> 00:49:30,860
現在記住，我沒有加入String helper

744
00:49:30,860 --> 00:49:33,180
到我的橋接頭文件。

745
00:49:33,180 --> 00:49:36,620
所以如果我去SceneDelegate並試圖使用它，

746
00:49:44,940 --> 00:49:46,540
我將得到一個失敗。

747
00:49:48,020 --> 00:49:51,340
所以我需要進入橋接頭文件

748
00:49:51,340 --> 00:49:54,780
並顯性地導入我的String helper。

749
00:49:54,780 --> 00:49:59,780
現在這個可以工作了。

750
00:50:04,860 --> 00:50:09,860
所以我可以使用String helper.validate String,任何String。

751
00:50:11,700 --> 00:50:13,900
並因为它将會繪製，

752
00:50:13,900 --> 00:50:18,900
所以我們將嘗試使用問號來使編譯器滿意。

753
00:50:19,860 --> 00:50:21,060
現在它運作了。

754
00:50:21,060 --> 00:50:26,060
所以回顧一下，查找Objective-C聲明

755
00:50:31,300 --> 00:50:32,700
在Swift中被使用，

756
00:50:33,940 --> 00:50:37,380
意識到Swift C或Swift編譯器

757
00:50:37,380 --> 00:50:39,300
嵌入Clang作為一個庫。

758
00:50:39,300 --> 00:50:42,700
這允許直接導入Objective-C框架。

759
00:50:43,820 --> 00:50:47,060
我們使用模組圖來部分導入這些模組

760
00:50:47,060 --> 00:50:50,260
以解析Objective-C聲明

761
00:50:50,260 --> 00:50:52,140
在同一個框架目標內。

762
00:50:52,140 --> 00:50:54,700
編譯器使用總線頭文件

763
00:50:54,700 --> 00:50:57,700
而用於增加目標時，它使用橋接頭文件。

764
00:51:04,340 --> 00:51:07,340
當導入器帶來聲明

765
00:51:07,340 --> 00:51:09,820
從Objective-C到Swift，

766
00:51:09,820 --> 00:51:12,620
它經常將它們變為更多的Swift。

767
00:51:12,620 --> 00:51:17,620
讓我們看一些範例。

768
00:51:20,100 --> 00:51:25,100
我將轉到來自CoreData的NSManage物件上下文頭文件

769
00:51:26,940 --> 00:51:31,940
並嘗試使用該系統，但我得到一個無選擇。

770
00:51:32,100 --> 00:51:37,100
所以我將重新打開我的項目。

771
00:51:39,660 --> 00:51:41,180
而這次它可以運作。

772
00:51:41,180 --> 00:51:46,180
我將使用生成的界面助手。

773
00:51:51,380 --> 00:51:55,500
我想要查看的方法是executeRequest。

774
00:51:58,660 --> 00:52:00,420
要找到它的對應項，

775
00:52:00,420 --> 00:52:02,580
我將使用NSPersistentStoreResult，

776
00:52:02,580 --> 00:52:05,580
這是唯一使用這個的功能。

777
00:52:05,580 --> 00:52:10,580
因此，你可以在左側看到標頭檔案

778
00:52:10,860 --> 00:52:15,860
來自於CoreData的NSManage物件內文。

779
00:52:16,420 --> 00:52:19,420
在右邊，使用生成的界面助手，

780
00:52:19,420 --> 00:52:24,420
我們基本上仿照Swift去生成

781
00:52:29,980 --> 00:52:32,980
這個物件的標頭檔案。

782
00:52:32,980 --> 00:52:36,860
這個標頭的標頭檔案

783
00:52:36,860 --> 00:52:39,820
並使其能在Swift中使用。

784
00:52:42,540 --> 00:52:44,300
我們注意到幾個事情。

785
00:52:44,300 --> 00:52:47,420
首先，這個方法的名稱是executeRequest。

786
00:52:47,420 --> 00:52:51,220
現在request部分已被刪除

787
00:52:51,220 --> 00:52:52,780
並且只剩execute這個名稱。

788
00:52:53,660 --> 00:52:56,260
它對於第一個參數沒有名稱，

789
00:52:56,260 --> 00:53:00,580
但是需求變數名稱會被用於

790
00:53:00,580 --> 00:53:03,260
在方法定義中。

791
00:53:03,260 --> 00:53:06,660
此外，因為它遵循了慣例

792
00:53:06,660 --> 00:53:09,900
像是最後一個參數是Error，

793
00:53:09,900 --> 00:53:11,740
NSError的雙指針，

794
00:53:12,700 --> 00:53:16,940
它被轉換為一種throws方法。

795
00:53:16,940 --> 00:53:19,780
你看不到NSError參數存在任何地方。

796
00:53:21,700 --> 00:53:25,100
並且它回傳一個NSPersistentStoreResult。

797
00:53:25,100 --> 00:53:30,100
另一個範例，在nstring.h裡，

798
00:53:35,340 --> 00:53:40,340
讓我們看看由String API分離的組件。

799
00:53:50,820 --> 00:53:52,700
並且它是一個組件。

800
00:53:52,700 --> 00:53:55,780
並且它是等價的。

801
00:53:55,780 --> 00:53:59,500
所以Objective-C的原始API

802
00:53:59,500 --> 00:54:01,780
被稱為由String分離的組件。

803
00:54:03,700 --> 00:54:07,140
Swift產生的介面名稱

804
00:54:07,140 --> 00:54:12,140
是由組件和分隔符參數組成。

805
00:54:18,020 --> 00:54:22,620
如果你熟悉Objective-C Generics，


806
00:54:22,620 --> 00:54:25,100
我們將在稍後解釋它們。

807
00:54:25,100 --> 00:54:29,660
你可以看到我們這裡有一個類型為NSArray以及一個String。

808
00:54:29,660 --> 00:54:30,860
所以是一個字符串的數組。

809
00:54:30,860 --> 00:54:34,060
所以這就是為什麼這個函數的返回類型

810
00:54:34,060 --> 00:54:35,340
是一个字符串的陣列。

811
00:54:40,420 --> 00:54:41,580
另一個例子

812
00:54:41,580 --> 00:54:46,580
是在nstring drawing.h裡面，

813
00:55:00,060 --> 00:55:02,140
我們做了這兩個APIs。

814
00:55:02,140 --> 00:55:04,380
所以是draw at point 和 draw in rect。

815
00:55:06,100 --> 00:55:10,500
對於他們來說，單詞 point 和 rect

816
00:55:10,500 --> 00:55:11,660
將被刪除。

817
00:55:12,660 --> 00:55:14,380
讓我們找找看。

818
00:55:16,420 --> 00:55:20,180
這些是對應的擴展

819
00:55:20,180 --> 00:55:21,820
在一個帶有String的資產上。

820
00:55:22,900 --> 00:55:25,060
你可以看到第一種方法。

821
00:55:25,060 --> 00:55:28,180
因此，draw at point被轉換為draw at

822
00:55:28,180 --> 00:55:42,700
而draw in rect被轉換為draw in。

823
00:55:42,700 --> 00:55:44,980
因此在Swift中這些詞被省略

824
00:55:44,980 --> 00:55:48,500
當方法導入時只需簡單地畫在或畫入。

825
00:55:49,860 --> 00:55:51,380
那這是怎麼運作的？

826
00:55:51,380 --> 00:55:53,500
現在，你可能會驚訝地發現

827
00:55:53,500 --> 00:55:55,220
編譯器包含了一個List

828
00:55:55,220 --> 00:55:58,340
列有常用的英語動詞和介詞。

829
00:55:58,340 --> 00:56:01,300
因為它只是一個硬編碼的List，

830
00:56:01,300 --> 00:56:04,420
只限用於少數的詞語。

831
00:56:04,420 --> 00:56:08,500
再者，為了達到Swift的命名慣例，

832
00:56:08,500 --> 00:56:10,700
導入器也將會重命名方法

833
00:56:10,700 --> 00:56:13,220
並刪除基於詞類的詞語。

834
00:56:21,780 --> 00:56:24,580
因此，檢查您的Objective-C頭文件

835
00:56:24,580 --> 00:56:26,220
如何導入到Swift，

836
00:56:26,220 --> 00:56:28,780
您可以使用剛才展示的生成介面助手

837
00:56:28,780 --> 00:56:29,740
我們剛才展示過。

838
00:56:32,100 --> 00:56:34,660
讓我們看看我們的String helper。

839
00:56:43,060 --> 00:56:47,340
所以我們看到它轉換了所有三個函數。

840
00:56:49,260 --> 00:56:51,860
所以 do nothing 就是 do nothing。

841
00:56:51,860 --> 00:56:53,700
這非常直接了當。

842
00:56:53,700 --> 00:56:57,780
drawString at point 被轉換為 draw at

843
00:56:59,220 --> 00:57:02,860
以及 validate String 返回了 bool

844
00:57:02,860 --> 00:57:07,300
並擁有一個NSR雙指針

845
00:57:07,300 --> 00:57:10,060
現在與String參數進行驗證

846
00:57:10,060 --> 00:57:11,740
以及可拋出異常的函數。

847
00:57:13,700 --> 00:57:18,020
另一個有趣的事情是，導入至核心圖形，

848
00:57:18,020 --> 00:57:21,620
CGGeometry.h被替換為import

849
00:57:21,620 --> 00:57:23,820
core-graphics.CGGeometry。

850
00:57:27,420 --> 00:57:30,220
現在讓我們看看我們如何使這些API

851
00:57:30,220 --> 00:57:31,460
更加的Swifty。

852
00:57:32,820 --> 00:57:35,860
首先，我們可以使用NSSwiftName

853
00:57:35,860 --> 00:57:39,900
來控制結果的Swift API名稱。

854
00:57:43,420 --> 00:57:46,180
所以如果我想要，比如說，

855
00:57:46,180 --> 00:57:51,820
把我的do nothing方法重命名為nothing，

856
00:57:51,820 --> 00:57:55,460
我將添加一个NSSwiftName與nothing名稱。

857
00:57:58,900 --> 00:58:02,060
這就是我如何刷新生成的介面。

858
00:58:03,820 --> 00:58:06,500
然後我看到函數的新名稱

859
00:58:06,500 --> 00:58:09,900
是nothing如指令。

860
00:58:09,900 --> 00:58:13,100
但由於此函數實際上什麼也沒做，


861
00:58:13,100 --> 00:58:16,780
我想從生成的界面完全排除它。

862
00:58:17,700 --> 00:58:20,420
為了做到這一點，我可以使用另一個屬性

863
00:58:20,420 --> 00:58:23,340
也就是NSSwiftUnavailable，

864
00:58:23,340 --> 00:58:25,300
它接受一個字符串參數

865
00:58:27,180 --> 00:58:29,460
像這是無法使用的原因。

866
00:58:29,460 --> 00:58:31,820
讓我們假設它什麼都不做。

867
00:58:36,220 --> 00:58:39,700
所以再次，我將刷新界面。

868
00:58:39,700 --> 00:58:42,540
抱歉。

869
00:58:46,100 --> 00:58:51,020
這次，該函數完全消失了。

870
00:58:51,020 --> 00:58:54,140
所以我只得到繪製和驗證函數。

871
00:58:54,140 --> 00:58:56,580
這就是NSSwiftUnavailable的工作方式。

872
00:59:00,540 --> 00:59:04,460
現在讓我們更深入地看看

873
00:59:04,460 --> 00:59:07,940
我的函數參數。

874
00:59:07,940 --> 00:59:11,460
所以默認情況下，所有Objective-C參數

875
00:59:11,460 --> 00:59:15,500
都作為隱含解包的可選項導入Swift，

876
00:59:15,500 --> 00:59:16,860
就像這裡的這些字符串。

877
00:59:19,500 --> 00:59:20,820
但我認為這是錯的

878
00:59:21,700 --> 00:59:24,300
因為一個NSString指針

879
00:59:25,260 --> 00:59:28,260
可以指向一個字符串值或指向Null。

880
00:59:29,780 --> 00:59:31,620
但如果它被設定為 Null

881
00:59:31,620 --> 00:59:36,620
我們試圖解開這個被隱式解包的 optional，

882
00:59:36,620 --> 00:59:37,900
這個應用程式將會崩潰。

883
00:59:40,380 --> 00:59:42,420
所以為了幫助編譯器，

884
00:59:42,420 --> 00:59:46,500
Objective-C添加了像 non-Null 或 nullable 這樣的註釋 

885
00:59:46,500 --> 00:59:48,940
來明確地標記哪些參數可以為 Null

886
00:59:48,940 --> 00:59:49,780
哪些不可以。

887
00:59:53,900 --> 00:59:55,020
我將這個標記

888
00:59:59,980 --> 01:00:03,900
把 drawString 的 String 參數設為 non-Null 並建立。

889
01:00:03,900 --> 01:00:08,900
我可以看到我得到了一些警告。

890
01:00:12,860 --> 01:00:16,140
這是因為一旦我們添加一個註釋，

891
01:00:16,140 --> 01:00:17,980
將一個 nullable 的註釋添加到一個檔案，

892
01:00:17,980 --> 01:00:20,460
編譯器會認為我們選擇了

893
01:00:20,460 --> 01:00:22,700
在該檔案中使用 nullable 註釋。

894
01:00:22,700 --> 01:00:25,860
所以我們必須提供這個資訊

895
01:00:25,860 --> 01:00:29,860
對於我們方法的所有參數。

896
01:00:29,860 --> 01:00:34,860
所以我們來添加剩下的註釋。

897
01:00:44,140 --> 01:00:46,100
我標記了第二個，

898
01:00:46,940 --> 01:00:49,860
將傳送到 validate String 的 String 標記為 nullable


899
01:00:49,860 --> 01:00:54,060
因為我們知道我們可以處理空值，

900
01:00:54,940 --> 01:00:56,820
所以新的值就在那裡。

901
01:00:56,820 --> 01:01:00,980
我用下劃線 nullable 來標記這些指針。

902
01:01:07,540 --> 01:01:12,540
建立並讓我們來看新的介面。

903
01:01:16,580 --> 01:01:20,340
現在，繪製函數的 String 參數

904
01:01:21,500 --> 01:01:24,860
從一個隱式展開的可選 String

905
01:01:24,860 --> 01:01:26,180
改為 String。

906
01:01:26,180 --> 01:01:27,860
這正是我們想要的。

907
01:01:29,020 --> 01:01:30,700
對於 validate 函數，

908
01:01:30,700 --> 01:01:32,780
由於我們將其標記為可空，

909
01:01:32,780 --> 01:01:35,460
類型現在是可選的 String。

910
01:01:40,100 --> 01:01:43,220
但尤其在大型文件中，

911
01:01:43,220 --> 01:01:47,340
添加所有這些註釋可以佔用很多空間。

912
01:01:47,340 --> 01:01:52,340
所以 Apple 添加了一些方便的指令。

913
01:01:52,340 --> 01:01:57,340
這些是 nsassume non-new begin 和 non-Null end

914
01:02:01,220 --> 01:02:03,380
你在文件模板中看到的

915
01:02:03,380 --> 01:02:05,260
由 Xcode 自動創建。

916
01:02:06,740 --> 01:02:10,340
在這些之間，Xcode 將認為

917
01:02:10,340 --> 01:02:15,020
所有變數都是非空的。

918
01:02:15,020 --> 01:02:26,020
所以你只需要標出哪些是可以為空的。

919
01:02:26,100 --> 01:02:30,660
我將建立並重新生成介面。

920
01:02:33,740 --> 01:02:35,700
而介面應該保持一樣。

921
01:02:35,700 --> 01:02:51,700
是的。

922
01:02:51,780 --> 01:02:54,340
我們可以幫助編譯器生成

923
01:02:54,340 --> 01:02:57,140
對Swift正確的介面的另一種方式就是使用

924
01:02:59,860 --> 01:03:04,620
三種類型的指令。

925
01:03:04,620 --> 01:03:08,980
NSEnum、NSOptions和NSErrorEnum。

926
01:03:08,980 --> 01:03:13,980
我將在我們的標頭檔案中複製粘貼一個範例。

927
01:03:16,820 --> 01:03:21,820
首先我們的類型定義 MyEnum type，

928
01:03:21,900 --> 01:03:26,460
其使用NSUnsignedIntegers作為支援。

929
01:03:27,500 --> 01:03:32,340
有三種情況，MyOptions、NSOption類型，

930
01:03:32,340 --> 01:03:37,340
也是由無符號整數支援，有零、一或兩個選項。

931
01:03:37,780 --> 01:03:42,780
還有一個稱為MyError的NSErrorEnum，

932
01:03:44,940 --> 01:03:46,540
有兩個特定的錯誤。

933
01:03:51,140 --> 01:03:53,460
讓我們來看看這些介面是如何看起來的。

934
01:03:53,460 --> 01:03:58,460
首先，我們看到一個使用無符號整數的SwiftEnum


935
01:04:05,420 --> 01:04:07,980
涵蓋所有情況，情況零，一和二。

936
01:04:08,900 --> 01:04:13,900
然後是一個名為 MyOptions 的結構，並符合 option set

937
01:04:14,180 --> 01:04:16,660
具有接受原始值的初始化器

938
01:04:16,660 --> 01:04:21,500
只有選項一和選項二的靜態變量

939
01:04:21,500 --> 01:04:24,580
因為選項零是預設值。

940
01:04:24,580 --> 01:04:28,700
而 MyError 結構更為複雜。

941
01:04:28,700 --> 01:04:32,260
它有一個接受 NSError 的初始化器。

942
01:04:32,260 --> 01:04:37,260
它具有一個內置的列舉代碼與特定的錯誤代碼

943
01:04:38,220 --> 01:04:43,220
還有一些特定錯誤的靜態變量。

944
01:04:43,220 --> 01:04:48,220
所以我們應該優先於常規的C風格枚舉型。

945
01:04:55,460 --> 01:05:00,460
我們可以做的另一件事來幫助 Swift 編譯器是

946
01:05:01,660 --> 01:05:06,660
遵循這種函數的慣例

947
01:05:07,700 --> 01:05:11,700
返回 bool 並返回 Null 的函數。

948
01:05:11,700 --> 01:05:16,700
該函數回傳 bool 並針對使用者回傳

949
01:05:19,020 --> 01:05:21,780
NSError 的雙指針作為最後一個參數

950
01:05:21,780 --> 01:05:25,900
它被稱為 Error，因為 Swift 生成的標頭

951
01:05:25,900 --> 01:05:29,020
可以察覺到這實質上是一種拋出方法。

952
01:05:29,020 --> 01:05:34,020
所以它可以將那轉化為一種Swift API會拋出來的。

953
01:05:34,020 --> 01:05:39,020
最後，我們提到的Objective-C泛型。

954
01:05:43,300 --> 01:05:48,300
於是我在我的String helper中黏貼一些function。

955
01:05:52,900 --> 01:05:54,700
第一個function叫做MyArray

956
01:05:54,700 --> 01:05:57,700
並只是回傳一個簡單的NSArray。

957
01:05:57,700 --> 01:06:02,220
第二個則使用泛型，所以它回傳

958
01:06:02,220 --> 01:06:06,580
使用泛型，所以這是一個明確的NSArray

959
01:06:06,580 --> 01:06:10,220
使用NSString 指標作為背後的類型。

960
01:06:10,220 --> 01:06:13,940
然後是一個簡單的NSDictionary，再來也是一個NSDictionary

961
01:06:13,940 --> 01:06:17,580
其中鍵是NSString，而值則是NSNumber。

962
01:06:17,580 --> 01:06:30,580
我們將看到這些的介面看起來如何。

963
01:06:33,660 --> 01:06:34,500
哎呀。

964
01:06:35,660 --> 01:06:40,340
所以，MyArray function回傳一個任意的Array

965
01:06:40,340 --> 01:06:43,980
在MyDictionary回傳AnyHashable到任何。

966
01:06:43,980 --> 01:06:47,540
這是因為NSArray和NSDictionary


967
01:06:47,540 --> 01:06:49,500
不提供任何關於類型的信息

968
01:06:49,500 --> 01:06:52,700
所以基本上可以是任何東西。

969
01:06:52,700 --> 01:06:54,740
但如果我們使用這些泛型，

970
01:06:56,660 --> 01:07:00,820
我們真的有助於編譯器解析類型。

971
01:07:00,820 --> 01:07:05,820
所以MyArray的字符串，這裡返回一個String數組

972
01:07:06,100 --> 01:07:09,380
字典同理，

973
01:07:09,380 --> 01:07:14,140
從String到NSNumber的明確哈希。

974
01:07:14,140 --> 01:07:16,660
這些泛型並不如Swift的強大

975
01:07:16,660 --> 01:07:19,540
但他們對於Swift確實有所幫助，

976
01:07:19,540 --> 01:07:22,420
特別是在導入聲明時對Swift編譯器有所幫助。

977
01:07:22,420 --> 01:07:26,100
但即使是Clang編譯器也很聰明。

978
01:07:33,620 --> 01:07:38,060
所以回顧一下，我們看到了編譯器對Objective-C頭文件進行的隱式轉換

979
01:07:38,060 --> 01:07:40,660
當導入到Swift時。

980
01:07:40,660 --> 01:07:42,100
並且，

981
01:07:43,500 --> 01:07:47,020
我們也看到了如何使我們的Swift界面

982
01:07:47,020 --> 01:07:52,020
通過給出明確的Swift API名稱變得更加友好或更多的Swift-y，

983
01:07:52,900 --> 01:07:56,140
當它們不實用時，將APIs隱藏於Swift中，

984
01:07:56,140 --> 01:07:58,660
提供可為空或者不可為空的註解

985
01:07:58,660 --> 01:08:01,500
避免隱式和未封裝的選項

986
01:08:02,860 --> 01:08:07,540
使用NSEnum, NSOptions 和 NSErrorEnum

987
01:08:07,540 --> 01:08:09,580
並使用Objective-C的泛型

988
01:08:09,580 --> 01:08:12,860
讓Swift編譯器確切知道要使用哪種類型。

989
01:08:19,820 --> 01:08:23,820
所以這就是Swift怎麼導入Objective-C，

990
01:08:23,820 --> 01:08:25,580
但反方向又怎麼樣呢？

991
01:08:25,580 --> 01:08:28,340
Objective-C要如何導入Swift？

992
01:08:28,340 --> 01:08:31,540
嗯，答案其實相當簡單。

993
01:08:31,540 --> 01:08:34,580
Swift為每個目標生成一個標題

994
01:08:34,580 --> 01:08:37,180
你可以進行井號導入。

995
01:08:37,180 --> 01:08:41,740
這個標題遵循規定

996
01:08:41,740 --> 01:08:45,100
為目標名稱加上橫號後加Swift點H。

997
01:08:48,540 --> 01:08:52,020
我將轉到SceneDelegate類，

998
01:08:53,500 --> 01:08:56,980
在EssentialApp目標中的Swift類

999
01:08:56,980 --> 01:09:00,060
並使用生成的介面。

1000
01:09:00,940 --> 01:09:03,660
所以生成的介面助手

1001
01:09:03,660 --> 01:09:07,540
現在顯示我的EssentialApp加橫號的Swift標頭。

1002
01:09:10,420 --> 01:09:13,940
這裡有很多的巨集和指令，

1003
01:09:13,940 --> 01:09:16,420
但如果我們滾動到結尾，

1004
01:09:16,420 --> 01:09:18,460
我們就會看到重要的部分。

1005
01:09:20,220 --> 01:09:21,580
讓我們看看這是如何運作的。

1006
01:09:22,620 --> 01:09:26,700
編譯器將生成這些Objective-C聲明

1007
01:09:27,900 --> 01:09:32,180
用於擴展任何主題的Swift類別

1008
01:09:32,180 --> 01:09:35,420
以及以add of C標記的方法。

1009
01:09:38,820 --> 01:09:40,980
對於應用程式和單元測試目標，

1010
01:09:40,980 --> 01:09:42,660
生成的標頭將包括

1011
01:09:42,660 --> 01:09:44,780
公開和內部聲明。

1012
01:09:44,780 --> 01:09:46,860
這允許您在應用程式的Objective-C部分

1013
01:09:46,860 --> 01:09:49,740
使用內部的Swift。

1014
01:09:49,740 --> 01:09:52,100
使用已生成的界面助手，

1015
01:09:52,100 --> 01:09:54,620
就像我們已經在做的，

1016
01:09:54,620 --> 01:09:56,580
我們可以看到為EssentialApp目標生成的Swift界面

1017
01:09:56,580 --> 01:09:58,420
而我們注意到兩個實體，

1018
01:09:59,940 --> 01:10:01,900
AppDelegate和SceneDelegate。

1019
01:10:01,900 --> 01:10:04,340
這是因為這些都是唯一的NSObject的子類

1020
01:10:06,740 --> 01:10:11,740
因為這些都是唯一的NSObject子類別


1021
01:10:12,140 --> 01:10:16,940
因為UI-responder實際上是NSObject的子類。

1022
01:10:20,100 --> 01:10:23,420
和他們的定義。

1023
01:10:23,420 --> 01:10:30,180
但如果我們去看，比方說，URLSessionHTTPClient，

1024
01:10:32,420 --> 01:10:36,220
Swift 文件這是我們EssentialFeed框架的一部分

1025
01:10:37,220 --> 01:10:40,460
並嘗試查看EssentialFeed.Swift，

1026
01:10:40,460 --> 01:10:42,860
我們會看到它沒有任何定義

1027
01:10:42,860 --> 01:10:47,860
除了編譯器自動包含的宏之外。

1028
01:10:47,860 --> 01:10:52,860
這是因為在我們的EssentialFeed中沒有實體

1029
01:10:54,020 --> 01:10:56,660
被暴露給Objective-C。

1030
01:10:56,660 --> 01:10:59,580
但作為一個實驗來看看這如何運作，

1031
01:10:59,580 --> 01:11:02,540
我們可以讓URLSessionHTTPClient

1032
01:11:02,540 --> 01:11:05,740
成為NSObject的子類。

1033
01:11:05,740 --> 01:11:10,020
我們也可以標記這個公開的初始化器

1034
01:11:10,900 --> 01:11:15,580
用添加Objective-C標記。

1035
01:11:15,580 --> 01:11:20,580
如果我們建立，Swift 生成的界面會再生成。

1036
01:11:22,180 --> 01:11:27,180
所以現在我們可以看到它包含了接口


1037
01:11:28,380 --> 01:11:31,300
針對 URLSessionHTTPClient。

1038
01:11:31,300 --> 01:11:34,140
並且 Swift 名稱相當有趣

1039
01:11:34,140 --> 01:11:37,980
因為它是一種變異的組合

1040
01:11:37,980 --> 01:11:40,060
包含了框架的名稱，

1041
01:11:40,060 --> 01:11:45,060
也就是在類別名稱中的 EssentialFeed。

1042
01:11:47,540 --> 01:11:49,620
這避免了在運行時的衝突

1043
01:11:49,620 --> 01:11:52,780
當兩個模塊定義相同名稱的類別時。

1044
01:11:52,780 --> 01:11:56,220
由於 Objective-C 沒有像 Swift 那樣的命名空間，

1045
01:11:56,220 --> 01:11:59,380
所有的實體都屬於全局命名空間，

1046
01:11:59,380 --> 01:12:01,620
所以碰撞很可能會發生。

1047
01:12:02,740 --> 01:12:06,980
Swift 生成的介面所做的混疊可以防止這種情況。

1048
01:12:06,980 --> 01:12:11,980
您可以告訴 Swift 編譯器

1049
01:12:13,300 --> 01:12:16,180
使用不同的 Objective-C 名稱，

1050
01:12:16,180 --> 01:12:20,180
但是將名稱與 obc 一起傳遞。

1051
01:12:27,940 --> 01:12:32,940
現在，即使 Swift 的名稱也是 URLSessionHTTPClient。

1052
01:12:32,940 --> 01:12:35,420
但是如果你這麼做，你就要負責

1053
01:12:35,420 --> 01:12:37,420
確保名稱不會衝突。

1054
01:12:50,780 --> 01:12:55,780
所以要在這個類別中使用這個Swift介面，

1055
01:12:57,180 --> 01:13:00,180
我們需要創建一個新的類別。

1056
01:13:00,180 --> 01:13:03,180
而如果我們想要在這個Swift介面中使用這個Swift介面

1057
01:13:03,180 --> 01:13:07,700
進入一個Objective-C的標頭檔，

1058
01:13:07,700 --> 01:13:11,980
我們可以去到我們的一個Objective-C檔案。

1059
01:13:13,020 --> 01:13:16,980
在這裡，我可以使用import essential，

1060
01:13:18,980 --> 01:13:23,980
是的，EssentialFeed，是的，它運作了。

1061
01:13:23,980 --> 01:13:28,980
所以在這裡，我可以使用我的URLHTTPSession類型。

1062
01:13:33,580 --> 01:13:34,820
Client等於。

1063
01:13:43,780 --> 01:13:45,780
它只暴露這個初始化器，

1064
01:13:45,780 --> 01:13:47,940
所以這是使用它的方法。

1065
01:13:47,940 --> 01:13:51,940
所以總結一下，找到Swift聲明

1066
01:13:51,940 --> 01:13:53,780
從Objective-C中使用的

1067
01:13:53,780 --> 01:13:56,180
是通過Swift產生的標頭檔完成的。

1068
01:13:59,700 --> 01:14:03,220
這裡重要的一點是永遠不要導入

1069
01:14:03,220 --> 01:14:06,420
你的Swift生成的標頭檔進入總線標頭檔，

1070
01:14:06,420 --> 01:14:09,820
因為這會創建一個循環依賴。

1071
01:14:09,820 --> 01:14:12,820
所以如果你想要使用Swift產生的頭文件，

1072
01:14:12,820 --> 01:14:15,820
你需要導入你的Swift產生的頭文件

1073
01:14:15,820 --> 01:14:17,980
在一個循環依賴中。

1074
01:14:17,980 --> 01:14:21,260
這是蘋果公司強烈建議我們不要做的事情。

1075
01:14:26,540 --> 01:14:30,900
最後，讓我們稍微談談一下

1076
01:14:30,900 --> 01:14:32,740
如何把控Swift的能力，

1077
01:14:32,740 --> 01:14:35,580
哪怕是在Objective-C中也要封裝它。

1078
01:14:37,900 --> 01:14:41,660
所以如果你已經衍合了Swift和Objective-C

1079
01:14:41,660 --> 01:14:43,620
進入了同一個項目，

1080
01:14:43,620 --> 01:14:46,900
你可能已經注意到，讓你的Swift代碼

1081
01:14:46,900 --> 01:14:48,740
可從Objective-C訪問

1082
01:14:48,740 --> 01:14:51,220
需要限制在Swift代碼中使用的Swift功能

1083
01:14:51,220 --> 01:14:53,020
你可以在Swift代碼中使用的功能。

1084
01:14:54,140 --> 01:14:56,300
使用下面的Swift特性

1085
01:14:56,300 --> 01:14:58,660
會使你的代碼在Objective-C中無法訪問

1086
01:14:58,660 --> 01:15:02,340
或者是可訪問性有限。

1087
01:15:02,340 --> 01:15:04,580
使用泛型，元組，

1088
01:15:04,580 --> 01:15:07,780
帶有關聯值的枚舉，結構，

1089
01:15:09,140 --> 01:15:11,700
頂層函數或全局變量，

1090
01:15:11,700 --> 01:15:15,020
類型別名，巢狀類型等等。

1091
01:15:18,580 --> 01:15:21,700
所以實際上，這意味著你不能真正使用

1092
01:15:21,700 --> 01:15:23,500
Swift提供給你的所有功能，

1093
01:15:23,500 --> 01:15:26,420
因為你很可能必須與你的Objective-C層共享那份Swift代碼

1094
01:15:26,420 --> 01:15:28,380
這將導致Swift代碼的效能不佳。

1095
01:15:28,380 --> 01:15:30,860
這導致了Swift代碼的表現不是最佳。

1096
01:15:32,740 --> 01:15:35,500
如果你的目標是逐漸遷移

1097
01:15:35,500 --> 01:15:38,900
從Objective-C代碼庫過渡到Swift，

1098
01:15:38,900 --> 01:15:41,420
用這些限制寫新的Swift代碼

1099
01:15:41,420 --> 01:15:44,420
將導致生成的Swift代碼效能不佳。

1100
01:15:45,580 --> 01:15:48,220
你的大多數類型都會是繼承自任何主題的類

1101
01:15:48,220 --> 01:15:49,860
所有的枚舉都是基於內的。

1102
01:15:49,860 --> 01:15:52,820
因此，你可能想要重寫那部分代碼

1103
01:15:52,820 --> 01:15:55,340
在未來也是如此。

1104
01:15:55,340 --> 01:15:56,740
讓我們引入一種策略

1105
01:15:58,340 --> 01:15:59,980
你仍然可以用Swift寫新的代碼，

1106
01:15:59,980 --> 01:16:03,100
充分利用所有新的特性

1107
01:16:03,100 --> 01:16:05,180
Swift所提供的，



1109
01:16:06,700 --> 01:16:08,860
同時保留一層的兼容性

1110
01:16:08,860 --> 01:16:13,100
與Objective-C代碼。

1111
01:16:13,100 --> 01:16:18,100
這個想法是將交點減少到平均值。

1112
01:16:19,780 --> 01:16:22,380
嘗試編寫像模塊之類的子系統，

1113
01:16:22,380 --> 01:16:25,580
使用相同語言編寫的功能或組件

1114
01:16:25,580 --> 01:16:27,100
而不是來回切換

1115
01:16:27,100 --> 01:16:28,900
在Swift和Objective-C之間。

1116
01:16:32,780 --> 01:16:36,500
如果這種系統，子系統是用Swift撰寫的

1117
01:16:36,500 --> 01:16:39,580
並且需要從Objective-C存取，

1118
01:16:39,580 --> 01:16:41,820
只有子系統界面

1119
01:16:41,820 --> 01:16:45,380
需要可以從Objective-C存取。

1120
01:16:45,380 --> 01:16:48,060
所以為此，我們可以在Swift中編寫一個包裝器

1121
01:16:48,060 --> 01:16:51,580
遵循我們談到的Objective-C的限制，

1122
01:16:51,580 --> 01:16:55,180
而在子系統中的所有其他文件

1123
01:16:55,180 --> 01:16:58,060
可以繼續使用Swift的功能。

1124
01:17:00,940 --> 01:17:04,580
此外，編寫這些包裝器只是暫時的。

1125
01:17:04,580 --> 01:17:06,780
一旦你重寫了使用該子系統的所有客戶端

1126
01:17:06,780 --> 01:17:09,260
你可以將其移除。

1127
01:17:09,260 --> 01:17:10,660
在Swift中。

1128
01:17:12,780 --> 01:17:17,780
剩下的將會是 Swifty 類型和程式碼。

1129
01:17:18,900 --> 01:17:21,100
現在讓我們看一些例子。

1130
01:17:21,100 --> 01:17:32,100
讓我們增加一個新的 Swift File，我們叫它計時器。

1131
01:17:38,780 --> 01:17:41,500
所以我們的計時器類別非常簡單。

1132
01:17:41,500 --> 01:17:43,860
它有一個可以是現在

1133
01:17:43,860 --> 01:17:47,300
或者是之後與一個相關的日期的枚舉

1134
01:17:47,300 --> 01:17:52,300
和一個執行功能，可以帶進一個這些時間的枚舉

1135
01:17:53,100 --> 01:17:57,540
如果枚舉案例是現在就執行一個回呼

1136
01:17:57,540 --> 01:18:02,540
或者在此Date使用此patch async after的之後。

1137
01:18:02,900 --> 01:18:03,740
非常簡單。

1138
01:18:04,620 --> 01:18:07,660
這並不是我建議你在產品中使用的程式碼，

1139
01:18:07,660 --> 01:18:10,180
但它適合做為一個練習。

1140
01:18:11,980 --> 01:18:14,700
對這個類別我們真正的限制只有

1141
01:18:14,700 --> 01:18:18,020
它的子類別是 NSObject，

1142
01:18:18,020 --> 01:18:20,380
但這在未來是容易移除的。

1143
01:18:21,220 --> 01:18:26,140
除此之外，我們可以使用這些枚舉

1144
01:18:26,140 --> 01:18:27,940
內部有相關的值

1145
01:18:29,300 --> 01:18:34,300
和其他像前面所述的實體。

1146
01:18:35,980 --> 01:18:40,980
然後我們為Objective-C軸理出了擴展

1147
01:18:40,980 --> 01:18:45,980
我們公開了一個用Objective-C標記的功能

1148
01:18:49,540 --> 01:18:52,980
適用於枚舉的每種情形。

1149
01:18:52,980 --> 01:18:56,980
所以一個是現在執行，另一個是稍後執行。

1150
01:18:56,980 --> 01:18:59,380
而稍後執行也需要插入一個日期。

1151
01:19:01,420 --> 01:19:06,420
在背後，兩者都只是調用我們的Swift函數。

1152
01:19:06,420 --> 01:19:11,420
Swift函數，這就是Objective-C的包裝器。

1153
01:19:17,980 --> 01:19:22,980
另一個例子是你可能想要定義你的值類型

1154
01:19:26,100 --> 01:19:29,380
或者作為結構的模型。

1155
01:19:31,420 --> 01:19:34,540
這就是我們項目中的一個例子

1156
01:19:34,540 --> 01:19:36,780
就是FeedImage結構。

1157
01:19:38,180 --> 01:19:41,700
那么我们如何将結構暴露给Objective-C呢？

1158
01:19:42,660 --> 01:19:45,580
哦，我们制作不了，但我们可以围绕它写一个包装器。

1159
01:19:48,620 --> 01:19:53,620
所以我就快速提醒大家


1160
01:19:55,100 --> 01:19:57,260
那麼，FeedImage有ID、描述，

1161
01:19:57,260 --> 01:19:59,580
位置和URL。

1162
01:19:59,580 --> 01:20:02,500
並且我們將這個FeedImage

1163
01:20:02,500 --> 01:20:05,500
封裝成FeedImage_Objective-C，

1164
01:20:06,340 --> 01:20:11,340
它是一個類，因為它需要繼承NSObject。

1165
01:20:11,540 --> 01:20:13,420
它內部使用了FeedImage。

1166
01:20:15,820 --> 01:20:19,420
我們寫了一些計算屬性

1167
01:20:19,420 --> 01:20:23,540
這只是返回FeedImage的值。

1168
01:20:23,540 --> 01:20:27,100
描述變量有一個特殊情況

1169
01:20:27,100 --> 01:20:30,660
因為NSObject已經包含了

1170
01:20:30,660 --> 01:20:33,340
一個名為description的屬性。

1171
01:20:33,340 --> 01:20:35,580
所以我們必須覆蓋它。

1172
01:20:35,580 --> 01:20:37,940
並且它有一個些微不同的簽名

1173
01:20:37,940 --> 01:20:41,660
而它返回一個String而不是String option。

1174
01:20:47,300 --> 01:20:50,500
所以通過將FeedImage封裝到一個FeedImage

1175
01:20:50,500 --> 01:20:53,820
C類，我們允許Objective-C

1176
01:20:53,820 --> 01:20:58,380
與Objective-C代碼互動

1177
01:20:58,380 --> 01:21:01,020
以及這個NSObject子類，

1178
01:21:01,020 --> 01:21:02,940
我們的所有Swift代碼都可以

1179
01:21:02,940 --> 01:21:05,700
仍可以使用我們的FeedImage結構。

1180
01:21:07,140 --> 01:21:10,140
如果你有所有與FeedImage一起工作的Swift類型

1181
01:21:10,140 --> 01:21:12,340
需要由Objective-C訪問，

1182
01:21:13,540 --> 01:21:16,540
例如 FeedCache，

1183
01:21:18,100 --> 01:21:20,540
您可以應用以前相同的技巧。

1184
01:21:20,540 --> 01:21:24,900
因此編寫一個擴展並定義API

1185
01:21:24,900 --> 01:21:29,820
與C子類的封裝的 FeedImage一起工作

1186
01:21:29,820 --> 01:21:30,940
的NSObject。

1187
01:21:35,340 --> 01:21:40,340
因此此擴展看起來像這樣。

1188
01:21:43,700 --> 01:21:46,500
所以我們使用OPC前綴

1189
01:21:46,500 --> 01:21:51,300
而不是採取一個FeedImage的數組，

1190
01:21:51,300 --> 01:21:55,180
而是取一個FeedImage underscore OPC的數組。

1191
01:21:55,180 --> 01:22:00,180
它也會拋出，我們稱之為保存Image，

1192
01:22:00,300 --> 01:22:02,260
我們已經擁有的保存方法

1193
01:22:02,260 --> 01:22:06,700
我們使用Map來獲取裡面的FeedImages。

1194
01:22:12,460 --> 01:22:16,700
另一個例子將會是，

1195
01:22:16,700 --> 01:22:21,700
我們曾經有一個FeedLoader協定

1196
01:22:26,220 --> 01:22:28,020
在我們的項目裡面。

1197
01:22:28,020 --> 01:22:32,860
在創建一些時，它被移除了，

1198
01:22:32,860 --> 01:22:35,300
就像最後的重構是處理泛型。

1199
01:22:39,060 --> 01:22:40,620
但這是簽名。

1200
01:22:40,620 --> 01:22:42,860
所以它有一個 Result 類型

1201
01:22:42,860 --> 01:22:47,620
那是FeedImage的陣列或者是錯誤

1202
01:22:47,620 --> 01:22:49,540
以及一個名為 load 的 API，

1203
01:22:49,540 --> 01:22:54,540
這是一個異步 API，基本上返回一個 Result。

1204
01:22:58,260 --> 01:23:03,260
現在，如果我們為它有穩固的 Objective-C 實現，

1205
01:23:06,300 --> 01:23:09,860
為了便利，我仍將在此處列出 Swift，

1206
01:23:09,860 --> 01:23:12,580
但就讓我們稱這是 Objective-C。

1207
01:23:15,580 --> 01:23:16,420
然後，

1208
01:23:23,660 --> 01:23:27,780
我們可以再次為它寫一個 Swift 包裝器。

1209
01:23:27,780 --> 01:23:29,460
所以是反過來。

1210
01:23:29,460 --> 01:23:31,620
如果我們有穩固的Objective-C，

1211
01:23:31,620 --> 01:23:33,460
我們希望使用 Swift，

1212
01:23:33,460 --> 01:23:38,060
我們將其包裝在 Swift 對象， Swift 類型中。

1213
01:23:38,060 --> 01:23:41,540
現在，我們的Objective-C 有一些限制。

1214
01:23:41,540 --> 01:23:43,540
它不能使用 Result 類型。

1215
01:23:43,540 --> 01:23:46,900
所以它必須使用兩個參數，

1216
01:23:46,900 --> 01:23:50,340
一個是可選的FeedImage陣列和一個可選的Error。

1217
01:23:51,420 --> 01:23:54,580
然而，我們知道我們想要使用Result類型，

1218
01:23:54,580 --> 01:23:57,460
其可以是陣列或者Error。

1219
01:23:59,060 --> 01:24:03,860
所以我們將C的RemoteFeedLoader包裹起來，

1220
01:24:03,860 --> 01:24:07,180
放入RemoteFeedLoader類別中。

1221
01:24:07,180 --> 01:24:10,460
而在load函式中，

1222
01:24:10,460 --> 01:24:14,860
這次遵循FeedLoader協議，

1223
01:24:14,860 --> 01:24:18,820
我們只是對load進行Map操作，

1224
01:24:18,820 --> 01:24:20,900
該操作可以回傳兩個參數。

1225
01:24:21,820 --> 01:24:24,860
如果我們得到一個Error，

1226
01:24:24,860 --> 01:24:27,700
我們就用失敗的結果呼叫Completion。

1227
01:24:27,700 --> 01:24:30,780
如果我們得到一個Feed，我們用成功的結果呼叫Completion。

1228
01:24:30,780 --> 01:24:34,060
並且，因為這裡有一個狀態，

1229
01:24:34,060 --> 01:24:36,220
這個狀態不應該被表達出來，

1230
01:24:36,220 --> 01:24:39,740
但是卻由於optional的組合而存在，

1231
01:24:39,740 --> 01:24:44,380
我們可以既沒有Error也沒有Feed。

1232
01:24:44,380 --> 01:24:48,100
在這個情況下，我們會以失敗結束

1233
01:24:48,100 --> 01:24:50,580
並產生這個意想不到的 Error 結構.

1234
01:24:53,060 --> 01:24:58,060
所以這就是我建議

1235
01:24:58,060 --> 01:25:03,060
你應該如何逐步遷移到這個問題的方法。

1236
01:25:08,980 --> 01:25:10,500
謝謝。

1237
01:25:10,500 --> 01:25:12,380
如果有任何問題，

1238
01:25:13,580 --> 01:25:17,140
Sarthak說，可以接受FeedImage或C的FeedImage。

1239
01:25:17,140 --> 01:25:22,140
是的，這裡應該是C的FeedImage，對吧？

1240
01:25:31,260 --> 01:25:36,260
好的，嗨，嗨，所以在FeedImage underscore Objective-C

1241
01:25:39,380 --> 01:25:42,700
在類中，你提出了一個FeedImage。

1242
01:25:42,700 --> 01:25:44,140
這樣可以吧？

1243
01:25:45,300 --> 01:25:46,460
有個原因。

1244
01:25:46,460 --> 01:25:51,380
就像我說的，這些Objective-C包裝函數只是暫時的。

1245
01:25:51,380 --> 01:25:56,380
我們需要這個是因為在FeedCache實施中，

1246
01:25:57,580 --> 01:26:01,220
我們需要 Map 並實際獲取 FeedImage。

1247
01:26:01,220 --> 01:26:04,340
所以這就是我們使用此屬性的地方。

1248
01:26:04,340 --> 01:26:06,100
這就是為何它是公開的。

1249
01:26:06,100 --> 01:26:09,940
你可以通過創建一個新的 FeedImage 來隱藏這個。

1250
01:26:09,940 --> 01:26:12,860
所以這將變為私有的。

1251
01:26:12,860 --> 01:26:17,860
然後這將無法被訪問，

1252
01:26:18,260 --> 01:26:21,180
但我們可以創建一個新的 FeedImage。

1253
01:26:22,780 --> 01:26:27,780
我們必須傳遞 $0.ID, $0.description。

1254
01:26:35,180 --> 01:26:37,460
所以讓它公開將是一種優化

1255
01:26:37,460 --> 01:26:38,740
當返回橋接時。

1256
01:26:38,740 --> 01:26:41,420
所以你不需要實例化一個新對象。

1257
01:26:41,420 --> 01:26:43,500
但如果你不想暴露它，這也沒問題。

1258
01:26:43,500 --> 01:26:45,060
我們只需創建一個新的。

1259
01:26:46,500 --> 01:26:51,500
所以如果沒有其他問題，我們就可以結束了。

1260
01:26:52,860 --> 01:26:55,140
好的，謝謝。

1261
01:26:55,140 --> 01:26:56,460
謝謝你。

1262
01:26:56,460 --> 01:27:11,460
我們下次見。