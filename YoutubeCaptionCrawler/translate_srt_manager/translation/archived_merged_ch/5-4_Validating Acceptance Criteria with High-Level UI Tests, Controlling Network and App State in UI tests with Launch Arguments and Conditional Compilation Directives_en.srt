

1
00:00:00,366 --> 00:00:03,333
嗨，Mike，嘿，Caio在之前的

2
00:00:03,333 --> 00:00:05,033
講座我們完成了項目的

3
00:00:05,033 --> 00:00:05,900
應用程序

4
00:00:05,900 --> 00:00:08,133
並且我們通過運行證明了它的工作

5
00:00:08,133 --> 00:00:09,833
應用程序”

6
00:00:09,833 --> 00:00:12,233
但我們沒有自動化測試來證明

7
00:00:12,233 --> 00:00:13,500
這種組合

8
00:00:13,500 --> 00:00:16,066
的確是有效的，所以儘管我們可以運行

9
00:00:16,066 --> 00:00:16,800
應用程序

10
00:00:16,800 --> 00:00:19,333
並看到它運作，我們希望自動化

11
00:00:19,333 --> 00:00:20,700
一些檢查

12
00:00:20,700 --> 00:00:22,633
並且有很多方法我們可以做到這一點

13
00:00:22,633 --> 00:00:24,633
我們可以用單元測試與

14
00:00:24,633 --> 00:00:26,400
整合測試

15
00:00:26,400 --> 00:00:29,033
甚至更高級的測試通過

16
00:00:29,033 --> 00:00:31,033
用戶界面

17
00:00:31,033 --> 00:00:34,466
我們可以遵循我們的BDD規範

18
00:00:34,466 --> 00:00:37,666
是作為接受標準

19
00:00:37,666 --> 00:00:40,700
確實，只是非常高級的測試

20
00:00:40,700 --> 00:00:42,633
證明我們滿足所有的

21
00:00:42,633 --> 00:00:44,066
接受條件

22
00:00:44,066 --> 00:00:46,533
所以我們有線上客戶和

23
00:00:46,533 --> 00:00:48,533
離線客戶

24
00:00:48,533 --> 00:00:51,333
我們可以使用UI測試通過

25
00:00:51,333 --> 00:00:52,933
用戶界面

26
00:00:52,933 --> 00:00:55,500
來測試應用程序的組合好的，

27
00:00:55,500 --> 00:00:56,366
我們將進行測試


28
00:00:56,366 --> 00:00:58,366
從更高層次的應用程序

29
00:00:58,366 --> 00:01:01,500
就像一個黑箱子一樣

30
00:01:01,500 --> 00:01:03,666
和往常一樣，讓我們先從一個測試開始

31
00:01:03,666 --> 00:01:05,666
所以我將丟棄

32
00:01:05,666 --> 00:01:06,700
在Scene中的變更

33
00:01:06,700 --> 00:01:08,466
Delegate，因為我們要測試

34
00:01:08,466 --> 00:01:11,433
現在開始這個組成

35
00:01:11,433 --> 00:01:14,533
所以我們需要創建一個新的測試目標

36
00:01:14,533 --> 00:01:18,133
這是一個iOS目標，我們可以使用UI

37
00:01:18,133 --> 00:01:21,266
Testing Bundle模板

38
00:01:21,266 --> 00:01:24,400
我們把它叫做EssentialAppUI

39
00:01:24,400 --> 00:01:28,300
AcceptanceTests，好

40
00:01:28,300 --> 00:01:30,400
確保目標程式應用是

41
00:01:30,400 --> 00:01:33,033
正確的，我們正在測試EssentialApp

42
00:01:33,033 --> 00:01:35,733
應用程式，同時讓我們配置我們的

43
00:01:35,733 --> 00:01:36,633
計劃

44
00:01:36,633 --> 00:01:38,933
首先，我們為了

45
00:01:38,933 --> 00:01:41,333
創建測試EssentialApp的UI測試

46
00:01:41,333 --> 00:01:45,600
已經加入到EssentialApp計劃中

47
00:01:45,600 --> 00:01:47,266
意味著每次當我們運行

48
00:01:47,266 --> 00:01:49,333
EssentialApp測試時，它將會運行

49
00:01:49,333 --> 00:01:52,633
單元測試和UI測試，但是我們

50
00:01:52,633 --> 00:01:53,200
並不想讓這樣發生

51
00:01:53,200 --> 00:01:54,933
我們希望能夠運行單元測試

52
00:01:54,933 --> 00:01:56,233
在隔離狀態下

53
00:01:56,233 --> 00:01:57,833
因為它們更可靠且

54
00:01:57,833 --> 00:01:59,733
快速，我們將經常運行它

55
00:01:59,733 --> 00:02:03,900
但是UI測試通常慢

56
00:02:03,900 --> 00:02:06,366
所以我們會少運行它們

57
00:02:06,366 --> 00:02:07,266
確切地說

58
00:02:07,266 --> 00:02:09,500
當我們按Command+U時，我們只是希望進行一些

59
00:02:09,500 --> 00:02:11,666
極速的測試

60
00:02:11,666 --> 00:02:15,100
確實，只有單元測試，讓我們

61
00:02:15,100 --> 00:02:15,833
移除

62
00:02:15,833 --> 00:02:18,533
EssentialApp的UI測試

63
00:02:18,533 --> 00:02:20,866
計劃

64
00:02:20,866 --> 00:02:23,733
讓我們去管理計劃並新增

65
00:02:23,733 --> 00:02:25,333
一個新的

66
00:02:25,333 --> 00:02:28,133
針對UI測試的，因此我們可以運行UI

67
00:02:28,133 --> 00:02:28,700
測試

68
00:02:28,700 --> 00:02:32,066
隔離下進行，對，我喜歡這樣，這更

69
00:02:32,066 --> 00:02:33,200
乾淨

70
00:02:33,200 --> 00:02:36,400
讓我們將其移至工作區容器

71
00:02:36,400 --> 00:02:40,933
好的，現在讓我們配置CI_iOS

72
00:02:40,933 --> 00:02:44,300
新增UI測試，讓它也能運行

73
00:02:44,300 --> 00:02:47,333
在CI伺服器中，我們將測試順序隨機化以確保

74
00:02:47,333 --> 00:02:48,000
確定

75
00:02:48,000 --> 00:02:50,133
測試之間沒有順序依賴關係

76
00:02:50,133 --> 00:02:51,266
測試

77
00:02:51,266 --> 00:02:53,666
每一個測試都應該是獨立的

78
00:02:53,666 --> 00:02:54,700
就是這樣

79
00:02:54,700 --> 00:02:58,866
好的，我們可以開始提交了

80
00:02:58,866 --> 00:03:02,466
所以為運行增加 UI 測試目標

81
00:03:02,466 --> 00:03:06,533
高級驗收測試，就是這樣

82
00:03:06,533 --> 00:03:09,666
然後讓我們增加我們的第一個測試，首先

83
00:03:09,666 --> 00:03:11,433
測試

84
00:03:11,433 --> 00:03:14,133
從驗收標準中知道，在啟動時

85
00:03:14,133 --> 00:03:15,033
應該顯示

86
00:03:15,033 --> 00:03:17,266
當客戶擁有網路連接時的遠程資訊流

87
00:03:17,266 --> 00:03:19,333
連接性

88
00:03:19,333 --> 00:03:20,700
所以我們將要運行該應用程序

89
00:03:20,700 --> 00:03:22,466
我們將要啟動該應用程序，我們希望

90
00:03:22,466 --> 00:03:24,300
確保我們加載了資訊流

91
00:03:24,300 --> 00:03:27,733
我們如何做到這一點呢？我們會得到一個JSON

92
00:03:27,733 --> 00:03:28,233
回來

93
00:03:28,233 --> 00:03:30,466
在當前的遠端資訊流中有幾個項目

94
00:03:30,466 --> 00:03:31,666
幾個項目

95
00:03:31,666 --> 00:03:34,400
如果我數我們有多少項目

96
00:03:34,400 --> 00:03:35,266
我們有

97
00:03:35,266 --> 00:03:38,633
22張圖片，所以我們可以只檢查我們是否

98
00:03:38,633 --> 00:03:39,200
有

99
00:03:39,200 --> 00:03:42,533
22個格子，好的，我們可以

100
00:03:42,533 --> 00:03:46,133
根據格子數量來檢查，是的，如果我們

101
00:03:46,133 --> 00:03:48,133
有22個格子，這意味著

102
00:03:48,133 --> 00:03:51,733
我們從遠端載入了22個圖像

103
00:03:53,566 --> 00:03:56,866
所以應用程式的格子數量應該要是

104
00:03:56,866 --> 00:04:00,633
22, 揭示

105
00:04:00,633 --> 00:04:05,200
我們啟動應用程式

106
00:04:05,200 --> 00:04:07,500
就是這樣，有了這個測試我們可以

107
00:04:07,500 --> 00:04:08,700
確保的是

108
00:04:08,700 --> 00:04:11,900
我們用22個格子載入資訊，但是我們

109
00:04:11,900 --> 00:04:13,266
並未證明我們載入了

110
00:04:13,266 --> 00:04:16,366
每個訊息項目的圖像

111
00:04:16,366 --> 00:04:20,533
是的，我們只是證明了格子的數量

112
00:04:20,533 --> 00:04:23,900
所以我們也可以檢查

113
00:04:23,900 --> 00:04:27,033
圖像的數量，但問題是

114
00:04:27,033 --> 00:04:29,333
這些圖像都在格子裡

115
00:04:29,333 --> 00:04:33,100
而在UI測試中，我們可以查詢

116
00:04:33,100 --> 00:04:35,266
畫面上有多少格子

117
00:04:35,266 --> 00:04:36,933
即使格子

118
00:04:36,933 --> 00:04:39,166
不在畫面上，問題是

119
00:04:39,166 --> 00:04:40,533
圖像都在格子裡

120
00:04:40,533 --> 00:04:43,500
而你無法計算出像圖像這樣的項目

121
00:04:43,500 --> 00:04:44,466
在單個格子中的數量

122
00:04:44,466 --> 00:04:47,833
那些未在螢幕上的，所以如果我們檢查

123
00:04:47,833 --> 00:04:48,800
影像的計數

124
00:04:48,800 --> 00:04:50,700
我們只能計算那些在

125
00:04:50,700 --> 00:04:52,800
螢幕上的，這個情況下將只有

126
00:04:52,800 --> 00:04:53,666
2

127
00:04:53,666 --> 00:04:56,466
對於較小的螢幕尺寸的裝置

128
00:04:56,466 --> 00:04:57,166
可能只剩下1

129
00:04:57,166 --> 00:05:00,533
是的，或許我們該確保我們至少加載了

130
00:05:00,533 --> 00:05:02,066
一個影像

131
00:05:02,066 --> 00:05:04,233
所以我們可以獲得第一個單元並確保

132
00:05:04,233 --> 00:05:06,466
它有一個影像，好的，這樣我們可以

133
00:05:06,466 --> 00:05:07,733
測試這個

134
00:05:07,733 --> 00:05:10,466
我們正在加載含有22個影像的訊息源

135
00:05:10,466 --> 00:05:11,433
並且我們至少載入

136
00:05:11,433 --> 00:05:13,733
第一個訊息項目的第一個影像

137
00:05:13,733 --> 00:05:15,100
所以讓我們執行這個測試，它應該

138
00:05:15,100 --> 00:05:18,400
會失敗，讓我們選擇正確的方案

139
00:05:18,400 --> 00:05:19,833
EssentialAppUIAcceptanceTests並且

140
00:05:19,833 --> 00:05:22,466
讓我們運行它

141
00:05:22,466 --> 00:05:25,433
這個UI測試將實際運行

142
00:05:25,433 --> 00:05:27,100
我們的應用程序

143
00:05:27,100 --> 00:05:29,166
並觀查螢幕上的事情

144
00:05:29,166 --> 00:05:30,300
我們的應用程式

145
00:05:30,300 --> 00:05:33,666
並且查看螢幕上的內容

146
00:05:33,666 --> 00:05:35,500
如你所見，我們已加載了一個空的

147
00:05:35,500 --> 00:05:36,700
application

148
00:05:36,700 --> 00:05:38,933
並且它當然找不到該單元格

149
00:05:38,933 --> 00:05:40,700
或者第一個圖像

150
00:05:40,700 --> 00:05:43,600
好，讓我們實現該SceneDelegate，所以

151
00:05:43,600 --> 00:05:44,866
讓我們導入

152
00:05:44,866 --> 00:05:48,066
EssentialFeed以及Essential

153
00:05:48,066 --> 00:05:51,500
FeediOS

154
00:05:51,500 --> 00:05:53,266
讓我們只添加代碼以使此

155
00:05:53,266 --> 00:05:54,800
測試通過

156
00:05:54,800 --> 00:05:56,800
我們需要RemoteFeedLoader來加載

157
00:05:56,800 --> 00:05:58,466
從遠端加載feed

158
00:05:58,466 --> 00:06:00,233
和一個圖像加載器加載圖像

159
00:06:00,233 --> 00:06:01,733
確切的說 

160
00:06:01,733 --> 00:06:03,833
當前的測試並未提到任何

161
00:06:03,833 --> 00:06:06,233
本地或者緩存的feed

162
00:06:06,233 --> 00:06:08,133
那麼讓我們運行它，它將再次運行

163
00:06:08,133 --> 00:06:10,133
app

164
00:06:10,133 --> 00:06:12,400
但這次它加載單元格和

165
00:06:12,400 --> 00:06:15,433
加載圖像

166
00:06:15,433 --> 00:06:19,833
通過了，那麼讓我們提交 

167
00:06:19,833 --> 00:06:22,466
當客戶有連接時會在啟動時顯示遠端feed

168
00:06:22,466 --> 00:06:24,466
完成了

169
00:06:24,466 --> 00:06:27,333
那好，現在這個可以運行，但是

170
00:06:27,333 --> 00:06:29,100
有點脆弱，因為

171
00:06:29,100 --> 00:06:31,100
我們可能會添加更多的單元格到這昰

172
00:06:31,100 --> 00:06:33,100
在應用程序中並未實際上

173
00:06:33,100 --> 00:06:36,233
有feed圖像單元，所以僅依數量

174
00:06:36,233 --> 00:06:39,166
衡量任何單元並不是有效的方式

175
00:06:39,166 --> 00:06:40,233
釐定這些值。

176
00:06:40,233 --> 00:06:42,233
所以我們可以用識別符來

177
00:06:42,233 --> 00:06:43,900
確認正確的單元。

178
00:06:43,900 --> 00:06:47,166
我們真正想要計數的是，這樣我們就可以找到

179
00:06:47,166 --> 00:06:49,333
帶有特定識別符的單元

180
00:06:49,333 --> 00:06:52,233
例如feed圖像單元，然後我們只計算

181
00:06:52,233 --> 00:06:54,133
匹配該識別符的單元

182
00:06:54,133 --> 00:06:54,866
應該是

183
00:06:54,866 --> 00:06:57,833
22，然後我們可以對圖像做同樣的事

184
00:06:57,833 --> 00:06:58,300
圖像

185
00:06:58,300 --> 00:07:00,933
我們獲取帶有識別符的第一個圖像

186
00:07:00,933 --> 00:07:01,333
feed

187
00:07:01,333 --> 00:07:04,233
圖像視圖，然後我們只需要確保

188
00:07:04,233 --> 00:07:04,933
它存在

189
00:07:04,933 --> 00:07:08,300
讓我們再運行一次，理應會

190
00:07:08,300 --> 00:07:10,000
失敗，因為我們沒有

191
00:07:10,000 --> 00:07:15,833
在我們的視圖中設置這樣的識別符

192
00:07:15,833 --> 00:07:19,266
失敗了，好，那麼我們設置

193
00:07:19,266 --> 00:07:21,433
識別符，我們可以在

194
00:07:21,433 --> 00:07:22,300
故事版中進行設置

195
00:07:22,300 --> 00:07:24,300
或者如果你使用的是代碼，你也可以在

196
00:07:24,300 --> 00:07:26,000
代碼中設置它。

197
00:07:26,000 --> 00:07:28,133
所以讓我們選擇這個 cell，讓我們添加

198
00:07:28,133 --> 00:07:29,033
identifier

199
00:07:29,033 --> 00:07:32,933
feed-image-cell 讓我們選擇

200
00:07:32,933 --> 00:07:36,400
圖像，然後讓我們設置 feed-image-

201
00:07:36,400 --> 00:07:41,033
view identifier 返回到測試

202
00:07:41,033 --> 00:07:50,866
再次運行該測試

203
00:07:50,866 --> 00:07:53,266
通過。所以現在我們證明了我們

204
00:07:53,266 --> 00:07:54,633
正在加載 22

205
00:07:54,633 --> 00:07:57,166
個 feed image cells，然後我們最少加載

206
00:07:57,166 --> 00:07:58,000
至少

207
00:07:58,000 --> 00:08:00,300
一個 feed image，這意味著我們

208
00:08:00,300 --> 00:08:01,100
正在測試

209
00:08:01,100 --> 00:08:04,233
remote feed loader 和 remote

210
00:08:04,233 --> 00:08:07,266
feed image data loader，好的

211
00:08:07,266 --> 00:08:10,933
有了很大的改善，所以讓我們提交

212
00:08:10,933 --> 00:08:13,833
因此，通過使用 identifier 來提高涵蓋範圍

213
00:08:13,833 --> 00:08:15,333
用來找到 feed image

214
00:08:15,333 --> 00:08:18,533
cells，就這樣了

215
00:08:18,533 --> 00:08:20,933
關於在線情境當客戶

216
00:08:20,933 --> 00:08:23,433
有連接時

217
00:08:23,433 --> 00:08:25,033
現在當你沒有

218
00:08:25,033 --> 00:08:26,533
連接時會發生什麼

219
00:08:26,533 --> 00:08:28,700
如果你有兩個分支，

220
00:08:28,700 --> 00:08:30,066
如果緩存中有內容

221
00:08:30,066 --> 00:08:33,500
它應該顯示已緩存的 feed，否則，

222
00:08:33,500 --> 00:08:37,733
顯示一個空的 feed，所以第一個

223
00:08:37,733 --> 00:08:41,200
在啟動時應顯示緩存的 feed

224
00:08:41,200 --> 00:08:44,000
客戶無法連接網路時

225
00:08:44,000 --> 00:08:45,333
此為你擁有的情境

226
00:08:45,333 --> 00:08:46,233
擁有緩存的 feed 

227
00:08:46,233 --> 00:08:48,700
但没有網路連接，該如何模擬

228
00:08:48,700 --> 00:08:50,300
此情境呢

229
00:08:50,300 --> 00:08:52,766
首先我們要載入某些內容

230
00:08:52,766 --> 00:08:54,300
進到緩存中

231
00:08:54,300 --> 00:08:55,833
要載入內容我們需要

232
00:08:55,833 --> 00:08:58,466
網路連接，因此我們可以啟動 app

233
00:08:58,466 --> 00:09:00,933
有網路連接應該載入並

234
00:09:00,933 --> 00:09:03,266
緩存項目

235
00:09:03,266 --> 00:09:05,900
然後我們可以再次啟動 app，但在

236
00:09:05,900 --> 00:09:07,500
這種情況下，我們需要控制

237
00:09:07,500 --> 00:09:10,300
我們是否有網路連接，我們需要

238
00:09:10,300 --> 00:09:11,600
一個離線

239
00:09:11,600 --> 00:09:13,733
應用程式，並沒有簡單的方法可以

240
00:09:13,733 --> 00:09:17,266
以黑盒 UI 測試來實現

241
00:09:17,266 --> 00:09:20,133
但我們可以將啟動參數傳給

242
00:09:20,133 --> 00:09:21,266
應用程式

243
00:09:21,266 --> 00:09:23,600
於是在此情況中，將傳遞一個

244
00:09:23,600 --> 00:09:25,666
與連接性有關的參數，其值為

245
00:09:25,666 --> 00:09:29,666
離線，然後我們可以檢查我們

246
00:09:29,666 --> 00:09:30,533
應該擁有

247
00:09:30,533 --> 00:09:34,466
螢幕上的 22 個緩存 feed 單元

248
00:09:34,466 --> 00:09:37,266
並且它還會加載圖片

249
00:09:37,266 --> 00:09:38,133
我們正在進行測試

250
00:09:38,133 --> 00:09:39,833
我們正在編寫遠程feed

251
00:09:39,833 --> 00:09:42,066
使用本地的feed加載器來加載遠程feed

252
00:09:42,066 --> 00:09:45,033
以及遠程feed圖像數據加載器

253
00:09:45,033 --> 00:09:47,600
與本地的feed圖像數據加載器

254
00:09:47,600 --> 00:09:50,066
但要使這個工作，我們需要控制

255
00:09:50,066 --> 00:09:51,266
應用程序的連接性

256
00:09:51,266 --> 00:09:53,833
啟動應用程式的狀態

257
00:09:53,833 --> 00:09:55,033
根據啟動參數

258
00:09:55,033 --> 00:09:57,733
是的，我們的SceneDelegate可以創建一個

259
00:09:57,733 --> 00:09:58,300
函數

260
00:09:58,300 --> 00:10:02,066
製作遠程客戶端，所以如果我們獲得

261
00:10:02,066 --> 00:10:05,333
一個連接值，並且它處於離線狀態

262
00:10:05,333 --> 00:10:07,900
我們可以使用一個總是失敗的HTTPClient

263
00:10:07,900 --> 00:10:08,533
例如

264
00:10:08,533 --> 00:10:11,100
假裝應用程式處於離線狀態

265
00:10:11,100 --> 00:10:12,066
的應用程式

266
00:10:12,066 --> 00:10:15,500
好的，否則它就使用真正的一個

267
00:10:15,500 --> 00:10:17,600
我們可以使用這個非常方便的

268
00:10:17,600 --> 00:10:19,666
UserDefaults的功能

269
00:10:19,666 --> 00:10:22,066
它可以為我們讀取啟動參數

270
00:10:22,066 --> 00:10:23,666
並將其轉換

271
00:10:23,666 --> 00:10:26,133
為字符串，布爾值，整數等等

272
00:10:26,133 --> 00:10:27,733
在這種情況下，我們希望得到一個字符串

273
00:10:27,733 --> 00:10:30,533
連接性，如果離線，我們就

274
00:10:30,533 --> 00:10:33,200
回傳這個 AlwaysFailingHTTPClient

275
00:10:33,200 --> 00:10:35,733
這是一個非常簡單的實現

276
00:10:35,733 --> 00:10:37,333
這就是一個 HTTPClient 

277
00:10:37,333 --> 00:10:40,533
它總是立刻失敗，就是這樣，所以

278
00:10:40,533 --> 00:10:41,433
如果我們通過這個

279
00:10:41,433 --> 00:10:44,300
離線連接性標記，我們可以假設一個

280
00:10:44,300 --> 00:10:45,100
離線

281
00:10:45,100 --> 00:10:48,133
軟件。讓我們運行這個測試，它

282
00:10:48,133 --> 00:10:49,100
應該會失敗

283
00:10:49,100 --> 00:11:01,833
因為我們還沒處理 cache

284
00:11:01,833 --> 00:11:04,133
這就是它，cache中沒有任何東西

285
00:11:04,133 --> 00:11:05,100
那就是說

286
00:11:05,100 --> 00:11:07,100
所以當我們預期有 22 個 cells 時

287
00:11:07,100 --> 00:11:08,533
實際上有 0 個

288
00:11:08,533 --> 00:11:10,866
現在為了讓這個通過，我們需要組合

289
00:11:10,866 --> 00:11:12,533
遙端與本地

290
00:11:12,533 --> 00:11:18,000
loaders。讓我們導入 Core Data

291
00:11:18,000 --> 00:11:21,500
讓我們實例化本地 loaders

292
00:11:21,500 --> 00:11:25,033
現在我們可以像之前一樣組合他們

293
00:11:25,033 --> 00:11:35,033
讓我們再次運行測試

294
00:11:35,033 --> 00:11:37,833
好的，它通過了。因此，我們正在控制

295
00:11:37,833 --> 00:11:39,100
連接性狀態

296
00:11:39,100 --> 00:11:42,466
應用程序的狀態。是的，這是

297
00:11:42,466 --> 00:11:44,366
重要的理解

298
00:11:44,366 --> 00:11:48,133
通過運行一個離線的應用程序

299
00:11:48,133 --> 00:11:51,500
這意味著我們已經有了緩存

300
00:11:51,500 --> 00:11:54,866
從線上版本的途徑

301
00:11:54,866 --> 00:11:58,133
的應用程式就是這樣

302
00:11:58,133 --> 00:12:00,633
這個測試有兩個步驟我們 

303
00:12:00,633 --> 00:12:02,300
有連接的情況下啟動它並且我們 

304
00:12:02,300 --> 00:12:04,633
再次在無連接的情況下啟動它 

305
00:12:04,633 --> 00:12:07,666
我們期望已經將網上應用的結果緩存了

306
00:12:07,666 --> 00:12:10,000
並在應用程式中顯示它

307
00:12:10,000 --> 00:12:10,700
並顯示了出來 

308
00:12:10,700 --> 00:12:12,133
從緩存中的離線 

309
00:12:12,133 --> 00:12:14,066
應用程式真棒 

310
00:12:14,066 --> 00:12:16,800
而這些都只是非常高級的測試只

311
00:12:16,800 --> 00:12:17,500
檢測 

312
00:12:17,500 --> 00:12:20,066
了越少越好的細節 可能的

313
00:12:20,066 --> 00:12:22,133
你在高級測試中進行的越多細節

314
00:12:22,133 --> 00:12:22,866
測試

315
00:12:22,866 --> 00:12:25,900
將會越脆弱並且速度較慢 

316
00:12:25,900 --> 00:12:28,366
所以你要限制那個而且既然我們

317
00:12:28,366 --> 00:12:30,800
已經在獨立的單元測試中測試了細節 

318
00:12:30,800 --> 00:12:33,200
讓我們專注於高級的

319
00:12:33,200 --> 00:12:34,000
細節極好讓我們提交 

320
00:12:34,000 --> 00:12:38,066
所以在客戶無連接時顯示緩存的啟動畫面

321
00:12:38,066 --> 00:12:41,100
那不過如此所以一旦客戶

322
00:12:41,100 --> 00:12:43,100
無連接時會顯示緩存的啟動畫面

323
00:12:43,100 --> 00:12:45,900
就是說所以如果

324
00:12:45,900 --> 00:12:47,500
客戶沒有連接呢？

325
00:12:47,500 --> 00:12:50,366
並且沒有緩存，所以在這種情況下，我們

326
00:12:50,366 --> 00:12:51,033
應該顯示

327
00:12:51,033 --> 00:12:54,633
一個空的 feed，所以在啟動時顯示

328
00:12:54,633 --> 00:12:56,466
當客戶沒有

329
00:12:56,466 --> 00:12:59,266
連接性和無緩存時顯示空的 feed

330
00:12:59,266 --> 00:13:02,233
所以如果我們載入該應用程式時處於

331
00:13:02,233 --> 00:13:03,733
離線連接性

332
00:13:03,733 --> 00:13:06,933
我們應該有0個 cell，因為我們

333
00:13:06,933 --> 00:13:08,800
沒有像我們在這裡所做的那樣先前啟動過應用程式

334
00:13:08,800 --> 00:13:09,333
在這裡

335
00:13:09,333 --> 00:13:12,300
有連接性，因此它應該

336
00:13:12,300 --> 00:13:12,800
沒有任何東西

337
00:13:12,800 --> 00:13:18,700
在緩存中，讓我們執行測試

338
00:13:18,700 --> 00:13:23,033
並且它失敗了，所以我們預期擁有

339
00:13:23,033 --> 00:13:27,033
0個cell，但我們有22個

340
00:13:27,033 --> 00:13:30,233
那是因為我們之前在其他測試中已加載過了

341
00:13:30,233 --> 00:13:33,266
在其他測試中對吧

342
00:13:33,266 --> 00:13:36,066
所以，其中一個測試將某些東西加入到

343
00:13:36,066 --> 00:13:37,200
緩存中

344
00:13:37,200 --> 00:13:39,600
並且這在應用程序中是持久化的

345
00:13:39,600 --> 00:13:40,300
穿越

346
00:13:40,300 --> 00:13:42,800
啟動次數，所以這些測試並不

347
00:13:42,800 --> 00:13:43,833
是獨立的

348
00:13:43,833 --> 00:13:46,933
前一個測試改變了下一個測試的結果

349
00:13:46,933 --> 00:13:50,000
這是危險的，我們

350
00:13:50,000 --> 00:13:51,733
希望我們的測試是獨立的

351
00:13:51,733 --> 00:13:53,900
所以它們可以自己運行，或者以任何

352
00:13:53,900 --> 00:13:55,900
順序運行，否則它們就會變得不穩定

353
00:13:55,900 --> 00:13:58,800
它們是脆弱的，每個測試都應該是

354
00:13:58,800 --> 00:14:00,233
獨立的

355
00:14:00,233 --> 00:14:02,000
對，這就是側效應的定義

356
00:14:02,000 --> 00:14:04,133
這裡一項測試

357
00:14:04,133 --> 00:14:06,933
影響另一項測試的執行和結果

358
00:14:06,933 --> 00:14:08,133
這是確定的，所以我們需要重置狀態

359
00:14:08,133 --> 00:14:11,266
對於這個測試，我們可以通過傳遞

360
00:14:11,266 --> 00:14:13,666
另一個旗標來實現

361
00:14:13,666 --> 00:14:15,733
這就是面向用戶的測試的一個缺點

362
00:14:15,733 --> 00:14:17,900
它非常依賴狀態，並且具有

363
00:14:17,900 --> 00:14:20,300
大量的側效應，它們在整個

364
00:14:20,300 --> 00:14:22,933
應用程式之間持續存在

365
00:14:22,933 --> 00:14:24,000
每次啟動應用程式，您都可能

366
00:14:24,000 --> 00:14:26,933
有來自上一個測試的狀態，我們需要

367
00:14:26,933 --> 00:14:27,833
給一些指示

368
00:14:27,833 --> 00:14:30,466
讓應用程式能夠清除它的狀態

369
00:14:30,466 --> 00:14:31,600
為我們

370
00:14:31,600 --> 00:14:34,000
因為從用戶介面測試的角度

371
00:14:34,000 --> 00:14:34,800
我們無法訪問到任何

372
00:14:34,800 --> 00:14:36,800
應用程式的內部細節

373
00:14:36,800 --> 00:14:39,100
因此，我們不能訪問任何

374
00:14:39,100 --> 00:14:41,433
應用程式的內部細節


375
00:14:41,433 --> 00:14:44,133
這就是為什麼它被稱為黑盒測試

376
00:14:44,133 --> 00:14:45,166
確切的

377
00:14:45,166 --> 00:14:47,733
你只能從外部訪問它，就像

378
00:14:47,733 --> 00:14:49,166
客戶會做的

379
00:14:49,166 --> 00:14:53,166
所以如果我們傳遞一個重設啟動參數

380
00:14:53,166 --> 00:14:55,333
我們可以在我們的 Scene 中調查它

381
00:14:55,333 --> 00:14:57,166
Delegate

382
00:14:57,166 --> 00:15:01,100
所以如果 CommandLine 參數

383
00:15:01,100 --> 00:15:04,700
包含 -reset

384
00:15:04,700 --> 00:15:07,666
我們將刪除本地儲存店鋪

385
00:15:07,666 --> 00:15:08,366
所以它將會

386
00:15:08,366 --> 00:15:11,166
清空 cache 和 CommandLine

387
00:15:11,166 --> 00:15:13,266
參數是另外一種獲得方式

388
00:15:13,266 --> 00:15:16,533
在這種情況下的啟動參數，由於

389
00:15:16,533 --> 00:15:18,366
reset 沒有值，我們可以只是

390
00:15:18,366 --> 00:15:19,433
調查它

391
00:15:19,433 --> 00:15:21,733
這個參數被傳遞。但如果你關注

392
00:15:21,733 --> 00:15:22,866
關於值的話

393
00:15:22,866 --> 00:15:26,066
你可以使用用戶默認值助手

394
00:15:26,066 --> 00:15:28,233
它可以將值轉換為字符串

395
00:15:28,233 --> 00:15:30,933
布爾值，整數，等等

396
00:15:30,933 --> 00:15:33,600
好，現在讓我們運行這個，它應該

397
00:15:33,600 --> 00:15:34,000
會通過

398
00:15:34,000 --> 00:15:36,000
因為現在我們正在重設狀態

399
00:15:36,000 --> 00:15:38,133
並且它應該沒有 cache

400
00:15:38,133 --> 00:15:40,233
如果它沒有連接性和沒有

401
00:15:40,233 --> 00:15:43,733
快取應該顯示一個空的動態消息

402
00:15:43,733 --> 00:15:47,266
和它現在通過的一樣棒

403
00:15:47,266 --> 00:15:51,033
讓我們提交「顯示空的動態消息」

404
00:15:51,033 --> 00:15:53,833
當客戶沒有連接性和沒有

405
00:15:53,833 --> 00:15:54,866
快取

406
00:15:54,866 --> 00:15:58,800
就這樣好了

407
00:15:58,800 --> 00:16:01,266
所以這個測試與其他的每一個

408
00:16:01,266 --> 00:16:03,900
都是獨立的，因為它重置了狀態

409
00:16:03,900 --> 00:16:05,433
但其他的測試沒有重置

410
00:16:05,433 --> 00:16:06,933
狀態，這意味著他們可能會

411
00:16:06,933 --> 00:16:08,466
受前一個

412
00:16:08,466 --> 00:16:11,333
測試運行的影響，我們不希望這樣，所以讓我們

413
00:16:11,333 --> 00:16:12,800
確保也要重置

414
00:16:12,800 --> 00:16:16,066
每一個測試的狀態，所以在這種情況下

415
00:16:16,066 --> 00:16:19,100
當我們運行在線應用，我們希望

416
00:16:19,100 --> 00:16:21,100
重置狀態

417
00:16:21,100 --> 00:16:23,100
但我們不希望在

418
00:16:23,100 --> 00:16:25,266
離線應用程序啟動時重置狀態

419
00:16:25,266 --> 00:16:27,333
否則我們將刪除在在線應用中建立的快取

420
00:16:27,333 --> 00:16:29,666
正確，所以這個測試仍然是獨立的

421
00:16:29,666 --> 00:16:32,233
因為第一次啟動

422
00:16:32,233 --> 00:16:33,333
重置了所有東西，並從一個

423
00:16:33,333 --> 00:16:35,500
清潔的狀態開始

424
00:16:35,500 --> 00:16:37,433
乾淨的狀態

425
00:16:37,433 --> 00:16:39,733
且最後來讓第一個也

426
00:16:39,733 --> 00:16:40,466
重置

427
00:16:40,466 --> 00:16:42,066
確保未有共享的

428
00:16:42,066 --> 00:16:44,366
測試狀態

429
00:16:44,366 --> 00:16:48,000
讓我們運行所有的測試

430
00:16:48,000 --> 00:16:50,533
你可能已經注意到這些

431
00:16:50,533 --> 00:16:51,266
測試很慢

432
00:16:51,266 --> 00:16:54,000
他們需要重複地啟動應用程式

433
00:16:54,000 --> 00:16:54,800
屢次屢次地

434
00:16:54,800 --> 00:17:01,433
一次又一次

435
00:17:01,433 --> 00:17:05,833
但它成功了，讓我們提交

436
00:17:05,833 --> 00:17:08,466
在每次測試運行時重置緩存

437
00:17:08,466 --> 00:17:10,700
確保測試在乾淨的狀態下運行

438
00:17:10,700 --> 00:17:12,700
並且不影響其他的

439
00:17:12,700 --> 00:17:13,900
測試結果

440
00:17:13,900 --> 00:17:16,933
所以這些測試都是獨立的，你可以以任何順序運行他們

441
00:17:16,933 --> 00:17:18,633
你可以運行所有測試或只運行

442
00:17:18,633 --> 00:17:20,633
一個單獨的測試

443
00:17:20,633 --> 00:17:21,833
並且它應該無論如何都能通過

444
00:17:21,833 --> 00:17:25,666
好的，所以這正在運行， 但我們增加了測試

445
00:17:25,666 --> 00:17:28,233
代碼

446
00:17:28,233 --> 00:17:29,100
在生產中，對

447
00:17:29,100 --> 00:17:32,633
該SceneDelegate現在就是

448
00:17:32,633 --> 00:17:34,700
生產代碼

449
00:17:34,700 --> 00:17:36,300
它有一些測試邏輯，我們不希望

450
00:17:36,300 --> 00:17:39,566
將測試代碼佈署上去，因為你甚至可以

451
00:17:39,566 --> 00:17:39,833
有安全

452
00:17:39,833 --> 00:17:42,766
部署測試代碼，因為你甚至可能會遇到

453
00:17:42,766 --> 00:17:43,833
安全問題

454
00:17:43,833 --> 00:17:46,400
例如，這可能對惡意的

455
00:17:46,400 --> 00:17:48,533
使用者啟動您的應用程式並且帶有

456
00:17:48,533 --> 00:17:51,500
參數並控制應用程式的狀態有所影響

457
00:17:51,500 --> 00:17:52,633
這可以導致問題，所以我們不希望

458
00:17:52,633 --> 00:17:54,933
這段程式碼

459
00:17:54,933 --> 00:17:55,666
在生產環境中

460
00:17:55,666 --> 00:17:58,833
只有在我們正在進行測試時才會出現

461
00:17:58,833 --> 00:18:02,066
但由於我們正在使用 UI 測試

462
00:18:02,066 --> 00:18:05,433
即黑箱測試，我們不能控制

463
00:18:05,433 --> 00:18:07,833
像是連線性或緩存的狀態等事情

464
00:18:07,833 --> 00:18:09,433
從測試的角度來看，我們需要

465
00:18:09,433 --> 00:18:10,466
注入這段程式碼

466
00:18:10,466 --> 00:18:12,766
至生產環境中，所以我們應該至少

467
00:18:12,766 --> 00:18:14,066
在此處加入

468
00:18:14,066 --> 00:18:16,300
一些編譯指令以防止

469
00:18:16,300 --> 00:18:18,133
此程式碼被部署

470
00:18:18,133 --> 00:18:20,933
至生產環境中，所以我們可以將其用

471
00:18:20,933 --> 00:18:22,533
編譯指令包圍起來

472
00:18:22,533 --> 00:18:25,500
if debug，所以這段程式碼只會

473
00:18:25,500 --> 00:18:27,600
被加入到在測試或者在調試配置中運行的程式碼中

474
00:18:27,600 --> 00:18:29,200
例如當您正在進行測試

475
00:18:29,200 --> 00:18:32,300
或者在調試配置中運行它

476
00:18:32,300 --> 00:18:34,766
現在，如果您想要在

477
00:18:34,766 --> 00:18:35,600
生產環境中運行 UI 測試

478
00:18:35,600 --> 00:18:36,633
您需要建立自己的app

479
00:18:36,633 --> 00:18:38,866
例如，您可以建立

480
00:18:38,866 --> 00:18:40,066
一个 if 測試

481
00:18:40,066 --> 00:18:41,833
您可以在生產環境中設定

482
00:18:41,833 --> 00:18:43,266
建構配置

483
00:18:43,266 --> 00:18:46,066
所以，所有测试代码都应在

484
00:18:46,066 --> 00:18:47,333
編譯指令之間

485
00:18:47,333 --> 00:18:49,333
防止它在

486
00:18:49,333 --> 00:18:51,100
生產環境中被部署

487
00:18:51,100 --> 00:18:53,200
所以在這種情況下，我們可以將

488
00:18:53,200 --> 00:18:54,233
switch 語句用

489
00:18:54,233 --> 00:18:57,666
if 來代替並且我們的

490
00:18:57,666 --> 00:19:01,266
fake HTTPClient 同樣可以這樣做，所以現在至少

491
00:19:01,266 --> 00:19:02,933
這部分代碼不會被部署在

492
00:19:02,933 --> 00:19:04,233
生產環境中

493
00:19:04,233 --> 00:19:12,300
所以讓我們跑測試

494
00:19:12,300 --> 00:19:15,433
好的，通過了測試

495
00:19:15,433 --> 00:19:19,100
讓我們進行提交並添加

496
00:19:19,100 --> 00:19:22,133
if debug 編譯指令來

497
00:19:22,133 --> 00:19:22,866
預防

498
00:19:22,866 --> 00:19:25,833
測試特定代碼被部署

499
00:19:25,833 --> 00:19:26,933
在生產環境中

500
00:19:26,933 --> 00:19:30,133
就這樣，但我們仍然露着

501
00:19:30,133 --> 00:19:32,533
所有这些编译器标志和测试

502
00:19:32,533 --> 00:19:33,900
代碼

503
00:19:33,900 --> 00:19:35,600
是的，並且這仍然是一個小

504
00:19:35,600 --> 00:19:37,900
應用程序，隨著我們添加更多功能

505
00:19:37,900 --> 00:19:39,500
想象它將如何擴展和

506
00:19:39,500 --> 00:19:41,333
變成一個超級無法維護的

507
00:19:41,333 --> 00:19:45,200
充滿編譯器指令的混亂

508
00:19:45,200 --> 00:19:47,833
測試代碼生產代碼，對，而且

509
00:19:47,833 --> 00:19:49,200
這就是與

510
00:19:49,200 --> 00:19:52,233
黑盒測試基本上的問題

511
00:19:52,233 --> 00:19:54,133
如果你需要有任何形式的控制

512
00:19:54,133 --> 00:19:56,000
來測試一些邊緣案例

513
00:19:56,000 --> 00:19:59,100
你需要在生產中插入代碼

514
00:19:59,100 --> 00:20:00,533
並由於我們不想將此

515
00:20:00,533 --> 00:20:02,866
代碼部署到您的客戶端，所以您需要添加

516
00:20:02,866 --> 00:20:04,533
所有這些標記

517
00:20:04,533 --> 00:20:06,700
但是我們有其他方法可以做到這一點

518
00:20:06,700 --> 00:20:07,833
以消除

519
00:20:07,833 --> 00:20:11,033
生產代碼中的這種噪音，所以

520
00:20:11,033 --> 00:20:13,433
所有這些if debug標記

521
00:20:13,433 --> 00:20:16,766
可以移到另一個類中

522
00:20:16,766 --> 00:20:21,266
所以我們可以建立一個debugging的

523
00:20:21,266 --> 00:20:25,600
SceneDelegate，好

524
00:20:25,600 --> 00:20:28,766
這個類是一個次類

525
00:20:28,766 --> 00:20:31,100
是SceneDelegate的次類，然後我們可以加

526
00:20:31,100 --> 00:20:32,766
入所有的debugging邏輯

527
00:20:32,766 --> 00:20:36,400
到這個子類型中，所以我們正在擴大

528
00:20:36,400 --> 00:20:38,066
SceneDelegate

529
00:20:38,066 --> 00:20:41,200
並將debug邏輯移動到新的

530
00:20:41,200 --> 00:20:43,200
DebuggingSceneDelegate

531
00:20:43,200 --> 00:20:46,866
確實如此，我們可以複製這段程式碼

532
00:20:46,866 --> 00:20:51,266
到我們的DebuggingSceneDelegate中

533
00:20:51,266 --> 00:20:54,466
去覆蓋掉

534
00:20:54,466 --> 00:20:55,333
super class

535
00:20:55,333 --> 00:20:57,666
SceneDelegate的功能並且我們可以移除所有

536
00:20:57,666 --> 00:20:59,600
我們不需要的部分

537
00:20:59,600 --> 00:21:02,700
並且只保留可以偵錯的程式碼，所以在這

538
00:21:02,700 --> 00:21:04,400
個案例中我們只需保留

539
00:21:04,400 --> 00:21:07,500
重設邏輯，並且我們將

540
00:21:07,500 --> 00:21:10,633
信息傳達到 super class，是的

541
00:21:10,633 --> 00:21:12,533
我喜歡這個，然後我們也可以

542
00:21:12,533 --> 00:21:16,866
覆蓋掉遠程客戶端

543
00:21:16,866 --> 00:21:20,133
假如我們獲取了連接性引數

544
00:21:20,133 --> 00:21:22,133
我們將它替換為總是失敗的

545
00:21:22,133 --> 00:21:24,300
客戶端，否則我們將使用 super

546
00:21:24,300 --> 00:21:27,333
的實現

547
00:21:27,333 --> 00:21:30,866
所以我們需要在 super class 中公開本地儲存URL

548
00:21:30,866 --> 00:21:34,233
和製作遠程

549
00:21:34,233 --> 00:21:34,866
客戶端

550
00:21:34,866 --> 00:21:38,000
同樣也是

551
00:21:38,000 --> 00:21:39,833
所以製作遠程客戶端現在需要

552
00:21:39,833 --> 00:21:41,500
內部izable

553
00:21:41,500 --> 00:21:45,033
我們可以將偵錯程式碼移除

554
00:21:45,033 --> 00:21:47,833
我們也可以從

555
00:21:47,833 --> 00:21:49,200
這裡移除偵錯程式碼

556
00:21:49,200 --> 00:21:51,433
我們只需將本地儲存

557
00:21:51,433 --> 00:21:54,700
URL公開


558
00:21:54,700 --> 00:21:56,866
最後我們將總是失敗的

559
00:21:56,866 --> 00:22:02,466
客戶端也移動

560
00:22:02,466 --> 00:22:05,733
讓我們導入EssentialFeed

561
00:22:05,733 --> 00:22:07,666
就這樣，我們將所有的除錯

562
00:22:07,666 --> 00:22:09,433
邏輯移到一個新的類別

563
00:22:09,433 --> 00:22:12,466
只在除錯時使用，確實

564
00:22:12,466 --> 00:22:15,266
現在我們甚至可以將整個類別包裹在

565
00:22:15,266 --> 00:22:15,500
一個

566
00:22:15,500 --> 00:22:18,533
如果有除錯編譯指令的話

567
00:22:18,533 --> 00:22:20,866
就是這樣，所以這仍然是只存在於

568
00:22:20,866 --> 00:22:21,833
僅在構建除錯時存在的代碼

569
00:22:21,833 --> 00:22:24,400
但它包含在

570
00:22:24,400 --> 00:22:26,700
它自己的文件裡，它自己的類別裡

571
00:22:26,700 --> 00:22:29,833
所以SceneDelegate很乾淨，只有

572
00:22:29,833 --> 00:22:31,833
生產代碼

573
00:22:31,833 --> 00:22:34,300
然而，現在我們需要告訴我們的

574
00:22:34,300 --> 00:22:35,100
應用程式

575
00:22:35,100 --> 00:22:37,900
在除錯模式下使用DebuggingSceneDelegate

576
00:22:37,900 --> 00:22:39,200
除錯模式

577
00:22:39,200 --> 00:22:42,400
我們可以在AppDelegate裡做這件事

578
00:22:42,400 --> 00:22:44,700
剛好，應用程式代理將會是

579
00:22:44,700 --> 00:22:45,500
決策者

580
00:22:45,500 --> 00:22:47,733
決定它應該選擇哪個SceneDelegate

581
00:22:47,733 --> 00:22:48,533
選擇

582
00:22:48,533 --> 00:22:51,100
的確，如果我們實現了

583
00:22:51,100 --> 00:22:53,200
連接的設定

584
00:22:53,200 --> 00:22:56,066
場景會話，我們就有機會

585
00:22:56,066 --> 00:22:56,533
創建


586
00:22:56,533 --> 00:22:59,033
我們自己的配置並取代

587
00:22:59,033 --> 00:23:00,133
delegate class

588
00:23:00,133 --> 00:23:03,033
場景配置，所以如果我們

589
00:23:03,033 --> 00:23:04,400
有一個調試版本

590
00:23:04,400 --> 00:23:06,933
我們將使用 DebugScene

591
00:23:06,933 --> 00:23:08,133
Delegate

592
00:23:08,133 --> 00:23:10,133
否則，就使用預設值

593
00:23:10,133 --> 00:23:12,233
你的 Info.plist 中設定的

594
00:23:12,233 --> 00:23:16,066
在我們的案例中，就是 SceneDelegate

595
00:23:16,066 --> 00:23:17,733
所以，這是一種更潔淨的

596
00:23:17,733 --> 00:23:19,266
容納這個

597
00:23:19,266 --> 00:23:22,233
論述或測試邏輯與您的

598
00:23:22,233 --> 00:23:24,000
生產代碼

599
00:23:24,000 --> 00:23:37,433
確實，所以讓我們運行測試

600
00:23:37,433 --> 00:23:40,466
仍舊通過，太棒了

601
00:23:40,466 --> 00:23:43,666
讓我們提交移動除錯

602
00:23:43,666 --> 00:23:46,700
代碼路徑從主 SceneDelegate

603
00:23:46,700 --> 00:23:49,100
至新的 DebuggingSceneDelegate

604
00:23:49,100 --> 00:23:50,300
子類別

605
00:23:50,300 --> 00:23:52,933
以區分除錯和測試專用

606
00:23:52,933 --> 00:23:53,733
代碼

607
00:23:53,733 --> 00:23:57,100
從生產代碼中。就是這樣

608
00:23:57,100 --> 00:23:59,600
我真的很喜歡這種分離 情景 

609
00:23:59,600 --> 00:24:01,500
Delegate 保持清潔

610
00:24:01,500 --> 00:24:04,233
不帶有任何調試代碼，我們已經

611
00:24:04,233 --> 00:24:05,333
提取

612
00:24:05,333 --> 00:24:09,333
任何測試相關的代碼到它自己的地方

613
00:24:09,333 --> 00:24:11,200
確切地說，我們有很多權衡

614
00:24:11,200 --> 00:24:13,333
當使用黑盒測試時，因為我們

615
00:24:13,333 --> 00:24:14,000
需要具備

616
00:24:14,000 --> 00:24:17,033
在生產目標中的測試代碼，但至少

617
00:24:17,033 --> 00:24:18,933
我們可以從生產二進制中剝離該代碼

618
00:24:18,933 --> 00:24:20,300
並且還可以使用我們自己的

620
00:24:22,466 --> 00:24:23,666
子類來進行區隔

621
00:24:23,666 --> 00:24:26,066
因此，至少你可以將壞處限制在

622
00:24:26,066 --> 00:24:29,033
一個集中的地方

623
00:24:29,033 --> 00:24:30,400
我們還可以做一件事來

624
00:24:30,400 --> 00:24:32,866
提升使用者介面測試的效能

625
00:24:32,866 --> 00:24:34,700
到目前為止，我們正在檢查我們是否有

626
00:24:34,700 --> 00:24:36,133
加載22個

627
00:24:36,133 --> 00:24:38,400
訊息單元，並且我們至少加載了第一個

628
00:24:38,400 --> 00:24:39,600
圖片，但問題是我們正在從

629
00:24:39,600 --> 00:24:41,900
遠端的伺服器加載這些內容，這是個

630
00:24:41,900 --> 00:24:42,633
從遠端

631
00:24:42,633 --> 00:24:45,433
從伺服器加載的，我們無法控制的伺服器

632
00:24:45,433 --> 00:24:46,233
我們有

633
00:24:46,233 --> 00:24:48,933
對它沒有任何的控制權。如果明天該

634
00:24:48,933 --> 00:24:50,233
伺服器開始回傳

635
00:24:50,233 --> 00:24:53,266
23個，或者50個，或者100個

636
00:24:53,266 --> 00:24:56,466
或者0個呢？如果伺服器停機呢？

637
00:24:56,466 --> 00:24:57,500
如果你沒有網路的情況下呢？

638
00:24:57,500 --> 00:24:59,733
在你運行測試時的連接

639
00:24:59,733 --> 00:25:01,500
所以所有這些問題可能導致你的

640
00:25:01,500 --> 00:25:03,266
測試失敗

641
00:25:03,266 --> 00:25:05,666
所以這個測試是不穩定的，它不能獨自通過

642
00:25:05,666 --> 00:25:07,433
它依賴於一些外部的

643
00:25:07,433 --> 00:25:08,233
系統

644
00:25:08,233 --> 00:25:11,033
處於你預期的特定狀態

645
00:25:11,033 --> 00:25:12,400
所以這是脆弱的

646
00:25:12,400 --> 00:25:13,900
理想情況下，我們應該能夠運行這個

647
00:25:13,900 --> 00:25:16,133
測試一次又一次，永遠

648
00:25:16,133 --> 00:25:16,466
得到

649
00:25:16,466 --> 00:25:19,333
相同的結果，我們想要減少並

650
00:25:19,333 --> 00:25:20,233
消除

651
00:25:20,233 --> 00:25:23,733
不穩定性，所以我們需要解耦我們的UI

652
00:25:23,733 --> 00:25:24,300
測試

653
00:25:24,300 --> 00:25:27,333
與特定後端，我們已經

654
00:25:27,333 --> 00:25:29,100
有一種機制可以做到這一點

655
00:25:29,100 --> 00:25:31,333
我們可以讓應用程序處於離線狀態，我們

656
00:25:31,333 --> 00:25:32,633
也可以告訴應用程序

657
00:25:32,633 --> 00:25:35,100
處於在線狀態並有一些預設的

658
00:25:35,100 --> 00:25:36,133
回應

659
00:25:36,133 --> 00:25:37,900
因此，我們不需要網絡

660
00:25:37,900 --> 00:25:40,000
連接，或者它不會依賴

661
00:25:40,000 --> 00:25:41,033
伺服器

662
00:25:41,033 --> 00:25:44,000
狀態，因為我們已經測試了與伺服器的

663
00:25:44,000 --> 00:25:45,733
端到端通信


664
00:25:45,733 --> 00:25:48,233
在API整合測試中，我們不需要

665
00:25:48,233 --> 00:25:49,266
再次進行這種測試

666
00:25:49,266 --> 00:25:52,466
在UI測試中，UI測試不應該測試

667
00:25:52,466 --> 00:25:54,866
低階的細節，你應該測試高

668
00:25:54,866 --> 00:25:55,500
階級的

669
00:25:55,500 --> 00:25:58,066
接受標準，所以我們需要去

670
00:25:58,066 --> 00:25:58,766
控制

671
00:25:58,766 --> 00:26:01,433
針對網路

672
00:26:01,433 --> 00:26:02,466
的狀態

673
00:26:02,466 --> 00:26:05,033
而我們可以通過傳入

674
00:26:05,033 --> 00:26:06,300
連接性

675
00:26:06,300 --> 00:26:09,100
例如在線，並有些

676
00:26:09,100 --> 00:26:10,300
預設的

677
00:26:10,300 --> 00:26:12,700
回應為此，所以當我們只是

678
00:26:12,700 --> 00:26:14,533
測試時我們能獲得一個可靠的

679
00:26:14,533 --> 00:26:17,500
結果，現在我們有個地方能做到這點

680
00:26:17,500 --> 00:26:19,500
那就是DebuggingSceneDelegate

681
00:26:19,500 --> 00:26:23,600
所以如果設置了連接性

682
00:26:23,600 --> 00:26:26,466
我們就以此創建我們的HTTPClient

683
00:26:26,466 --> 00:26:28,300
連接性

684
00:26:28,300 --> 00:26:29,900
所以我們應該改名這個

685
00:26:29,900 --> 00:26:31,833
因為它不再總是失敗了

686
00:26:31,833 --> 00:26:34,300
它取決於連接性引數

687
00:26:34,300 --> 00:26:35,666
所以測試

688
00:26:35,666 --> 00:26:39,333
HTTPClient

689
00:26:39,333 --> 00:26:41,600
並且現在依靠連接性

690
00:26:41,600 --> 00:26:42,866
狀態我們可以

691
00:26:42,866 --> 00:26:46,133
返回一些預定義的回應

692
00:26:46,133 --> 00:26:49,033
所以在線連接狀態下我們

693
00:26:49,033 --> 00:26:49,833
完成

694
00:26:49,833 --> 00:26:52,066
用成功的反應對於給定的

695
00:26:52,066 --> 00:26:53,500
URL

696
00:26:53,500 --> 00:26:57,433
否則我們會完結且帶有離線錯誤

697
00:26:57,433 --> 00:27:01,733
好的，所以創建成功的反應給 URL

698
00:27:01,733 --> 00:27:04,533
它創建一個 HTTP URL 反應狀態

699
00:27:04,533 --> 00:27:05,200
200

700
00:27:05,200 --> 00:27:08,633
成功並且我們創建數據給 URL

701
00:27:08,633 --> 00:27:11,500
如果這是圖片請求，我們創建

702
00:27:11,500 --> 00:27:12,300
一些假的

703
00:27:12,300 --> 00:27:16,466
圖片數據，就只是一張紅色的圖片

704
00:27:16,466 --> 00:27:18,366
否則我們返回提供的數據

705
00:27:18,366 --> 00:27:20,866
反應，就只是一個含有 2

706
00:27:20,866 --> 00:27:22,866
項目的JSON

707
00:27:22,866 --> 00:27:24,700
所以我們只需改變我們的測試去

708
00:27:24,700 --> 00:27:26,366
預期 2

709
00:27:26,366 --> 00:27:29,600
項目而不是 22 但我們可以使用

710
00:27:29,600 --> 00:27:30,000
3

711
00:27:30,000 --> 00:27:33,200
4，5 或者我們想要的數量

712
00:27:33,200 --> 00:27:35,333
現在讓我們運行這些測試並且它應該

713
00:27:35,333 --> 00:27:37,033
運行並且順利通過，而不做

714
00:27:37,033 --> 00:27:39,100
任何網絡請求，一切都是

715
00:27:39,100 --> 00:27:40,533
獨立的

716
00:27:40,533 --> 00:27:43,600
看，它載入了紅色圖片

717
00:27:43,600 --> 00:27:49,833
我們在 DebuggingHTTPClient 中創建的

718
00:27:49,833 --> 00:27:52,933
過關了，所以那些測試並不依賴

719
00:27:52,933 --> 00:27:55,733
在伺服器狀態或網路

720
00:27:55,733 --> 00:27:56,633
連接性

721
00:27:56,633 --> 00:27:58,933
狀態上，它們變得更為

722
00:27:58,933 --> 00:28:00,366
可靠

723
00:28:00,366 --> 00:28:02,533
它們不會因為外部

724
00:28:02,533 --> 00:28:03,500
系統

725
00:28:03,500 --> 00:28:06,533
而出錯，我們可以一再地

726
00:28:06,533 --> 00:28:06,933
運行這個測試

727
00:28:06,933 --> 00:28:09,733
並總是得到相同的結果，對

728
00:28:09,733 --> 00:28:11,500
那很棒

729
00:28:11,500 --> 00:28:15,200
讓我們提交 intercept

730
00:28:15,200 --> 00:28:18,133
利用預設的回應來攔截 HTTP 請求

731
00:28:18,133 --> 00:28:19,600
在 UI 測試中

732
00:28:19,600 --> 00:28:22,633
以消除網路的不穩定性

733
00:28:22,633 --> 00:28:25,433
我們現在可以在無網路的情況下進行 UI 測試

734
00:28:25,433 --> 00:28:26,700
連線

735
00:28:26,700 --> 00:28:30,000
好極了，沒錯

736
00:28:30,000 --> 00:28:32,066
我們正在執行這些 UI 測試，儘管

737
00:28:32,066 --> 00:28:33,900
傳統上這些都是非常不穩定的，但我們

738
00:28:33,900 --> 00:28:35,100
創建了一個非常

739
00:28:35,100 --> 00:28:38,633
可靠的解決方案，因為我們控制

740
00:28:38,633 --> 00:28:42,133
基礎設施狀態和網路

741
00:28:42,133 --> 00:28:44,766
我們只測試高層次

742
00:28:44,766 --> 00:28:45,433
細節

743
00:28:45,433 --> 00:28:48,133
我們並不檢查 cell 中的

744
00:28:48,133 --> 00:28:48,933
值

745
00:28:48,933 --> 00:28:51,100
文本和這樣的東西，所有這些

746
00:28:51,100 --> 00:28:52,366
事情已經被測試過

747
00:28:52,366 --> 00:28:55,433
無論是獨立的單元測試

748
00:28:55,433 --> 00:28:58,700
或是整合的 UI 測試

749
00:28:58,700 --> 00:29:00,633
他們實際運行應用程序時，他們應該

750
00:29:00,633 --> 00:29:02,866
只測試高級別的接受標準

751
00:29:02,866 --> 00:29:06,000
現在來確保

752
00:29:06,000 --> 00:29:08,466
你在UI中沒有進行太多的模擬

753
00:29:08,466 --> 00:29:09,033
測試中

754
00:29:09,033 --> 00:29:11,666
你只應該替換基礎設施

755
00:29:11,666 --> 00:29:12,633
細節

756
00:29:12,633 --> 00:29:15,900
例如 HTTPClient

757
00:29:15,900 --> 00:29:17,600
我們並不改變應用程序

758
00:29:17,600 --> 00:29:19,900
的行為，我們一直保持

759
00:29:19,900 --> 00:29:22,766
當前的行為，我們添加

760
00:29:22,766 --> 00:29:23,900
功能

761
00:29:23,900 --> 00:29:27,200
當進行調試的時候，例如我們會重設

762
00:29:27,200 --> 00:29:29,733
緩存狀態，這不影響

763
00:29:29,733 --> 00:29:30,533
應用程序

764
00:29:30,533 --> 00:29:32,866
的功能，以及替換

765
00:29:32,866 --> 00:29:34,633
HTTPClient並不影響

766
00:29:34,633 --> 00:29:36,633
應用程序的功能

767
00:29:36,633 --> 00:29:39,733
確實，我們依然使用 SceneDelegate

768
00:29:39,733 --> 00:29:42,700
因為我們正在給它繼承並使用

769
00:29:42,700 --> 00:29:44,133
調試子類

770
00:29:44,133 --> 00:29:46,766
在測試中，整個組成是

771
00:29:46,766 --> 00:29:47,666
相同的

772
00:29:47,666 --> 00:29:50,133
我們替換的唯一事情是

773
00:29:50,133 --> 00:29:50,866
基礎設施

774
00:29:50,866 --> 00:29:53,733
結構，HTTPClient，這是

775
00:29:53,733 --> 00:29:54,533
關鍵

776
00:29:54,533 --> 00:29:59,266
你不想模擬或者替換業務邏輯

777
00:29:59,266 --> 00:30:02,366
只替換基礎設施細節

778
00:30:02,366 --> 00:30:05,500
例如網絡客戶端，這就是你要做的

779
00:30:05,500 --> 00:30:07,100
保持對於

780
00:30:07,100 --> 00:30:10,233
你正在測試你的真實應用的信心

781
00:30:10,233 --> 00:30:11,900
我們有這種信心，因為我們

782
00:30:11,900 --> 00:30:14,066
有API的端到端測試

783
00:30:14,066 --> 00:30:16,233
直接與後端進行對話所以我們

784
00:30:16,233 --> 00:30:17,500
不需要再次測試此項目

785
00:30:17,500 --> 00:30:20,700
使用UI測試，我們只測試

786
00:30:20,700 --> 00:30:22,300
高級驗收標準

787
00:30:22,300 --> 00:30:24,633
通過黑箱，這就是你

788
00:30:24,633 --> 00:30:25,900
進行UI測試

789
00:30:25,900 --> 00:30:29,266
可靠性的情況，但是還有一個問題

790
00:30:29,266 --> 00:30:30,366
與UI測試有關

791
00:30:30,366 --> 00:30:34,000
他們超級超級超級慢

792
00:30:34,000 --> 00:30:37,033
多麼慢，讓我們來看看

793
00:30:37,033 --> 00:30:40,700
它需要29.8秒來運行

794
00:30:40,700 --> 00:30:43,900
3個測試對吧

795
00:30:43,900 --> 00:30:47,433
30秒做3項測試，每一個10秒

796
00:30:47,433 --> 00:30:49,666
每一個測試的意思是你不會

797
00:30:49,666 --> 00:30:51,500
經常運行這些測試

798
00:30:51,500 --> 00:30:53,333
你可能只在

799
00:30:53,333 --> 00:30:54,533
CI上

800
00:30:54,533 --> 00:30:56,866
是的，否則你的

801
00:30:56,866 --> 00:30:59,266
產能會非常低，如果你經常運行它們

802
00:30:59,266 --> 00:31:01,833
是的，我們添加的功能越多，

803
00:31:01,833 --> 00:31:02,366
越來越

804
00:31:02,366 --> 00:31:05,500
這將會不斷增長，所以非常常見

805
00:31:05,500 --> 00:31:08,466
UI測試要花5分鐘，10

806
00:31:08,466 --> 00:31:09,200
分鐘

807
00:31:09,200 --> 00:31:12,466
30分鐘，幾個小時去跑，這就是我們

808
00:31:12,466 --> 00:31:12,933
希望

809
00:31:12,933 --> 00:31:16,066
減少UI測試數量的理由，

810
00:31:16,066 --> 00:31:16,766
只有少數的

811
00:31:16,766 --> 00:31:19,333
超高水平的測試，只測試

812
00:31:19,333 --> 00:31:20,866
驗收標準

813
00:31:20,866 --> 00:31:22,700
所有詳細的應該在

814
00:31:22,700 --> 00:31:24,633
隔離的狀態下進行測試

815
00:31:24,633 --> 00:31:27,600
這些並不屬於你的Command+U

816
00:31:27,600 --> 00:31:28,366
流程中的一部分

817
00:31:28,366 --> 00:31:30,233
不，他們是在一個專門針對

818
00:31:30,233 --> 00:31:31,500
慢速測試的專案中

819
00:31:31,500 --> 00:31:34,533
這就是全部，你總是需要UI

820
00:31:34,533 --> 00:31:35,600
測試嗎？

821
00:31:35,600 --> 00:31:38,466
不是，但是如果你做，你需要讓他們

822
00:31:38,466 --> 00:31:39,833
越可靠越好

823
00:31:39,833 --> 00:31:43,266
同理，需要越快越好

824
00:31:43,266 --> 00:31:44,833
低階細節你可以在

825
00:31:44,833 --> 00:31:47,333
隔離的狀況下測試，並且只測試

826
00:31:47,333 --> 00:31:49,900
非常高水平的驗收標準

827
00:31:49,900 --> 00:31:51,200
通過UI測試

828
00:31:51,200 --> 00:31:53,600
如果需要，且你需要握有

829
00:31:53,600 --> 00:31:54,366
控制權於

830
00:31:54,366 --> 00:31:57,033
應用程式的任一部分，創建一個

831
00:31:57,033 --> 00:31:58,066
清晰的區隔

832
00:31:58,066 --> 00:32:00,233
在除錯程式碼或是

833
00:32:00,233 --> 00:32:01,100
測試程式碼

834
00:32:01,100 --> 00:32:05,600
與生產程式碼之間, 很棒

835
00:32:05,600 --> 00:32:07,600
就到這裡為止於這堂課

836
00:32:07,600 --> 00:32:08,700
我們下次會再見面

837
00:32:08,700 --> 00:32:22,466
下次再見各位, 再見了
