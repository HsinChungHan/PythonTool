

1
00:00:00,880 --> 00:00:10,000
大家好，歡迎參加。我們將繼續我們的工具篇，以及我們的Crashes和Crash

2
00:00:10,000 --> 00:00:19,280
報告的迷你系列，帶來一個實踐課程。希望這能為我們過去做過的講座

3
00:00:19,280 --> 00:00:27,360
在Crashes和Crash報告的理論部分上帶來更多的光明。我知道這可能是一個恐怖的話題。

4
00:00:27,360 --> 00:00:35,760
我還記得當我是一個初級開發者的時候，他很多次遭遇Crashes，每當有人

5
00:00:35,760 --> 00:00:41,520
把一個Crash指定給我，或者我不得不處理那個Crash，那就像一塊未知領地。所以

6
00:00:42,720 --> 00:00:49,920
為了解決這個問題，我們將其加入到課程中，我們已經進行了兩次關於更為

7
00:00:49,920 --> 00:00:56,320
理論的講座，比如什麼是應用終止，為什麼會發生，如何取得Crash報告，


8
00:00:56,320 --> 00:01:05,680
如何進行符號解析。所以你看到完整的回溯，而今天的講座著重於實踐

9
00:01:05,680 --> 00:01:16,560
這些常見於設備上的Crashes案例，以及如何應對這類情況。那麼，我們開始吧。

10
00:01:18,640 --> 00:01:25,520
今日的議程相當直接。我們將談論幾種類型的Crashes和

11
00:01:25,520 --> 00:01:30,640
如何應對它們，最後如果有問題，我們會進行問答環節。

12
00:01:36,640 --> 00:01:44,800
所以，第一種類型的Crash是Swift運行時Crash。現在許多應用程式都具有Swift程式碼

13
00:01:44,800 --> 00:01:53,120
其中，針對導致Crash的編程錯誤，Swift與Objective-C具有

14
00:01:53,120 --> 00:02:00,480
不同之處，因為在Objective-C中，不同的錯誤會導致不同類型的Crash，然而幾乎

15
00:02:00,480 --> 00:02:07,760
所有與Swift編程錯誤相關的錯誤將遵循相似的模式。

16
00:02:10,000 --> 00:02:15,040
所以，依據你的應用程式中有多少Swift程式碼，你會看到更多或是更少的這些訊息。

17
00:02:15,040 --> 00:02:24,080
Swift使用記憶體安全技術來早期捕捉編程錯誤，並且如果你使用像是一個

18
00:02:24,080 --> 00:02:32,000
強制解開一個可能有新值的選擇性型別，或者如果你使用了預測

19
00:02:32,000 --> 00:02:42,000
所以如果你把驚歎符號導向到一個錯誤的型別，那麼Swift程式運行時期將會捕捉這些錯誤並

20
00:02:42,000 --> 00:02:50,880
故意讓應用程式崩潰。實際上我已模擬如此的崩潰，我已模擬多個

21
00:02:51,440 --> 00:03:02,480
類型的崩潰，使用我們的EssentialApp儲藏庫，我們將稍微看一下他們，看看哪些

22
00:03:02,480 --> 00:03:07,440
不同的、特殊的每一種類型。所以對於這個，我們將要看的是

23
00:03:07,440 --> 00:03:12,480
看看有哪些不同、特殊的每一種類型。所以這第一種類型。

24
00:03:16,480 --> 00:03:24,240
像我剛剛說的，這些崩潰大多數都有個可以在崩潰報告中識別的模式

25
00:03:26,000 --> 00:03:33,840
因為在ARM處理器上，而ARM處理器在iOS、iPadOS、watchOS 和 tvOS上都有

26
00:03:33,840 --> 00:03:41,280
異常類型就是這個 XCBreakpoint，而信號就是 seek trap。所以

27
00:03:42,640 --> 00:03:47,360
當我們看到 XCBreakpoint 和 seek trap，我們很可能在看 Swift 的運行時崩潰。

28
00:03:52,000 --> 00:04:02,560
而在inter處理器上，這些是較舊的 Macs 和模擬器，我們將看到不同的

29
00:04:02,560 --> 00:04:08,160
我們將會看到不同的異常型態，那就是 XC bad instruction 和 sigil signal。

30
00:04:13,600 --> 00:04:15,120
現在，我們回到這個範例。

31
00:04:17,760 --> 00:04:22,080
此外，崩潰報告也顯示出遇到錯誤的線程

32
00:04:22,080 --> 00:04:34,320
而線程頂部的第一個框架將會顯示出罪魁禍首，或者是跑出錯誤的那一行。

33
00:04:34,320 --> 00:04:46,320
問題存在。在我們這裡，首四個也就是零到三都只是例外數字

34
00:04:46,320 --> 00:04:52,720
都只是例外數字，並且stack trace中的第一個函數調用

35
00:04:53,680 --> 00:04:58,160
在EssentialApp中是這個 Main View body gather

36
00:04:58,160 --> 00:05:02,560
以及Main View Swift 第11行，就是問題所在。

37
00:05:05,600 --> 00:05:13,920
是的，如我所說，此斷點異常類型的XCBreakpoint指示了一個追蹤陷阱

38
00:05:13,920 --> 00:05:20,560
該陷阱中斷了程序，並給於附著的除錯器在特定點上中斷的機會

39
00:05:20,560 --> 00:05:28,720
在其執行。Swift runtime 使用追蹤陷阱來針對特定

40
00:05:28,720 --> 00:05:36,160
對無法恢復的錯誤類型，因此一些較底層的庫，如dispatch 或其他

41
00:05:36,160 --> 00:05:42,800
在遇到無法恢復的錯誤時會以此異常來中斷程序，並且他們


42
00:05:42,800 --> 00:05:50,000
在崩潰報告的附加信息部分記錄有關錯誤的附加信息。

43
00:05:50,560 --> 00:05:57,840
在我們的案例中，這是我們在其中找到詳細錯誤的應用程式特定資訊部分

44
00:05:57,840 --> 00:06:05,680
關於崩潰的錯誤，所以在Main View.Swift的第11行，我們有一個致命錯誤

45
00:06:05,680 --> 00:06:11,440
在拆包一個可選值時意外地找到了nil，所以這非常清楚我們知道我們

46
00:06:11,440 --> 00:06:23,280 
正在強制展開一個為nil的選項。但這種具體的明確資訊

47
00:06:24,160 --> 00:06:30,720
像我在這裡展示的，都被從來自於iOS，iPadOS，

48
00:06:30,720 --> 00:06:37,920
watchOS 和 tvOS的崩潰報告中模糊化了，以保護用戶的隱私，所以你並不總是能看到這個

49
00:06:37,920 --> 00:06:45,440
額外的信息。所以試圖在你的模擬器中重現崩潰狀況是很有用的。

50
00:06:46,160 --> 00:06:50,400
因為那時你才能看到這些額外的信息。

51
00:06:56,720 --> 00:07:04,080
這裡有一些Result在Swift中導致這種類型崩潰的例子。第一個就是你剛剛看到的

52
00:07:04,080 --> 00:07:09,120
強制解包一個nil的可選項，沒什麽比一個nil的可選項更糟糕的了

53
00:07:09,120 --> 00:07:16,480
我們強制解包然後嘗試打印它，我相信你已經知道，它會崩潰。另一個例子

54
00:07:16,480 --> 00:07:24,240
是使用超出邊界的索引訪問陣列元素，所以如果我們有一個空的陣列

55
00:07:24,240 --> 00:07:32,240
並嘗試獲取索引一的元素，我們也會得到一個崩潰，同的簽名。還有一個例子

56
00:07:32,240 --> 00:07:38,720
是在一條可能會拋出異常的指令上使用強制嘗試，在這種情況下我們使用了

57
00:07:38,720 --> 00:07:45,040
JSONDecoder並嘗試從空數據中解碼成某物，這將很可能失敗。

58
00:07:49,680 --> 00:07:56,720
以及那些立即生成Crash、斷言失敗或者fatal Error的指令

59
00:07:56,720 --> 00:08:01,600
這裡的重點是，當你看到一個帶有異常類型XCBreakpoint的Crash並尋求

60
00:08:01,600 --> 00:08:10,480
trap作為信號或者對於交叉處理器的XC壞指令，高概率是來自於

61
00:08:10,480 --> 00:08:16,880
一個Swift runtime Error。所以只需檢查Crash Thread的backtrace，那應該

62
00:08:16,880 --> 00:08:22,880
給你確定的發生Error的函數和行。所以取決於真實的代碼

63
00:08:22,880 --> 00:08:30,720
在那一行你應該得到繼續進行的想法，比如使用E flat進行解包

64
00:08:30,720 --> 00:08:37,520
一個選項或添加一個catch區塊以避免強制嘗試等等。所以它真的

65
00:08:37,520 --> 00:08:54,000
取決於錯誤。接著我要談的是一種 Objective-C 的 Crash

66
00:08:54,960 --> 00:08:58,560
這是來自未捕獲的語言異常。

67
00:08:58,560 --> 00:09:08,080
所以這種 Crash 使用了 xccrash 訊息和 seek abort 訊號，並它指示進程

68
00:09:08,080 --> 00:09:14,240
因為接收到這個中止訊號而終止。這種訊號通常是因為進程中的一個功能

69
00:09:14,240 --> 00:09:22,240
調用了中止，例如當應用程式遇到未捕獲的 Objective-C 或 C++ 語言

70
00:09:22,240 --> 00:09:32,960
異常。再次，我們這裡有一個例子。所以像我說的，異常類型 xccrash seek abort

71
00:09:35,520 --> 00:09:40,720
以及由 OS 提供的未捕獲的異常處理器將異常訊息記錄到控制台

72
00:09:40,720 --> 00:09:46,720
在結束處理過程之前。所以如果你複製由語言異常引起的 Crash

73
00:09:46,720 --> 00:09:52,960
當Xcode偵錯器連接到你的應用程序時，你可以看到這條訊息。所以跟之前的例子一樣，

74
00:09:52,960 --> 00:09:59,760
有一些特定於應用程序的資訊，你只有在模擬器上才能看到，因為iOS、iPadOS以及其他平台都進行了混淆。你會看到確切的

75
00:09:59,760 --> 00:10:08,640
問題類型。所以這裡有一個未捕獲的異常終止類型為XC。所以你可以看到

76
00:10:09,360 --> 00:10:16,640
NSException，並且是一個NSRangeException，你可以非常清楚的看到試圖獲取超出

77
00:10:16,640 --> 00:10:27,200
空NSArray範圍的索引一的情況。所以再次非常明確。同樣地，由於語言異常導致的崩潰也是如此，

78
00:10:27,200 --> 00:10:34,880
它沒有被捕獲，並且有最後一個異常的回溯。所以如果你還記得我們的崩潰報告結構，

79
00:10:34,880 --> 00:10:45,040


80
00:10:45,040 --> 00:10:52,560
它們都有這個Thread crashed 和 stack，但對於那些有未捕獲的

81
00:10:52,560 --> 00:11:00,000
異常的，還有一個last exception backtrace，這將准確顯示導致

82
00:11:00,000 --> 00:11:07,760
異常的跟蹤。驗證這個backtrace是否存在以確認Crash確實來自於語言

83
00:11:07,760 --> 00:11:16,880
異常。如果我們看第一行，你可以看到exception pre process 和 obfuscate exception

84
00:11:16,880 --> 00:11:22,160
throw，所以我們真的確認我們正在觀察的是語言異常。

85
00:11:23,680 --> 00:11:33,520
並且調用該函數的行給我們提供了我們的代碼調用該方法的確切部分，該方法

86
00:11:33,520 --> 00:11:41,360
導致了異常。所以在我們的情況下，從我的class.m線11，我們有一個函數，這個函數

87
00:11:41,360 --> 00:11:46,720
我將其命名為指數自動界限異常的「Crash」。所以它非常清晰。然後我們看到了

88
00:11:47,440 --> 00:11:53,360
這個「Crash」發生在核心基礎內部，對一個NSArray物體的列舉器。

89
00:11:53,360 --> 00:12:04,000
列舉器。所以再次說明，這是直線而下。產生此「Crash」的代碼示例

90
00:12:04,000 --> 00:12:11,120
只是創建一個空的NSArray，然後再試圖訪問帶有索引的元素

91
00:12:11,120 --> 00:12:22,480
在這種情況下，自動界限索引為一。另一個例子是不實現所需的

92
00:12:22,480 --> 00:12:30,160
Protocol的方法，因為Objective-C是如此的動態語言，我們可以傳遞一個物件

93
00:12:30,880 --> 00:12:40,480
使用ID類型，然後將它轉換為Protocol類型。所以如果它缺少一個所需的方法來自

94
00:12:40,480 --> 00:12:51,040
那個Protocol，那我們就會遇到異常、未捕獲的異常「Crash」。這裡的要點是

95
00:12:51,040 --> 00:12:57,920
由Objective-C或C++未經剪輯的例外所引起的崩潰具有這個XC Crash和SIGABORT

96
00:12:59,680 --> 00:13:02,880
例外訊息。因此它們容易識別。

97
00:13:08,240 --> 00:13:16,320
接下來我們來談談看門狗崩潰。我已經提過幾次了，但這還不夠。

98
00:13:16,320 --> 00:13:23,920
所以iOS和watchOS都採用了一個觀察元件，這就是一個簡單的元件，僅僅監控

99
00:13:23,920 --> 00:13:29,040
啟動時間和應用程式響應性，並終止無響應的應用程式。

100
00:13:30,320 --> 00:13:35,520
當這種情況發生時，系統將產生一個崩潰報告。但請注意，無論是

101
00:13:35,520 --> 00:13:42,720
Apple收集崩潰報告的服務，還是像Firebase Crashlytics這樣的第三方服務，

102
00:13:42,720 --> 00:13:49,520
都不會收集和顯示這些看門狗崩潰。所以你需要直接獲取這些。

103
00:13:49,520 --> 00:13:55,360
如我在講座中所示，來自使用者的反饋，我已經說明如何獲取Crash報告。所以他們可以

104
00:13:55,360 --> 00:14:04,160
傳送給你Crash報告，但是沒有服務會收集這些watchdog的Crashes。所以

105
00:14:04,160 --> 00:14:13,040
Crashes所以他們有些在雷達下。要談論他們的特殊性，他們使用

106
00:14:13,040 --> 00:14:21,040
XC Crash Message和這次的SIGKILL。所以上次是SIGKILL。這是SIGKILL信號

107
00:14:21,040 --> 00:14:27,200
這表明作業系統終止了進程，並且Crash報告包含一個終止原因

108
00:14:27,200 --> 00:14:32,880
有一個代碼解釋了Crash的原因。而這個代碼可能有多個值，

109
00:14:32,880 --> 00:14:41,040
我們稍後會看到。如果這個代碼是8 bad food，那麼作業系統的watchdog就已經終止了這個應用程式。

110
00:14:42,960 --> 00:14:51,200
讓我們看一個例子。所以異常類型是 XC Crash 和 SIGKILL

111
00:14:53,440 --> 00:14:59,600
我們也會看到來自看門狗的大量信息。例如看門狗事件，

112
00:14:59,600 --> 00:15:06,880
看門狗的可見性，CPU 資料統計，你也會看到我提到的這段代碼，所以 8 個壞食物

113
00:15:08,800 --> 00:15:12,080
這是看門狗崩潰的明確。

114
00:15:19,200 --> 00:15:24,960
看門狗將終止那些長時間阻塞主線程的應用程式，有許多

115
00:15:24,960 --> 00:15:32,000
方法可以長時間阻塞主線程，例如同步網路，處理

116
00:15:32,000 --> 00:15:40,000
大量的數據，如大的 JSON 文件或 3D 模型，觸發輕量級移植

117
00:15:40,000 --> 00:15:47,440
對大型 CoreDataStore 的同步等等。為了了解為何阻塞主線程

118
00:15:47,440 --> 00:15:53,760
是一個問題，考慮這個最常見的例子。從同步數據裡讀取數據進入 UI.

119
00:15:53,760 --> 00:16:01,120
網路調用。如果主線程忙於這個網路調用，系統無法處理UI事件

120
00:16:01,120 --> 00:16:08,800
如多個滾動事件，直到完成網路調用。所以如果這個網路

121
00:16:08,800 --> 00:16:17,040
調用花費了太長的時間，用戶滾動你的UI到應用程序

122
00:16:17,040 --> 00:16:23,360
實際上回應這些滾動事件的時間會很長。我知道你已經在實踐中看到了，你

123
00:16:23,360 --> 00:16:32,160
知道這使得應用程序感覺真的很無回應。所有的看門狗Crashes都包含有關

124
00:16:32,160 --> 00:16:38,560
導致看門狗關閉應用程序的慢速應用程序狀態過渡的細節。你可以使用

125
00:16:38,560 --> 00:16:47,680
Crash Thread回蹤來看看誰是罪魁禍首。在我們的案例中，我們看到這是AppDelegate

126
00:16:47,680 --> 00:16:54,000
application did finish launching，一旦我們有了這些資訊，我們就可以使用Instruments來進行

127
00:16:54,000 --> 00:17:01,040
這個特別的情況下，時間分析器是完美的工具來檢查相同的應用程序轉換並理解為何

128
00:17:01,040 --> 00:17:08,560
它需要如此長的時間來執行，實際上在執行的是什麼。你可能會找到方法讓

129
00:17:08,560 --> 00:17:16,080
這些運程更快，但是有些情況下，例如进入network call，你需要

130
00:17:16,080 --> 00:17:21,280
可能只需要將耗時的工作移到後台Thread，並讓Main Thread可以

131
00:17:21,280 --> 00:17:28,880
處理UI手勢和UI更新。所以這也許就是你找的策略。

132
00:17:32,400 --> 00:17:38,640
所以，一個好的策略是從UI關鍵代理方法中盡快返回，因為

133
00:17:38,640 --> 00:17:44,160
它們在Main Thread上執行，我們希望能快速釋放Main Thread以處理這些

134
00:17:44,160 --> 00:17:51,040
UI事件和更新。這同樣適用於SceneDelegate AppDelegate方法調用，只需返回即可

135
00:17:51,040 --> 00:17:56,800
快速且將控制權交還給系統，避免任何可能需要較長時間的操作

136
00:17:57,760 --> 00:18:04,080
如網路呼叫、在此加載或寫入此處，執行重計算等。

137
00:18:06,000 --> 00:18:12,560
請記住，您在任何儀表板上都不會獲得這些watchdog崩潰，所以確保

138
00:18:12,560 --> 00:18:19,440
如果他們告訴你發生了這種情況，那麼就從您的測試人員那裡獲得它。同時你應該定期

139
00:18:19,440 --> 00:18:25,440
監控像您的應用啟動時間這樣的指標，並積極應對，嘗試改進它。

140
00:18:26,640 --> 00:18:33,280
除非你正在開發一個非常大的應用程序，否則你應該能夠在半秒內啟動你的應用程序

141
00:18:33,280 --> 00:18:45,440
這是Apple的建議，因此量測並嘗試將此保持在半秒內。接下來

142
00:18:46,880 --> 00:18:56,240
使用xccrash異常類型和SQL訊號的OS終止

143
00:18:56,240 --> 00:19:04,400
並且它指出OS終止了進程，並且Crash報告包含了一個終止原因

144
00:19:04,400 --> 00:19:12,080
欄位解釋了Crash的原因，就像我們之前看到的壞食品代碼一樣

145
00:19:12,080 --> 00:19:20,400
8個壞食品代碼之前，還有一些其他類型的代碼，您可能在這裡看到 

146
00:19:20,400 --> 00:19:27,680
所以你可能在這裡看到，讓我們來通過他們，以防你看到這個。

147
00:19:29,280 --> 00:19:37,360
首先，這個代碼，我只是閱讀你應該如何讀它，所以它很酷 

148
00:19:38,880 --> 00:19:44,800
並且操作系統由於熱事件中止了帶有此代碼的應用。

149
00:19:44,800 --> 00:19:49,760
這可能是此Crash發生的特定設備或環境的問題。

150
00:19:49,760 --> 00:20:00,400
操作的。死結。作業系統因應用程式保持文件鎖定或SQLite數據庫鎖定而在掛起期間終止該應用程式。

151
00:20:00,400 --> 00:20:08,080
或在掛起期間鎖定SQLite數據庫。您可以通過BeginBackgroundTask API在主線程上要求額外的背景執行時間。

152
00:20:08,080 --> 00:20:15,280
在主要線程上與 BeginBackgroundTask API。只需要確保在開始寫入文件之前請求此服務。

153
00:20:15,280 --> 00:20:25,280
開始寫入文件。當操作系統因應用程式未能回報通話套件呼叫以回應pushkit通知，所以被終止，這就叫做壞的呼叫。

154
00:20:25,280 --> 00:20:32,240
在回應pushkit通知時未能報告call Kit的調用，這是一種非常明確的情況。

155
00:20:32,240 --> 00:20:42,480
後面跟著五個2，這是發生在操作系統終止語音 over IP應用程式，因為它恢復的次數太多了。

156
00:20:42,480 --> 00:20:55,920
因為它恢復得太頻繁，有三個非常相似的代碼C51 bad 0 1 0 2 0 3，


157
00:20:55,920 --> 00:21:05,040
是專屬於watchOS的。所以在bad 0 1的情況下，如果watchOS因應用程式使用了

158
00:21:05,040 --> 00:21:14,880
太多CPU時間而在執行BackgroundTask時終止了該應用程式。而0 2與0 3的代碼也會在

159
00:21:14,880 --> 00:21:22,160
watchOS中收到，當應用程式無法在分配的時間內完成BackgroundTask。

160
00:21:22,160 --> 00:21:28,560
這裡的重點是您可以針對每種的異常代碼類型嘗試複現

161
00:21:28,560 --> 00:21:34,560
問題或只是理解為何您的應用程式會引起該類問題。所以例如如果

162
00:21:34,560 --> 00:21:39,680
你正在處理一個cool off Crash，你可以檢查後退軌跡看哪些函數正在使用大量的

163
00:21:39,680 --> 00:21:45,680
CPU時間並使用時間剖析器分析。對於Deadlock Crash，你可以使用

164
00:21:45,680 --> 00:21:52,000
回溯以理解哪個操作需要額外的背景執行並配置它

165
00:21:52,000 --> 00:22:00,640
等等。我只想提到，所有這些崩潰與我們剛才談到的watchdog Crash很相似

166
00:22:00,640 --> 00:22:07,600
我們剛才討論的，所以你需要用類似的方式處理它們。所以你需要監控並獲取

167
00:22:07,600 --> 00:22:14,000
他們明確地。所以如果你在處理一個cool off Crash，你可以嘗試重現該問題或者

168
00:22:14,000 --> 00:22:24,640
就明確地管理他們。所以下一種類型的Crash是由於

169
00:22:24,640 --> 00:22:31,440
另一個程序的要求而終止的程序，它使用xccrash異常類型和這次的seek quit信號。

170
00:22:33,440 --> 00:22:39,040
這表明該過程是應另一程序具有權限的要求而終止的。

171
00:22:39,040 --> 00:22:46,320
終生。所以尋求退出並不意味著進程崩潰，但它可能以一種可檢測的方式行為不當。

172
00:22:46,320 --> 00:22:54,400
方式。在iOS和iPadOS鍵盤擴展中，如果宿主應用終止了花了太長時間加載的鍵盤擴展

173
00:22:54,400 --> 00:23:04,240
那就是我在這裡準備的確切例子。所以異常類型 

174
00:23:04,240 --> 00:23:14,160
xccrash seek quit，這只是由於

175
00:23:15,920 --> 00:23:19,440
一個花了太長時間加載的鍵盤擴展而發生的Crash。

176
00:23:22,240 --> 00:23:24,960
所以主應用程序會終止該擴展。

177
00:23:24,960 --> 00:23:32,000
就像你從launchd看到的。

178
00:23:36,960 --> 00:23:44,400
另一種Crash類型是守衛資源違規Crash，這種異常類型就是 

179
00:23:44,400 --> 00:23:51,120
XC guard，這表示進程違反了被守衛的資源保護。

180
00:23:51,120 --> 00:23:57,520
雖然有多種類型的被守衛系統資源，但大多數被守衛資源Crashes

181
00:23:57,520 --> 00:24:04,880
來自受保護的 File descriptors，它們在異常子類型欄位中有 FD 值。

182
00:24:06,000 --> 00:24:11,840
如果你對 File descriptors 不熟悉，File descriptors 只是對

183
00:24:11,840 --> 00:24:17,520
輸入或輸出數據資源如 File 的抽象處理。換句話說，這是一種讓

184
00:24:17,520 --> 00:24:26,000
寫入或讀取自一個 File 的抽象化。OS 將 File descriptor 標記為受保護，所以正常的

185
00:24:26,000 --> 00:24:32,800
File descriptor API 無法修改它們。這是一種保護機制，讓誰打開了 File

186
00:24:32,800 --> 00:24:38,880
都可以保護它防止變化，所以它也要負責關閉它。而 guard

187
00:24:38,880 --> 00:24:44,400
File description 可以在問題發生時識別出這些問題，使得處理更易。

188
00:24:44,400 --> 00:24:49,040
異常訊息欄位含有特定的違規，這些可以被關閉，

189
00:24:49,040 --> 00:24:56,320
loop、File port、write等等。我將在演講文章中鏈接到一篇來自Apple的文檔頁面，

190
00:24:56,320 --> 00:25:02,000
理解崩潰報告中的異常類型，詳細介紹了這些違規行為。

191
00:25:02,000 --> 00:25:12,160
讓我們看一個例子。這次我只選擇了來自崩潰報告的異常信息，

192
00:25:12,160 --> 00:25:19,440
所以這是一個部分報告，因為我們只關心這四個字段。所以異常類型，

193
00:25:19,440 --> 00:25:25,280
XC guard，子型別guard type FD，這告訴我們我們正在處理一個

194
00:25:25,280 --> 00:25:33,680
FD File descriptor guard問題。如我們所說，異常訊息包含違規事項，

195
00:25:33,680 --> 00:25:42,000
那就是closed，我們還知道觸發這次崩潰的Thread number。所以我們知道

196
00:25:42,000 --> 00:25:48,400
去哪裡尋找，因為我們可以查詢崩潰Thread的backtrace，並看看問題在哪裡。

197
00:25:48,400 --> 00:25:55,920
來源於。接下來，另一種Crash來源於一個超出資源消耗限制的進程。

198
00:25:55,920 --> 00:26:04,080
他們使用XC資源異常類型，這是OS發出的一種通知，表明進程超出了它設定的資源消耗限制。

199
00:26:04,080 --> 00:26:12,240
所以異常類型就是OS發出的通知，表明進程超出了它設定的資源消耗限制。

200
00:26:12,240 --> 00:26:18,720
是來自操作系統的通知，表明進程超過了它設定的資源消耗限制。

201
00:26:22,320 --> 00:26:27,840
所以我們在這裡有幾個例子。再次強調，所有的異常類型都是XC資源異常類型。

202
00:26:29,600 --> 00:26:38,400
因為我們在這裡有三個不同部分的Crashes，如果異常節點，

203
00:26:38,400 --> 00:26:45,120
像在這個案例中包含了非致命條件，那麼即使操作系統產生了Crash報告，進程也不會終止。

204
00:26:45,120 --> 00:26:52,640
所以這更像是一種警告。異常訊息欄位。

205
00:26:54,720 --> 00:27:00,640
描述了在特定時間間隔內消耗的資源量。所以在第一種情況下

206
00:27:00,640 --> 00:27:13,760
是喚醒，於300秒的時間內大量的喚醒，或者在這種情況下是大量的CPU使用

207
00:27:14,560 --> 00:27:24,080
在180秒的時間框架內。與此同時，Crash report在異常
subtype中列出了特定的資源

208
00:27:24,080 --> 00:27:33,440
如你所見。所以是喚醒，CPU，內存。讓我們看看還可以有什麼其他的值。因此

209
00:27:34,240 --> 00:27:42,880
首先，CPU或CPU fatal意味著進程中的Thread在短時間內過度使用CPU。

210
00:27:44,560 --> 00:27:49,120
當過程超過系統強加的內存限制時，就會發生Memory。

211
00:27:49,120 --> 00:27:56,480
並且在我們收到這個警告之後，我們可能會看到因過度使用記憶體而終止，

212
00:27:56,480 --> 00:28:04,240
但也不一定。例如當行程導致短時間內硬碟寫入量明顯過多時，

213
00:28:04,240 --> 00:28:11,920
或者當該行程中的執行緒太頻繁地喚醒，這就會大量消耗電量。

214
00:28:11,920 --> 00:28:19,920
像是執行緒與執行緒之間的通信API，如"perform on Thread"或

215
00:28:19,920 --> 00:28:26,880
"async execute"或"dispatch async"，在不經意間被調用的次數遠超過預料，就會引發這種情況。

216
00:28:28,320 --> 00:28:32,800
由於觸發此異常的通信發生得如此頻繁，

217
00:28:33,840 --> 00:28:38,720
通常會有多個背景執行緒，其相似的回溯指示出

218
00:28:38,720 --> 00:28:47,040
執行緒通信的起源。所以這裡的要點是，每當你的應用程式正使用

219
00:28:47,040 --> 00:28:53,440
大量的某種資源時，您可能會看到這種類型的崩潰。所以說，XC Resource是非常具體的。

220
00:28:54,560 --> 00:29:02,160
你應該使用Instruments來檢查你的CPU使用量，記憶體使用量並嘗試

221
00:29:02,160 --> 00:29:11,280
改善它。現在談談記憶體訪問問題。這是一種有趣的崩潰類別，因為你會

222
00:29:11,280 --> 00:29:19,200
時常看到。由於記憶體訪問問題發生的崩潰，當應用程式以意想不到的

223
00:29:19,200 --> 00:29:26,320
方法使用記憶體時。記憶體訪問問題有許多原因，如解引用到無效的

224
00:29:26,320 --> 00:29:32,480
記憶體地址，寫入唯讀記憶體，或跳到一個無效的

225
00:29:32,480 --> 00:29:39,200
地址等等。你會在生產中遇到很多Crashes，特別是來自Objective-C的

226
00:29:39,200 --> 00:29:48,080
與記憶體訪問問題相關的Crashes。這些Crashes最常由XC來識別

227
00:29:48,080 --> 00:29:57,760
bad access exception類型和SIG SEGV信號標示，代表了分段違規。

228
00:29:57,760 --> 00:30:10,480
或是SIG巴士訊號。讓我們看一個例子。你會看見XC壞的存取段的例外類型 

229
00:30:10,480 --> 00:30:18,400
violation以及例外子類型欄位蘊含一個描述錯誤的值和

230
00:30:18,400 --> 00:30:25,600
被非正確存取的記憶體的地址。所以在這種情況下一個無效的核心地址在這個地址

231
00:30:26,320 --> 00:30:34,080
並且有幾種類型的例外子類型。讓我們看看它們是什麼。首先，我們剛剛

232
00:30:34,080 --> 00:30:43,440
看到的。非法地址。當崩潰的緒存取未映射的記憶體。然後一個保護

233
00:30:43,440 --> 00:30:49,040
失敗發生在崩潰的緒試圖使用受保護的有效記憶體地址。

234
00:30:49,920 --> 00:30:58,560
這可能是唯讀的或非可執行的記憶體區域。然後是當記憶體錯誤發生時，


235
00:30:58,560 --> 00:31:04,240
線程試圖訪問當時無法返回數據的內存，例如內存映射的文件

236
00:31:04,240 --> 00:31:12,800
那就變得無法訪問了。最後是ARMDA對齊，當崩潰線程

237
00:31:12,800 --> 00:31:18,880
試圖訪問未正確對齊的內存時就會發生。一旦你確定崩潰報告

238
00:31:18,880 --> 00:31:26,800
是因為內存訪問問題，所以你已經認出了"bad access"異常，然後你必須要

239
00:31:26,800 --> 00:31:33,040
認出異常"bad access"異常類型, 你可以用Xcode來繼續你的調查。

240
00:31:34,160 --> 00:31:39,280
因為Xcode包含了一套調試工具, 你可以用來識別內存訪問問題

241
00:31:39,280 --> 00:31:50,480
當你的應用運行時。所以對於這, 讓我們進入Xcode並且我將使用scheme editor。

242
00:31:50,480 --> 00:31:55,680
確保選擇了運行動作，然後打開診斷面板。

243
00:31:57,920 --> 00:32:03,760
這裡有幾個工具在測試時非常有效。所以我們有地址

244
00:32:03,760 --> 00:32:08,800
sanitizer，威脅 sanitizer 或者未定義行為 sanitizer。

245
00:32:11,120 --> 00:32:18,160
我建議你一次只啟用一個 sanitizer，因為他們每一個都需要大量的記憶體

246
00:32:18,160 --> 00:32:23,680
和 CPU 來產生他們的結果。然後只需將此工具啟用並運行該應用程序，然後去

247
00:32:23,680 --> 00:32:30,480
檢視你想要檢查的場景，並嘗試檢查並修復他們回報的所有問題至

248
00:32:30,480 --> 00:32:40,640
你。另一個選擇是，如果你有很多的 objective cc 或 c++ 的程式碼，有一個靜態分析器

249
00:32:40,640 --> 00:32:52,080
你可以在產品菜單的分析操作中運行。再次查看它發現的問題

250
00:32:52,080 --> 00:32:58,720
並嘗試解決他們所有，因為靜態分析器在構建時間分析你的程式碼和


251
00:32:58,720 --> 00:33:04,080
將辨識常見的程式設計錯誤，包括某些類型的記憶體管理問題。

252
00:33:04,080 --> 00:33:11,280
所以這是一種可以定期進行的好的驗證。

253
00:33:17,040 --> 00:33:20,240
常見的記憶體存取崩潰類型是僵屍崩潰。

254
00:33:21,840 --> 00:33:27,680
一旦一個Objective-C或Swift對象不再有任何強引用，該對象就會

255
00:33:27,680 --> 00:33:35,040
被移除。試圖在此之後向該對象發送消息，好像它仍然是一個有效的

256
00:33:35,040 --> 00:33:43,520
對象，會導致崩潰。接收消息的對象被稱為僵屍對象。最可能的

257
00:33:43,520 --> 00:33:51,520
僵屍原因是使用不安全的引用，但任何使用不安全的記憶體都可能導致僵屍產生。

258
00:33:51,520 --> 00:33:57,040
Swift和Objective-C都支持這種類型的引用，所以在兩種語言中僵屍都是

259
00:33:57,040 --> 00:34:09,280
可能的話，在Swift它們被命名為unowned與unowned unsafe。所以是unowned和unowned unsafe，而在

260
00:34:09,280 --> 00:34:21,600
Objective-C中，它們是帶有assign specifier或者unsafe unretained specifier的屬性。

261
00:34:21,600 --> 00:34:28,320
讓我們舉個例子。假設我們有一個ViewController類別，並且它有一個weak Delegate。

262
00:34:29,120 --> 00:34:33,440
因為它是weak，所以View control並不持有對它的強引用，

263
00:34:33,440 --> 00:34:39,920
所以如果沒有其他類別保留對它的參照，Delegate將被釋放。這就是為什麼它

264
00:34:39,920 --> 00:34:45,680
需要是optional，因為如果Delegate被釋放，則該屬性將自動設定

265
00:34:45,680 --> 00:34:51,680
為nil。這是最安全的選擇，因為編譯器強制我們處理情況可能發生的場合，

266
00:34:51,680 --> 00:34:57,600
Delegate已被釋放，所以我們需要安全地拆封optional以確保其包含一個

267
00:34:57,600 --> 00:35:06,720
對Delegate的引用。到目前為止一切進行得很順利。現在讓我們看另一個情況。有一點微妙的變化

268
00:35:06,720 --> 00:35:13,280
我們並未使用 weak 而是使用 unowned。像 weak一樣，unowned 不會持有一個強參照

269
00:35:13,280 --> 00:35:21,680
但它不是一個選項，所以這段程式碼的安全性稍低。如果沒有人再持有對Delegate的引用

270
00:35:21,680 --> 00:35:28,000
它將被釋放，但在這種情況下，如果我們試圖訪問已被釋放的實例，程式將會停止運行

271
00:35:28,000 --> 00:35:40,480
立即。最後，最不安全的情況是使用unowned unsafe。在

272
00:35:40,480 --> 00:35:47,920
Objective-C 在自動參照數之前，這是非常常見的，所以你可能會使用舊的系統 Objective-C類別那

273
00:35:47,920 --> 00:35:55,680
宣告unowned unsafe屬性。unowned unsafe與unowned相像，它不持有強烈的

274
00:35:55,680 --> 00:36:06,000
引用，但有很大的差別。讓我們解釋這個。讓我們說，我們在記憶體地址 1, 2, 3, 4, 5 分配了 my Delegate

275
00:36:06,000 --> 00:36:14,480
但過一陣子，沒有人再持有對它的引用，

276
00:36:14,480 --> 00:36:21,360
所以在這種情況下，該實例將被釋放，該記憶體地址與1, 2, 3, 4, 5

277
00:36:21,360 --> 00:36:25,840
將可以用於分配其他實例，因為記憶體被回收。

278
00:36:27,520 --> 00:36:34,720
但我們仍然有一個unowned unsafe屬性，仍然引用1, 2, 3, 4, 5

279
00:36:34,720 --> 00:36:41,440
地址，而且因為它是不安全的，這將不會自動清理並設置為空。

280
00:36:41,440 --> 00:36:47,440
稍後系統可能會在相同的地址處分配另一個對象，例如一個NSString，

281
00:36:48,480 --> 00:36:55,200
然後我們嘗試通過該未擁有的引用向Delegate發送訊息，所以讓我們說

282
00:36:55,200 --> 00:37:02,400
Delegate方法存在於我的Delegate中，但實際上由於我的Delegate不再存在於

283
00:37:02,400 --> 00:37:08,400
1，2，3，4，5地址，但是改為有一個NSString在那裡，NSString將會收到這

284
00:37:08,400 --> 00:37:17,200
我的Delegate方法訊息，這是一個大問題，因為最可能的是NSString不能

285
00:37:17,200 --> 00:37:25,200
回應我們發送給Delegate的這些訊息，因此它將不會按照我們預期的方式行為，我們會遇到一個

286
00:37:25,200 --> 00:37:33,760
崩潰的原因是NSString無法響應我的委託方法選擇器，你可能會想

287
00:37:33,760 --> 00:37:39,920
但我從來沒有向NSString發送這個消息，這怎麼可能？ 好吧，你並沒有直接發送，

288
00:37:39,920 --> 00:37:49,200
但是因為內存被回收，所以如果對內存進行不安全的訪問，這就可能會發生，

289
00:37:49,200 --> 00:38:00,160
這就是zombie（殭屍）Crash如何發生的，如果發生zombie Crash，你會看到這樣的例外，

290
00:38:00,160 --> 00:38:09,360
你會看到一個結束時的態度對於onCaughtException 和我之前顯示的無法識別的選擇器，

291
00:38:09,360 --> 00:38:18,960
你會看到如類別和接收到的消息的原因，但是任何對不安全內存的使用

292
00:38:18,960 --> 00:38:26,000
都可能導致zombie，這是來自zombie Crash的另一個Crash報告例子，

293
00:38:26,000 --> 00:38:35,200
再次的，遇到EXC_BAD_ACCESS與SIGSEGV訊號，我們也將會看到終止原因為區段錯誤

294
00:38:37,200 --> 00:38:45,680
如果你檢查崩潰線程的回溯，你將會看到在最後一行

295
00:38:45,680 --> 00:38:54,240
EssentialApp是其中的一個類，然後有一個objcMessageSend，這是一個明確的指標

296
00:38:54,240 --> 00:39:02,720
認定崩潰是由於一個殭屍對象，所以如果你曾經看到objcMessageSend或objcRetain

297
00:39:02,720 --> 00:39:07,760
或objcRelease位在回溯的最頂部，你就正在處理一個殭屍物件

298
00:39:10,080 --> 00:39:19,040
並且要處理殭屍物件，在方案編輯器旁邊的淨化器，我展示了一個

299
00:39:19,040 --> 00:39:27,120
殭屍對象診斷工具，這將會非常幫助你處理並找到你應用程式中的殭屍物件。

300
00:39:28,880 --> 00:39:35,760
因為這會讓你的應用程式在一個不會釋放任何對象的不同環境中運行

301
00:39:35,760 --> 00:39:42,240
對象不會被釋放，相反地，他們會成為僵屍並持續存在，

302
00:39:42,240 --> 00:39:48,320
所以如果你對一個應該被釋放掉的僵屍對象傳送訊息，應用程式就會

303
00:39:48,320 --> 00:39:54,480
崩潰並精確地顯示出問題在哪裡，因為當你正在處理僵屍時，

304
00:39:54,480 --> 00:40:01,360
問題在於你不知道誰分配了原始對象，那麼該對象怎麼就

305
00:40:01,360 --> 00:40:09,600
不再存在，所以當你使用這個僵屍對象選項時，情況會變得非常明確，因為

306
00:40:09,600 --> 00:40:15,120
工具會停止執行，你能查找該對象的所有參考並

307
00:40:15,120 --> 00:40:24,960
看看內存問題在哪裡，同時，為了診斷記憶體存取崩潰，你可以使用

308
00:40:24,960 --> 00:40:34,000
guard malloc選項也像是一種淨化器，它會審查所有的記憶體分配

309
00:40:34,000 --> 00:40:51,760
我想要講解的另一種崩潰類型是由於缺失庫造成的崩潰，這使用的是

310
00:40:51,760 --> 00:40:58,320
exe Crash Message類型和sigaboard信號，如果一個app因為它缺少一個

311
00:40:58,320 --> 00:41:05,760
所需的框架或庫而崩潰，崩潰報告會包含這個異常代碼，讓我們看一個例子

312
00:41:07,600 --> 00:41:09,520
所以exe Crash sigaboard

313
00:41:12,880 --> 00:41:19,440
你會在崩潰報告中找到一個終止描述，識別出具體的框架

314
00:41:19,440 --> 00:41:28,640
動態連接器無法定位的，所以在我們的案例中，庫未載入，Cocoa Lumberjack

315
00:41:30,000 --> 00:41:32,640
還有在應用特定的資訊中也是

316
00:41:34,240 --> 00:41:39,360
所以我們看到這個框架 Cocoa Lumberjack無法被系統找到

317
00:41:42,720 --> 00:41:49,040
要解決這個問題，你需要做幾件事，首先你需要確保那個library

318
00:41:49,040 --> 00:41:54,640
存在，然後你需要確保它包含在framework搜索路徑和

319
00:41:54,640 --> 00:42:00,160
library搜索路徑中，並且它包含了你的應用程序使用的所有架構

320
00:42:00,160 --> 00:42:03,440
所以它可能是這些問題中的一種

321
00:42:08,320 --> 00:42:14,320
嗯，我在聊天室裡看到一個問題，所以Vital正在問，因為我可以理解它關注的

322
00:42:14,320 --> 00:42:25,200
僅針對動態libraries，是的，所以這確實是一個只與動態加載有關的問題，因為

323
00:42:25,760 --> 00:42:32,080
當你使用靜態libraries或靜態frameworks時，它們在編譯時就會被連接，所以

324
00:42:32,720 --> 00:42:37,200
它們不會在運行時從另一個模塊中單獨加載

325
00:42:37,200 --> 00:42:42,960
所以，如果你有動態libraries或者動態frameworks，你可能會看到這個問題

326
00:42:46,320 --> 00:42:55,520
接下來，另一種特殊的Crash類型是jetsum，jetsum與記憶體壓力相關

327
00:42:55,520 --> 00:43:04,080
iOS、iPad OS、watchOS和tvOS的事件都有一個依賴所有應用程式的虛擬記憶體系統

328
00:43:04,080 --> 00:43:08,160
當作業系統遇到記憶體壓力時，釋放記憶體

329
00:43:09,200 --> 00:43:14,560
當可用記憶體少，系統無法滿足所有正在執行的應用程式的需求時

330
00:43:15,760 --> 00:43:20,800
因此，在記憶體壓力下，應用程式釋放記憶體並接收到低記憶體通知

331
00:43:22,080 --> 00:43:27,120
在執行的應用程式釋放足夠的總記憶體以減輕壓力之前，您的應用程式將繼續

332
00:43:27,120 --> 00:43:33,680
減輕壓力，你的APP將繼續運行，但如果記憶體壓力持續，因為應用程式

333
00:43:33,680 --> 00:43:38,720
並未放棄足夠的記憶體，系統通過結束應用程式釋放記憶體

334
00:43:38,720 --> 00:43:45,920
並回收他們的記憶體，這就是所謂的jetsum事件，系統會建立一個jetsum事件

335
00:43:45,920 --> 00:43:52,880
報告擁有關於為何選擇丟棄一個應用程式的信息，並我們可以看到一個實例

336
00:43:52,880 --> 00:43:58,720
首先，您會注意到 jetsum 事件報告與崩潰報告不同，因為它們包含

337
00:43:58,720 --> 00:44:04,800
所有應用與系統程序在設備中的整體記憶體，且他們是 JSON 格式

338
00:44:05,760 --> 00:44:13,520
它們沒有任何回朔資訊，僅列出所有流程及他們的記憶體

339
00:44:13,520 --> 00:44:23,200
腳印和其他類型的信息，我們很快就能看到，如果系統因記憶體壓力丟棄你的應用

340
00:44:23,200 --> 00:44:28,240
在應用程式可見的情況下，對用戶來說它就像你的應用程式崩潰了

341
00:44:29,040 --> 00:44:35,280
並且使用 jetsum 事件報告來識別你的應用程式在 jetsum 事件中的角色，即使你的應用程式

342
00:44:35,280 --> 00:44:39,040
並未被丟棄，可能是另一個應用程式被丟棄


343
00:44:39,040 --> 00:44:46,240
在此需要牢記的重要一點是，jetsum事件以及watchdog crashes並未被

344
00:44:46,240 --> 00:44:54,240
Apple服務或第三方服務收集，因此你需要確保直接從

345
00:44:54,800 --> 00:44:58,560
你的用戶那裡獲得這些資訊，因此最可靠的是你的內部用戶。

346
00:45:00,160 --> 00:45:05,520
你的測試人員和你的其他團隊，所以你需要確保直接從你的

347
00:45:05,520 --> 00:45:13,440
用戶、你的測試人員以及你其他的團隊成員那裡獲得這些資訊，回到這個Crash report的結構，

348
00:45:14,240 --> 00:45:21,360
你會看到一開始有一些資訊，像是Crash report、queue以及類似的Crashes，

349
00:45:22,240 --> 00:45:31,120
還包含了一些有關內存頁面的資訊，如多少頁面、有多少可用頁面、有線等

350
00:45:31,120 --> 00:45:37,440
你也會看到在我的情況下，佔用最大的進程是webkit web content。

351
00:45:38,400 --> 00:45:41,840
如果是你的app，你需要減少你的app的內存使用量

352
00:45:45,360 --> 00:45:53,040
一個 jetsum 事件也包含一個過程的數組，如你在這裡所見，數組中的每個項目

353
00:45:53,040 --> 00:46:01,760
描述系統中的一個單獨過程，這樣你可以搜索原因鍵來識別

354
00:46:01,760 --> 00:46:08,000
被 jettison 的過程以及系統為何終止它，因為只有被 jettison 的過程

355
00:46:08,000 --> 00:46:15,280
有原因鍵，如果是你的app，原因鍵的值解釋了導致

356
00:46:15,280 --> 00:46:22,880
jettison 事件的條件，你可以通過相乘來確定每個app使用的記憶體量

357
00:46:22,880 --> 00:46:37,840
r頁的數量與每頁的大小，這在這裡可以看到基本大小，所以在這裡我們

358
00:46:37,840 --> 00:46:49,600
處理16千字節的頁面，例如這個進程正在使用299個頁面，所以你可以做這個

359
00:46:49,600 --> 00:46:56,960
數學並看看它消耗了多少記憶體，另外我想提到的是，這個流程中的每一項

360
00:46:56,960 --> 00:47:03,840
Array都有一些鍵，這些鍵會給你一些額外的資訊，所以UUID是

361
00:47:03,840 --> 00:47:16,080
二進制檔案的構建標識符，並有一個Array顯示當前的記憶體使用狀態，如記憶體

362
00:47:16,080 --> 00:47:24,480
由最前面的應用程式、暫停或不活躍使用記憶體的情況，一個lifetime max是最高的

363
00:47:24,480 --> 00:47:31,760
的在進程期間分配的記憶體頁的數量，記憶體的聯合使用

364
00:47:31,760 --> 00:47:39,120
聯合使用對於如果你的應用的進程是一個包含其他的聯盟會很有用

365
00:47:39,120 --> 00:47:47,680
系統處理過程代表您的應用程式進行工作，如冠有該名稱的擴充功能是進程

366
00:47:47,680 --> 00:47:54,240
此處的名稱對應您的應用程式中的一個二進制檔案，或屬於另一個應用程式或系統進程

367
00:47:55,920 --> 00:48:01,360
由於jetsem事件是高記憶體使用的事件，因此建議您應常常

368
00:48:01,360 --> 00:48:07,200
確認您的應用程式像一個好公民那樣利用記憶體，或者避免大記憶體的尖峰

369
00:48:07,200 --> 00:48:12,720
分配並在不再需要時釋放記憶體，您可以使用這個記憶體

370
00:48:12,720 --> 00:48:18,240
在Xcode中的檢查器，或者某些像活動監視器這樣的儀器，這將給你一個

371
00:48:18,240 --> 00:48:23,280
對您的應用程式的總記憶體消耗的高級概念，然後你可以使用分配

372
00:48:23,280 --> 00:48:32,560
工具來深入瞭解並確切看到那些記憶體是如何分配的，以及哪些功能或部分原因

373
00:48:32,560 --> 00:48:41,680
佔用大部分記憶體和更多信息以降低您的應用程序的記憶體使用確保

374
00:48:41,680 --> 00:48:46,800
您接收到系統發出的低記憶體警告，並且您正在對這些警告採取行動

375
00:48:46,800 --> 00:48:53,520
因為這是您唯一可以保護自己不被系統

376
00:48:53,520 --> 00:48:59,120
射出的方式，如果系統發給您一個訊息，說設備的記憶體狀況不足，並要求您釋放

377
00:48:59,120 --> 00:49:05,280
記憶體，如果您不釋放記憶體，您將最可能被終止，所以試著回應這些

378
00:49:05,280 --> 00:49:11,440
事件，通過清除您可以從Cache重載的記憶體或任何其他改進記憶體的方式

379
00:49:11,440 --> 00:49:17,120
足跡您可以做的，順便說一下，在模擬器中有一個選項可以模擬


380
00:49:17,120 --> 00:49:22,480
記憶體警告，所以你可以在模擬器中看到你的 app 如何回應這些警告，

381
00:49:22,480 --> 00:49:36,240
只是明確的觸發這種警告，還有兩種類型，首先是無效的算術運算，也就是使用

382
00:49:36,240 --> 00:49:43,600
XC算術異常類型，這只是一種崩潰，因為一個無效

383
00:49:43,600 --> 00:49:51,200
的算術操作，比如除以零或浮點數錯誤，所以這些都是很明確的

384
00:49:51,200 --> 00:49:58,320
就像在這個例子中，由零除以和 XC 算術異常類型，你只需要使用

385
00:49:58,320 --> 00:50:01,600
線程回溯並查看錯誤來源。

386
00:50:01,600 --> 00:50:09,040
最後，只包含系統函數的崩潰，我們稱之為不可能的崩潰類型

387
00:50:09,040 --> 00:50:15,360
這是你可以理解和嘗試修復的最困難的崩潰類型之一，因為

388
00:50:15,360 --> 00:50:20,960
這些崩潰只包含他們回溯中的系統函數，沒有 AppCode。

389
00:50:20,960 --> 00:50:28,000
在回溯中你無法重現它，你沒有清晰的資訊，那你應該怎麼做？

390
00:50:28,000 --> 00:50:33,440
在這些情況下，首先你需要仔細閱讀Crash報告，而我說的是

391
00:50:33,440 --> 00:50:39,440
我是指所有的堆疊追蹤，例外碼，盡可能地縮小範圍，也許是應用程式的一部分

392
00:50:39,440 --> 00:50:46,480
在那裡Crash發生的地方，或是與框架相關的事物，或是你能在那裡找到的任何東西

393
00:50:47,360 --> 00:50:54,400
有時那還不夠，那就是當第三方服務像是Crash報告不夠用的時候

394
00:50:54,400 --> 00:51:02,560
這就是第三方服務如Firebase Crashlytics有選項可以註冊日誌的時候

395
00:51:02,560 --> 00:51:10,560
這樣可以派上用場，所以你可以添加日誌，並且這些第三方服務將運送這些日誌

396
00:51:10,560 --> 00:51:16,320
與Crash報告一起，這真的很有幫助，因為Crash報告就像是

397
00:51:16,320 --> 00:51:23,360
在應用程式崩潰時裝置上發生的情況的快照，您最需要的大部分

398
00:51:23,360 --> 00:51:31,760
時間都是一些可以再現的步驟，就像一個故事，所以如果您有這些日誌，您可能會有更多的細節

399
00:51:31,760 --> 00:51:39,040
就像好的，用戶開啟了應用程式並去搜索，然後做了這個和那個，也許

400
00:51:39,040 --> 00:51:44,960
也許那能給你一個關於如何複製這個崩潰的線索，因為像我說的如果你

401
00:51:44,960 --> 00:51:50,480
只獲得崩潰報告，那只是一個快照，所以它在這個功能中崩潰了，但是你對

402
00:51:50,480 --> 00:51:59,200
之前發生的其他事情一無所知，我並不知道有什麼方法可以得到蘋果的

403
00:51:59,200 --> 00:52:06,320
報告服務的日誌，所以如果你需要這個，你可能在尋找一個第三方服務或者不是它的

404
00:52:06,320 --> 00:52:13,360
我無法影響你的決定，但我不能再強調，能夠

405
00:52:13,360 --> 00:52:18,640
不斷重製 Crash 是多麼珍貴，因為當你可以不斷地重現它，那麼你就可以用

406
00:52:18,640 --> 00:52:25,200
我展示過的不同工具去檢查，或者你可以進行 TDD 流程並寫一個觸發 Crash 的測試

407
00:52:25,200 --> 00:52:31,520
然後修復它，這樣你就確保在將來不會對那次 Crash 產生回歸

408
00:52:32,720 --> 00:52:41,040
所以我希望我給你們提供了一些有關這些 Crash 類型的有用提示，如果你有問題請告訴我

409
00:52:41,040 --> 00:52:50,000
是的，我已經看到一個問題了，你知道哪種類型的 Crash 可以導致 swizzling 方法嗎，我的意思是

410
00:52:50,000 --> 00:52:57,360
它會是 zombie unrecognized selector 或者其他東西嗎？我想這取決於如果

411
00:52:57,360 --> 00:53:03,760
你正在使用一種該對象上不存在的方法進行混合，是的，你可能會得到一個未能認出的

412
00:53:03,760 --> 00:53:12,080
選擇器，我猜如果你使用錯誤的方法進行混合，據我經驗可能會導致

413
00:53:12,080 --> 00:53:21,040
其他問題，所以我儘可能地遠離它，當然，還有其他

414
00:53:21,040 --> 00:53:27,680
問題嗎？一次，二次 

415
00:53:27,680 --> 00:53:39,520
好的，沒有了，謝謝你們的耐心聽講，見你們下次，再見