

1
00:00:00,000 --> 00:00:07,080
大家好，歡迎回到iOS工具系列。

2
00:00:07,080 --> 00:00:14,280
我非常高興能夠和大家一起，在這裡真的很期待這場講座

3
00:00:14,280 --> 00:00:15,520
的實現。

4
00:00:15,520 --> 00:00:16,520
為什麼？

5
00:00:16,520 --> 00:00:23,200
因為這是我最喜歡的主題之一，關於Xcode和iOS的，也就是談到

6
00:00:23,200 --> 00:00:26,640
Xcode的建構過程。

7
00:00:26,640 --> 00:00:34,360
我真的知道花費數小時去了解和修復建立失敗有多沮喪

8
00:00:34,360 --> 00:00:39,880
或者只是嘗試讓Xcode做出你想要它做的事情。

9
00:00:39,880 --> 00:00:47,080
或者不得不不斷等待Xcode完成索引或建立，你掙扎

10
00:00:47,080 --> 00:00:55,240
要把你的想法保留到你能把它放到程式碼中。

11
00:00:55,240 --> 00:01:00,520
理解Xcode的建構過程如何運作與如何讓它更高效

12
00:01:00,520 --> 00:01:06,520
對於一個資深開發者來說，這是一項基本的信息。

13
00:01:06,520 --> 00:01:12,640
它將能讓你在Xcode中提高生產力，創造更快的構建，快速修復問題

14
00:01:12,640 --> 00:01:16,960
更別提在面試中脫穎而出。

15
00:01:16,960 --> 00:01:20,960
所以，請繼續關注。

16
00:01:20,960 --> 00:01:27,720
我們將解釋從源碼到可執行碼的步驟，這對於大多數編程

17
00:01:27,720 --> 00:01:36,880
語言都適用，並看看編譯器一般是如何工作的。

18
00:01:36,880 --> 00:01:44,480
我們將看到Xcode構建過程包括什麼，並嘗試解釋我們按下

19
00:01:44,480 --> 00:01:49,400
構建或命令B時會發生什麼。

20
00:01:49,400 --> 00:01:54,520
我們將探討構建系統認為是依賴性的是什麼。

21
00:01:54,520 --> 00:02:02,720
我們將看到我們如何透過提供額外的依賴性資訊來加快其速度。

22
00:02:02,720 --> 00:02:08,480
鏈接器是構建系統中這個較少被知道的部分，但其實它非常重要。

23
00:02:08,480 --> 00:02:14,600
簡單來說，連接器的工作就是將編譯器創建的所有輸出合併為

24
00:02:14,600 --> 00:02:17,080
一個單一的輸出。

25
00:02:17,080 --> 00:02:23,200
我們將解釋連接器是如何工作的，以及它為什麼對於構建系統如此重要。

26
00:02:23,200 --> 00:02:32,520
我們將以問答環節作結。

27
00:02:32,520 --> 00:02:36,120
編程在時間的推移下進化了許多。

28
00:02:36,120 --> 00:02:41,880
在一開始，程序員只有一小撮人會寫代碼，

29
00:02:41,880 --> 00:02:48,160
這是由機器直接執行的代碼，被稱為機器代碼，就像你現在看到的那樣。

30
00:02:48,160 --> 00:02:53,840
但閱讀和寫這樣的代碼真的很困難，速度慢，且容易出錯。

31
00:02:53,840 --> 00:03:02,280
所以程序員投入時間創建了編程語言。

32
00:03:02,280 --> 00:03:07,920
如我所說，這段機器代碼實際上取自Xcode的可執行文件，

33
00:03:07,920 --> 00:03:13,040
當然這只是其中的一小部分。

34
00:03:13,040 --> 00:03:20,960
編程語言僅是允許我們在程式碼中更好地表達的抽象。

35
00:03:20,960 --> 00:03:25,600
就像你在左邊看到的Swift hello word一樣。

36
00:03:25,600 --> 00:03:30,880
現代語言讓我們能夠寫出讀起來像故事的代碼，這使得理解和創建變得更容易。

37
00:03:30,880 --> 00:03:36,160
以便理解和創建。

38
00:03:36,160 --> 00:03:43,900
因此，在投影片的左側，你看到一行Swift代碼，右側

39
00:03:43,900 --> 00:03:51,040
你看到的是編譯此Swift 代碼後生成的33千字節機器碼的一部分。

40
00:03:51,040 --> 00:03:57,320
Swift代碼。

41
00:03:57,320 --> 00:04:04,160
今天，有了像Xcode這樣的先進的IDE，如Swift的先進編程語言，以及大量的框架，創建應用程序非常容易，

42
00:04:04,160 --> 00:04:10,280
包含像Swift這樣的先進編程語言，以及一大堆的框架都能解決大部分問題。

43
00:04:10,280 --> 00:04:15,160
大多數的問題都有現成的解決方案。

44
00:04:15,160 --> 00:04:20,920
在這裡，您可以看到CPU指令，這是我們在hello word的例子中看到的一部分

45
00:04:20,920 --> 00:04:24,080
在上一張幻燈片上。

46
00:04:24,080 --> 00:04:31,780
當然這也相當困難理解和追蹤。

47
00:04:31,780 --> 00:04:36,960
為了能夠將代碼以人類可讀的編程語言寫出並將其轉化爲

48
00:04:36,960 --> 00:04:44,420
有效的機器碼，我們需要一個工具，最好是可以自動完成這些工作的工具。

49
00:04:44,420 --> 00:04:50,600
這個工具被稱為Compiler，它自動將高級源碼轉換為低級

50
00:04:50,600 --> 00:04:55,480
可執行的機器碼。

51
00:04:55,480 --> 00:05:00,680
所以開發人員可以專注於編寫源代碼。

52
00:05:00,680 --> 00:05:06,160
現存的compiler數量眾多，並且每天都在增長。

53
00:05:06,160 --> 00:05:11,840
有針對非常簡單的編程語言的compiler，到非常強大的compiler，如

54
00:05:11,840 --> 00:05:19,720
Swift compiler，其實其是由許多子組件組成的。

55
00:05:19,720 --> 00:05:23,440
compiler的領域是一個非常複雜的領域。

56
00:05:23,440 --> 00:05:32,280
我記得我在大學期間修了一年的課程，但只是淺嚐其表。

57
00:05:32,280 --> 00:05:39,400
所以今天，為了時間上的考量，我們會試著探討編譯過程的精髓

58
00:05:39,400 --> 00:05:45,440
並深入研究我們在開發

59
00:05:45,440 --> 00:05:50,780
Apple平台時所使用的編譯器的特性。

60
00:05:50,780 --> 00:05:57,120
但無論語言或編譯器如何，編譯過程中都涉及到幾個組件，

61
00:05:57,120 --> 00:06:04,240
如我所說，將原始碼轉換成可執行的機器碼。

62
00:06:04,240 --> 00:06:08,880
碼。

63
00:06:08,880 --> 00:06:14,800
有一個組件被稱為前編譯器，它是一個在編譯器之前運行的程式，

64
00:06:14,800 --> 00:06:23,280
處理輸入數據，即代碼，以產生輸出數據，這也是代碼，

65
00:06:23,280 --> 00:06:27,160
供編譯器用作輸入。

66
00:06:27,160 --> 00:06:34,680
並非所有的編譯器都有一個預編譯器，但是像C或Objective-C這樣的基於C的語言

67
00:06:34,680 --> 00:06:37,000
有。

68
00:06:37,000 --> 00:06:46,920
更準確地說，預編譯器實際上是編譯器的一個子組件。

69
00:06:46,920 --> 00:06:53,000
「編譯器」這個名稱主要是用來稱呼將源碼從高級

70
00:06:53,000 --> 00:06:59,000
編程語言轉換到低級語言，如組裝語言，對象代碼或機器

71
00:06:59,000 --> 00:07:05,520
碼以創建可執行程序的程序。

72
00:07:05,520 --> 00:07:11,680
編譯器可能會執行一些或所有以下操作，通常被稱為

73
00:07:11,680 --> 00:07:21,880
階段，包括預處理（也稱為預編譯）, 字詞分析, 解析, 語義分析,

74
00:07:21,880 --> 00:07:30,880
將輸入程序轉換為其中間表示形式，代碼優化，代碼生成。

75
00:07:30,880 --> 00:07:36,320
編譯器通常將這些階段實現為模塊化的組件，以促進有效的


76
00:07:36,320 --> 00:07:43,760
設計與來源輸入到目標輸出的轉換的正確性。

77
00:07:43,760 --> 00:07:52,120
最後，連結器是一個程序，他將由編譯器生成的一個或多個對象文件

78
00:07:52,120 --> 00:07:59,520
或者編譯器和組合它們成單一的可執行文件，庫文件，或者僅僅是另一個

79
00:07:59,520 --> 00:08:06,340
對象文件。

80
00:08:06,340 --> 00:08:11,680
這只是編譯器的一般理論。

81
00:08:11,680 --> 00:08:23,120
現在讓我們深入了解Xcode的構建過程的具體情況。

82
00:08:23,120 --> 00:08:31,520
在Xcode中，你可以執行許多動作，如運行，測試，配置文件，分析，

83
00:08:31,520 --> 00:08:38,080
存檔，建造，運行SwiftUI預覽等更多。

84
00:08:38,080 --> 00:08:50,440
實際上，所有這些動作都依賴於構建一個或多個項目的目標。

85
00:08:50,440 --> 00:08:57,000
你已經知道Xcode使用工作區和項目來組織文件和任務到

86
00:08:57,000 --> 00:08:59,920
目標。

87
00:08:59,920 --> 00:09:03,880
既然你想從你的項目中建立不同的產品，你有能力

88
00:09:03,880 --> 00:09:10,360
將它們分組成不同的目標，並在這些目標間共享代碼、資源、設定，等等。

89
00:09:10,360 --> 00:09:12,240
這些目標。

90
00:09:12,240 --> 00:09:20,240
一個目標指定了要建立的產品，像在EssentialApp的案例中就是一個應用程式。

91
00:09:20,240 --> 00:09:27,420
像EssentialFeed框架的一種框架，一個Bundle或像EssentialFeedTests的單元測試Bundle。

92
00:09:27,420 --> 00:09:38,400
像EssentialFeed框架的一種框架，一個Bundle或像EssentialFeedTests的單元測試Bundle。

93
00:09:38,400 --> 00:09:45,180
Xcode使用一個由許多任務組成的構建過程，這些任務是根據要構建的目標類型創建的，

94
00:09:45,180 --> 00:09:50,760
基本上是從資源（如Swift 文件、Objective-C

95
00:09:50,760 --> 00:09:59,360
頭文件和源文件、故事板、資產目錄等）轉換成最終的可執行文件。

96
00:09:59,360 --> 00:10:07,680
當您按下command B時，基本上就是這樣的情況。蘋果公司提供兩種不同的編譯器

97
00:10:07,680 --> 00:10:18,920
它們都嵌入在Xcode中，Clang用於編譯C-based語言如C，C++，Objective-C，

98
00:10:18,920 --> 00:10:26,280
Objective-C++，以及Swift編譯器用於編譯Swift代碼。

99
00:10:26,280 --> 00:10:31,080
它們都會將源碼文件翻譯成物件檔案。

100
00:10:31,080 --> 00:10:36,560
物件檔案包含可執行的代碼片段，但本身並不能執行

101
00:10:36,560 --> 00:10:41,880
因為它們缺少必要的信息。

102
00:10:41,880 --> 00:10:47,400
最後，來自兩種編譯器的輸出檔案將由鏈接器使用以創建一個單一的

103
00:10:47,400 --> 00:10:49,800
對每個目標都可以執行的文件。

104
00:10:49,800 --> 00:10:52,760
這次，它不缺乏任何信息。

105
00:10:52,760 --> 00:10:57,240
所以這是一個真正的，系統可以運行的可執行文件。

106
00:10:57,240 --> 00:11:03,680
我們將在幾分鐘內看到鏈接器是如何做到這一點的。

107
00:11:03,680 --> 00:11:13,480
我提到的一些任務在建立過程中執行，如編譯源碼

108
00:11:13,480 --> 00:11:22,040
如 Swift 的源碼、Objective-C 文件、C++，以及更多。

109
00:11:22,040 --> 00:11:30,840
生成標頭或像這裡的Swift介面標頭那樣的文件，編譯故事板

110
00:11:30,840 --> 00:11:39,920
和包含您的資產的資產目錄。

111
00:11:39,920 --> 00:11:52,280
執行條紋，處理像Info.plist這樣的plists，鏈接其他模塊，程式碼簽名，

112
00:11:52,280 --> 00:11:55,680
以及更多。

113
00:11:55,680 --> 00:12:03,800
現在，建立過程中的大多數任務是通過運行命令行工具來實現的

114
00:12:03,800 --> 00:12:14,880
像Clang、LD、AC工具、IB工具、code sign，等等。

115
00:12:14,880 --> 00:12:20,160
這些工具必須在特定的順序中，使用一組非常特定的參數來執行，

116
00:12:20,160 --> 00:12:25,400
這基於你的Xcode 項目的配置。

117
00:12:25,400 --> 00:12:30,960
所以建構系統為你做的就是每次當你進行建置時，自動執行這些任務。

118
00:12:30,960 --> 00:12:34,040
每次進行建置時。

119
00:12:34,040 --> 00:12:38,720
由於一個建置過程中可能有許多任務，顯然這不是你

120
00:12:38,720 --> 00:12:43,400
希望手動輸入到終端機中的東西，我們幾秒鐘後就會看到。

121
00:12:43,400 --> 00:12:49,120
讓建構系統使用我們早些時候提到的Xcode操作，比如

122
00:12:49,120 --> 00:12:56,920
建置或存檔或從命令行中的Xcode建構命令來為您完成。

123
00:12:56,920 --> 00:13:08,280
記住我們可以使用報告導航器檢查建構日誌的結果和任務。

124
00:13:08,280 --> 00:13:10,600
我們來這麼做。

125
00:13:10,600 --> 00:13:25,520
我將在此選擇我最後的建置，首先我們注意到這個報告導航器

126
00:13:25,520 --> 00:13:30,560
頂部有一個有兩個控制項的過濾器。

127
00:13:30,560 --> 00:13:36,840
第一個控制項允許所有或最近的選項。

128
00:13:36,840 --> 00:13:45,560
所有(All)代表過去構建的所有訊息，而近期(recent)僅顯示已執行的最後一次構建的訊息。

129
00:13:45,560 --> 00:13:51,600
針對最後一次構建。

130
00:13:51,600 --> 00:13:58,080
另一個過濾器控制你看到哪類型的訊息，所有的訊息，所有的問題

131
00:13:58,080 --> 00:14:02,800
包含錯誤(Errors)或者只有錯誤(Errors)。

132
00:14:02,800 --> 00:14:09,020
如果我在成功構建的情況下使用這些過濾器，就沒有錯誤訊息，但如果我使用一個較舊的含有錯誤的構建

133
00:14:09,020 --> 00:14:21,800
我就可以看到錯誤訊息。

134
00:14:21,800 --> 00:14:32,400
我將在這裡使用我的最後一個構建並顯示，這些列出的每一個任務

135
00:14:32,400 --> 00:14:46,520
對於每個目標都可以被透過使用每個任務行的右側的一個小圖示來展開。

136
00:14:46,520 --> 00:14:57,440
所以讓我們看看構建像這樣的Swift的命令。

137
00:14:57,440 --> 00:15:09,200
你可以看到，命令行(CommandLine)非常長。

138
00:15:09,200 --> 00:15:19,600
讓我們使用一個命令來編譯Storyboard，這次稍微短一些，我們也可以看看

139
00:15:19,600 --> 00:15:28,320
一個連結命令，這個命令將連接到這一案例中的EssentialFeed iOS，該命令

140
00:15:28,320 --> 00:15:33,680
使用的是LD命令。

141
00:15:33,680 --> 00:15:40,000
如你所見，這些命令通常很長，並帶有許多參數，其中一些

142
00:15:40,000 --> 00:15:43,920
參數會直接通過構建設定來控制。

143
00:15:43,920 --> 00:15:49,720
當構建失敗，當構建緩慢或未能達到我們想要的效果時，我們

144
00:15:49,720 --> 00:16:04,600
可以檢查每一項任務的詳細情況以更好地理解它。

145
00:16:04,600 --> 00:16:11,240
構建過程中的任務是按照特定的順序來執行的。

146
00:16:11,240 --> 00:16:18,120
任務執行的順序是由依賴關係資訊來確定的，即

147
00:16:18,120 --> 00:16:25,840
任務，一個任務所消耗的輸入，以及它產生的輸出。

148
00:16:25,840 --> 00:16:33,800
編譯任務會消耗像SceneDelegate Swift File這樣的源文件作為輸入

149
00:16:33,800 --> 00:16:41,320
並產生像SceneDelegate.o這樣的對象文件作為輸出。

150
00:16:41,320 --> 00:16:48,640
同樣的，對於Objective-C，編譯會將myfile.m作為輸入並產生

151
00:16:48,640 --> 00:16:56,560
myfile.o 對象文件作為輸出。

152
00:16:56,560 --> 00:17:04,760
鏈接任務更有趣，因為它需要多個條目或輸入。

153
00:17:04,760 --> 00:17:12,040
在這種情況下，它需要從目標中獲得所有對象文件，這些文件是先前的

154
00:17:12,040 --> 00:17:19,520
編譯任務的結果，如myfile.o，AppDelegate.o，FeedUIComposer.o，和

155
00:17:19,520 --> 00:17:21,920
以此類推。

156
00:17:21,920 --> 00:17:34,800
但也有EssentialFeed框架，該框架與我的目標鏈接並產生一個可執行文件。

157
00:17:34,800 --> 00:17:42,480
這就是將進入EssentialApp Bundle的EssentialApp 可執行文件。

158
00:17:42,480 --> 00:17:48,480
編譯任務通常互相獨立，因此可以並行運行。

159
00:17:48,480 --> 00:17:53,880
鏈接任務需要同一目標中所有編譯任務的輸出，

160
00:17:53,880 --> 00:18:00,300
所以它必須等待所有的編譯任務完成後才能運行。

161
00:18:00,300 --> 00:18:06,280
構建系統使用依賴信息來確定任務應照何順序

162
00:18:06,280 --> 00:18:14,360
進行和哪些任務可以並行運行，我們稱之為依賴順序。

163
00:18:14,360 --> 00:18:18,600
那麼當你按下構建按鈕會發生什麼？

164
00:18:18,600 --> 00:18:26,680
嗯，首先，構建系統會從你的Xcode

165
00:18:26,680 --> 00:18:35,880
工程檔案中讀取構建描述。

166
00:18:35,880 --> 00:18:43,480
它考慮到項目中的所有文件、目標、依賴關係，

167
00:18:43,480 --> 00:18:53,080
以及我們在前幾講中談到的構建設定。

168
00:18:53,080 --> 00:19:00,280
而它把所有東西轉換成一種稱為有向圖的樹狀結構。

169
00:19:00,280 --> 00:19:02,600
讓我們來看看這個圖長什麼樣。

170
00:19:02,600 --> 00:19:11,800
在我們的案例中，創建EssentialApp依賴於編譯資源和故事版，並處理

171
00:19:11,800 --> 00:19:19,360
Info.plist檔案，但也依賴於連接EssentialApp可執行檔。

172
00:19:19,360 --> 00:19:25,200
要連接可執行檔，當然，我們首先需要編譯Objective-C檔案，如果

173
00:19:25,200 --> 00:19:28,120
有的話。

174
00:19:28,120 --> 00:19:38,200
Objective-C檔案的編譯取決於生成Swift頭檔接口。

175
00:19:38,200 --> 00:19:44,160
要生成Swift頭檔接口，我們需要編譯Swift檔案。

176
00:19:44,160 --> 00:19:48,640
因此，這項任務依賴於編譯Swift檔案。

177
00:19:48,640 --> 00:19:55,720
我剛提到了其中的一些。

178
00:19:55,720 --> 00:20:03,280
我們可以注意到的是，在這些構建任務之間可以存在直接的依賴性，


179
00:20:03,280 --> 00:20:10,760
像是在使用FeedUIComposer的SceneDelegate Swift File的情況下。

180
00:20:10,760 --> 00:20:18,200
另外，此些文件中的一些使用來自EssentialFeed Framework的實體。

181
00:20:18,200 --> 00:20:24,600
所以他們也依賴那項任務。

182
00:20:24,600 --> 00:20:26,800
為什麼呢？

183
00:20:26,800 --> 00:20:34,800
因為EssentialFeed Framework被列入EssentialApp的建置階段

184
00:20:34,800 --> 00:20:40,800
即在鏈接庫（link binary）下。

185
00:20:40,800 --> 00:20:55,520
最後，編譯Swift檔案依賴於編譯橋接標頭。

186
00:20:55,520 --> 00:21:01,640
儘管這只是建構圖的簡單表現方式，但完整的圖，包含

187
00:21:01,640 --> 00:21:09,560
更多任務，表示了輸入和輸出檔案之間的所有依賴性與

188
00:21:09,560 --> 00:21:14,200
將被執行以處理它們的任務。

189
00:21:14,200 --> 00:21:21,840
接下來，自此圖表所呈現出的低階執行過程，觀察依賴規範

190
00:21:21,840 --> 00:21:27,640
並確定執行哪些任務，他們必須按照哪種序列或順序運行，

191
00:21:27,640 --> 00:21:35,720
以及哪些任務可以並行運行，然後進行執行。

192
00:21:35,720 --> 00:21:47,920
但是你的項目越大，構建過程完成所需的時間就越長。

193
00:21:47,920 --> 00:21:54,160
所以你不想每次構建時都運行所有這些任務。

194
00:21:54,160 --> 00:22:02,040
相反，構建系統可能只執行圖中的一部分任務，這取決於

195
00:22:02,040 --> 00:22:05,840
自上次構建以來，你對項目進行了哪些更改。

196
00:22:05,840 --> 00:22:12,560
我們稱這種為增量構建，擁有準確的依賴性信息

197
00:22:12,560 --> 00:22:19,040
對於增量構建能夠正確且高效工作至關重要。

198
00:22:19,040 --> 00:22:27,520
如果我們在上次構建後只對FeedUIComposer進行了更改，構建系統將會


199
00:22:27,520 --> 00:22:35,360
此系統能偵測並只執行編譯 FeedUIComposer 任務以及所有依賴於此的任務，

200
00:22:35,360 --> 00:22:43,260
跳過剩餘的任務，這絕對可以加快建構的速度。

201
00:22:43,260 --> 00:22:47,880
但是，建構系統實際上如何偵測變動呢？

202
00:22:47,880 --> 00:22:58,720
好吧，每一個任務都有一個簽名，這種簽名是從各種不同訊息中計算出來的

203
00:22:58,720 --> 00:23:03,600
與任務相關的訊息。

204
00:23:03,600 --> 00:23:10,840
這些訊息包括任務的輸入，例如檔案路徑、修改時間戳記，

205
00:23:10,840 --> 00:23:18,480
實際執行命令的 CommandLine，以及其他特定於任務的元數據，

206
00:23:18,480 --> 00:23:26,120
例如編譯器的版本。

207
00:23:26,120 --> 00:23:31,920
建構系統了解目前任務和先前任務的簽名，

208
00:23:31,920 --> 00:23:39,120
以便了解每次演進時是否需要重新執行一個任務。

209
00:23:39,120 --> 00:23:43,680
即使是任何給定任務的簽名都與它在前一個中的簽名不同

210
00:23:43,680 --> 00:23:47,720
那麼，構建系統就會重新運行該任務。

211
00:23:47,720 --> 00:23:52,280
如果他們相同，那麼就會跳过。

212
00:23:52,280 --> 00:24:00,780
讓我們回到Xcode的構建日誌，並進行清理。

213
00:24:00,780 --> 00:24:09,520
現在我打算進行構建，這通常在清理後的構建就是一次乾淨的構建。

214
00:24:09,520 --> 00:24:18,340
我們能看到這次的構建在我的高效能機器上花了大約3.8秒，並且執行了許多任務。

215
00:24:18,340 --> 00:24:20,000
有很多任務。

216
00:24:20,000 --> 00:24:34,040
現在，如果我再次構建，我看到我的構建只花了半秒鐘，任務數量

217
00:24:34,040 --> 00:24:43,000
列出的比我們為清潔建築執行的任務少得多。

218
00:24:43,000 --> 00:24:53,080
再一次，我覺得這很明顯。

219
00:24:53,080 --> 00:24:59,000
這裡有一些我不完全確定為何的有趣現象。

220
00:24:59,000 --> 00:25:03,720
即使在EssentialFeed中沒有變化，我們仍舊讓系統重新編譯所有的

221
00:25:03,720 --> 00:25:09,520
Swift文件，但那可能只是編譯器的一瞥。

222
00:25:09,520 --> 00:25:20,680
這裡的關鍵是我們得到了一個更快的編譯並且更少的建構任務。

223
00:25:20,680 --> 00:25:25,840
現在我們看到這個，我們問自己，我們怎麼才能幫助編譯系統呢？

224
00:25:25,840 --> 00:25:31,880
嗯，要明白這點，我們需要從依賴關係的角度來思考編譯系統，

225
00:25:31,880 --> 00:25:34,240
而不是任務的順序。

226
00:25:34,240 --> 00:25:39,600
任務的順序是系統的工作。

227
00:25:39,600 --> 00:25:51,040
為了理解這點，我們需要了解依賴性從哪裡來。

228
00:25:51,040 --> 00:26:01,800
所以我正在使用項目編輯器並開啟建構規則分頁。

229
00:26:01,800 --> 00:26:08,520
因為在建構規則下，我們有第一組依賴性，這些是內建依賴性。

230
00:26:08,520 --> 00:26:12,760
對於某些任務，依賴性信息來自內置於建構
231
00:26:12,760 --> 00:26:14,280
系統中的知識。

232
00:26:14,280 --> 00:26:19,320
建置系統內建有編譯器，連結器，資產目錄和

233
00:26:19,320 --> 00:26:23,680
Storyboard 預處理器等的規則。

234
00:26:23,680 --> 00:26:28,680
這些規則定義了哪種類型的檔案可以被接受為輸入，以及輸出

235
00:26:28,680 --> 00:26:31,960
產生的結果。

236
00:26:31,960 --> 00:26:35,060
你在這裡看到的這些建設規則都是開箱即用。

237
00:26:35,060 --> 00:26:37,720
你不需要做任何事情就可以使用它們。

238
00:26:37,720 --> 00:26:43,320
這只是一個提醒，Xcode 使用建設規則來決定如何處理每一種

239
00:26:43,320 --> 00:26:46,760
類型的檔案。

240
00:26:46,760 --> 00:26:56,360
這就是為什麼，例如，系統在編譯 a 時可以使用 Swift 編譯器。

241
00:26:56,360 --> 00:27:26,000
Swift 檔案，或是用 Clang 編譯 C 檔案，或是一個 Storyboard 編譯器對 storyboards 進行編譯。

242
00:27:26,000 --> 00:27:30,680
其他類型的依賴關係是 target 依賴。

243
00:27:30,680 --> 00:27:38,520
要看這些，我將轉到建置階段標籤並查看這裡的第一個項目，

244
00:27:38,520 --> 00:27:44,200
那就是依賴關係。

245
00:27:44,200 --> 00:27:49,640
目標依賴關係大致確定了目標建構的順序。

246
00:27:49,640 --> 00:27:56,240
在某些情況下，建置系統可以同時編譯不同目標的源碼。

247
00:27:56,240 --> 00:28:01,360
之前在較舊版本的 Xcode 中，當建置一個目標時，它需要所有依賴目標的編譯完成才能開始。

248
00:28:01,360 --> 00:28:06,320
自從 Xcode 10 和它的新建置系統以來，目標可以更早開始建置。

249
00:28:06,320 --> 00:28:13,240
這意味著您的編譯源碼階段可以更早開始，為您提供一些

250
00:28:13,240 --> 00:28:19,160
這表示你的編譯來源階段可以更早開始，為你帶來一些

251
00:28:19,160 --> 00:28:22,760
免費取得的並行化。

252
00:28:22,760 --> 00:28:35,440
現在，如果您嘗試添加一個依賴項，我們看到只有來自當前項目的目標

253
00:28:35,440 --> 00:28:39,760
在這裡列出。

254
00:28:39,760 --> 00:28:45,880
這是因為在我們現在的設定中，EssentialApp 空間包含了 EssentialFeed

255
00:28:45,880 --> 00:28:50,120
以及EssentialApp項目在同一層級上。

256
00:28:50,120 --> 00:29:01,920
因此，EssentialFeed項目的目標在我的依賴選擇器中不可見。

257
00:29:01,920 --> 00:29:04,920
但我們可以對此採取一些行動。

258
00:29:04,920 --> 00:29:14,720
我們可以將EssentialFeed項目移動到EssentialApp項目內，然後依賴項

259
00:29:14,720 --> 00:29:20,800
將會變得可見，所以我們可以設置對EssentialFeed和EssentialFeed的明確依賴。

260
00:29:20,800 --> 00:29:22,800
框架。

261
00:29:22,800 --> 00:29:26,480
讓我們把這個當作一個練習。

262
00:29:26,480 --> 00:29:33,520
我將拖放EssentialFeed到EssentialApp上，並取消選中添加

263
00:29:33,520 --> 00:29:41,080
因為它已經存在，所以可以針對該目標，然後點擊完成。

264
00:29:41,080 --> 00:29:48,080
如果我展開 EssentialApp 專案，我會發現 EssentialFeed 專案已經內嵌

265
00:29:48,080 --> 00:29:49,440
在其中。

266
00:29:49,440 --> 00:29:57,520
所以我可以刪除這裡的參照，因為它現在已經重複了。

267
00:29:57,520 --> 00:30:06,040
現在，如果我回到我的 EssentialApp 的依賴項並使用加號按鈕，我可以看到所有的

268
00:30:06,040 --> 00:30:09,360
來自 EssentialFeed 專案的目標。

269
00:30:09,360 --> 00:30:18,160
如果我可以將我的明確依賴設為 EssentialFeed 和 EssentialFeed iOS框架，我將

270
00:30:18,160 --> 00:30:40,640
進行清理，確保一切正常，然後進行建構，希望一切都能正常運作。

271
00:30:40,640 --> 00:30:49,360
但是，如我們之前所注意到的，我們已經有了 EssentialFeed框架 和 EssentialFeed

272
00:30:49,360 --> 00:30:56,520
iOS框架 這兩個在搭配庫中的列表了。

273
00:30:56,520 --> 00:31:03,000
這是另一種稱為隱式依賴關係的依賴性類型，並與一種選項相結合

274
00:31:03,000 --> 00:31:05,940
這是在方案上可用的。

275
00:31:05,940 --> 00:31:16,080
所以如果我打開方案編輯器並檢查建立的選項，找到隱式依賴，

276
00:31:16,080 --> 00:31:22,440
如果這個選項被啟用，並且該選項是預設開啟的，則建立系統將確定

277
00:31:22,440 --> 00:31:30,440
在目標上的隱式依賴關係，即使它不在目標依賴關係中列出。

278
00:31:30,440 --> 00:31:36,400
因此，再次，由於我們已將EssentialFeed和EssentialFeed iOS架構列在

279
00:31:36,400 --> 00:31:44,960
與EssentialApp的庫鏈接二進制文件中，所以它們已經是隱式依賴關係。

280
00:31:44,960 --> 00:31:52,760
因此，我們實際上並未從使該依賴關係明確化中獲得任何東西。

281
00:31:52,760 --> 00:32:05,000
因此，我將撤銷我的更改。

282
00:32:05,000 --> 00:32:17,920
讓我重新打開該項目，清理，建立，我們回到了原先的狀況。

283
00:32:17,920 --> 00:32:27,600
我所提到的兩種框架是隱含地相互連結的。

284
00:32:27,600 --> 00:32:40,440
下一種類型的依賴關係也源於build phases tab。

285
00:32:40,440 --> 00:32:50,200
你可以看到這裡有許多部分，有時候像copy headers，我們有編譯來源，

286
00:32:50,200 --> 00:32:54,320
copy Bundle resources以及更多。

287
00:32:54,320 --> 00:32:59,920
與每一個階段相關的任務通常會以群組的方式運行，

288
00:32:59,920 --> 00:33:03,760
按照這裡列出的階段順序。

289
00:33:03,760 --> 00:33:05,480
但有一個問題。

290
00:33:05,480 --> 00:33:11,320
如果構建系統更了解情況，並知道有些情況下

291
00:33:11,320 --> 00:33:17,160
只有錯誤的建造階段順序會導致建造問題或失敗，

292
00:33:17,160 --> 00:33:21,840
那它可能會忽略該順序。 

293
00:33:21,840 --> 00:33:26,560
所以確保理解你的依賴並驗證構建階段是否按照正確的順序。

294
00:33:26,560 --> 00:33:30,600
另一種類型的依賴關係是調度次序的依賴關係。

295
00:33:30,600 --> 00:33:36,560
所以再次，我將選擇我現在的方案EssentialApp，並編輯方案。

296
00:33:36,560 --> 00:33:44,520
然後在建立（build）標籤下，我們可以看到所有將要被建立的目標（targets）。

297
00:33:44,520 --> 00:33:52,160
在最上面，有一種建立順序選項，它有兩種變體。

298
00:33:52,160 --> 00:34:01,480
預設的是依賴順序（dependency order）。這表示這裡列出的目標會被建立

299
00:34:01,480 --> 00:34:04,560
並行性取決於依賴資訊。

300
00:34:04,560 --> 00:34:11,880
所以你得到更好的建立性能，這樣子目標的順序並不重要。

301
00:34:11,880 --> 00:34:20,140
然而，如果你設定為手動順序（manual order），這是已被棄用的，Xcode 會嘗試

302
00:34:20,140 --> 00:34:25,360
按照你在方案的建立動作中列出目標的順序逐一建立。

303
00:34:25,360 --> 00:34:27,720
一個個來。

304
00:34:27,720 --> 00:34:33,800
目標依賴性（Target dependencies）在決定哪些目標先建立時，仍然有較高的優先級，

305
00:34:33,800 --> 00:34:38,540
但除此之外，Xcode將會遵循這個順序。

306
00:34:38,540 --> 00:34:47,360
所以，雖然使用這樣的方法能夠讓你預期的建立順序，即使

307
00:34:47,360 --> 00:34:53,160
你沒有正確設定你的依賴關係，但你可能會犧牲掉許多的平行處理能力

308
00:34:53,160 --> 00:34:57,080
進行這樣的操作將會減慢你的建立過程。

309
00:34:57,080 --> 00:35:02,280
Apple建議你應該將建立順序設定為依賴順序，並且設定

310
00:35:02,280 --> 00:35:10,640
你的目標正確，並不要依賴於排序。

311
00:35:10,640 --> 00:35:17,280
那麼,作為開發者,我們怎麼樣才能提供有價值的依賴性資訊以幫助建置系統呢?

312
00:35:17,280 --> 00:35:32,600
首先，如果你正在使用任何運行路線，我只是創建一個空的。

313
00:35:32,600 --> 00:35:39,640
確保告訴建置系統它的輸入，像是輸入檔或輸入檔名單

314
00:35:39,640 --> 00:35:45,000
和輸出檔案或文件列表。

315
00:35:45,000 --> 00:35:51,640
這讓建置系統避免不必要地重新執行腳本任務，並可能幫助

316
00:35:51,640 --> 00:35:55,420
確保它們按照正確的順序執行。

317
00:35:55,420 --> 00:36:03,040
您可以在運行腳本階段編輯器中定義輸入和輸出。

318
00:36:03,040 --> 00:36:09,080
請注意，如果您沒有定義任何輸入或輸出文件，則每次建置時都會執行該任務，

319
00:36:09,080 --> 00:36:17,640
因此，請確保這是您想要的。

320
00:36:17,640 --> 00:36:24,120
我們可以做的另一件事是避免項目依賴性的自動鏈接。

321
00:36:24,120 --> 00:36:39,680
這實際上是 Clang 編譯器可用的一項建置設定。

322
00:36:39,680 --> 00:36:45,680
而如您所見，這是預設狀態。

323
00:36:45,680 --> 00:36:53,400
做為 Clang 編譯器的設定，意味著此設定只適用於基於 C 的語言。

324
00:36:53,400 --> 00:37:00,160
此設定會讓編譯器自動鏈接對應的框架

325
00:37:00,160 --> 00:37:05,680
對任何你導入的模組，你無需在鏈接庫中明確地鏈接它們

326
00:37:05,680 --> 00:37:06,680
的構建階段。

327
00:37:06,680 --> 00:37:12,760
然而，需要注意的是，自動鏈接並不會在構建系統級別上建立依賴性

328
00:37:12,760 --> 00:37:15,640
對該框架。

329
00:37:15,640 --> 00:37:20,120
因此，它不能保證你依賴的目標實際上在你嘗試

330
00:37:20,120 --> 00:37:22,360
對其進行鏈接之前已經構建出來。

331
00:37:22,360 --> 00:37:27,480
Google 建議你禁用此設定，而是確認你已經鏈接了所有你使用的框架

332
00:37:27,480 --> 00:37:28,920
明確地鏈接它們。

333
00:37:28,920 --> 00:37:40,040
我也推薦這樣做。

334
00:37:40,040 --> 00:37:47,280
另一個我們可以做的，也是我們已經討論過的，是添加明確的依賴性。

335
00:37:47,280 --> 00:37:54,200
然而，對於你自己項目中的目標，確保你添加這些明確的依賴性。

336
00:37:54,200 --> 00:38:00,760
或者你可能需要做一個像我們做的練習，把另一個

337
00:38:00,760 --> 00:38:06,040
在你的項目的檔案導覽器中的Xcode項目中，可以顯示出其他項目的目標

338
00:38:06,040 --> 00:38:12,280
你依賴的，就像我們將必須的要素拖入EssentialApp時一樣。

339
00:38:12,280 --> 00:38:14,240
項目。

340
00:38:14,240 --> 00:38:21,040
結論，憑藉準確的依賴性資訊，構建系統可以更好地平行處理你的

341
00:38:21,040 --> 00:38:27,000
構建並確保你每次都能得到一致的結果，這樣你就可以花更少的時間

342
00:38:27,000 --> 00:38:40,560
建造，更多的時間進行開發。

343
00:38:40,560 --> 00:38:43,320
現在讓我們談談連結器。

344
00:38:43,320 --> 00:38:48,840
連結器是個程序，由編譯器生成一個或多個對象文件

345
00:38:48,840 --> 00:38:55,520
並將它們合併為一個單獨的可執行檔案或庫。

346
00:38:55,520 --> 00:39:01,040
在Xcode構建過程的情況下，連結器將由Clang和Swift編譯器產生的對象檔案

347
00:39:01,040 --> 00:39:08,000
合併成單一的可執行檔案。

348
00:39:08,000 --> 00:39:13,440
這實在是相當獨特，因為很少有系統接受結合不同語言的方式

349
00:39:13,440 --> 00:39:15,920
以及這樣的編譯器。

350
00:39:15,920 --> 00:39:25,800
這還需要大量的底層工作，由建構系統為我們完成。

351
00:39:25,800 --> 00:39:31,000
需要理解的是，鏈接器只會移動和修補代碼，它無法

352
00:39:31,000 --> 00:39:34,000
創建代碼。

353
00:39:34,000 --> 00:39:39,720
首先，我們需要理解符號是什麼。

354
00:39:39,720 --> 00:39:47,400
所以符號其實就是指向代碼或資料片段的名稱。

355
00:39:47,400 --> 00:39:51,480
代碼片段僅僅是一段代碼。

356
00:39:51,480 --> 00:39:56,840
這些片段可能會參考到其他你在寫函數時會看到的符號

357
00:39:56,840 --> 00:40:00,260
也就是調用其他函數。

358
00:40:00,260 --> 00:40:05,740
符號上可能會有屬性，這些屬性會影響鏈接器的行為。

359
00:40:05,740 --> 00:40:11,280
一個例子是「weak symbol」，這是一個注釋，表示在執行或稱為運行時間時，該符號可能不存在。

360
00:40:11,280 --> 00:40:18,080
關於這點的一個例子就是使用atAvailable標記。

362
00:40:36,360 --> 00:40:46,800
現在我將這個新的Store類別僅在iOS 15及其以上版本中設為available，意味著

363
00:40:46,800 --> 00:40:52,480
如果我們在運行先前版本操作系統的應用程式中，這個類別將不會

364
00:40:52,480 --> 00:40:55,240
在這些版本上存在。

365
00:40:55,240 --> 00:41:03,560
因此，鏈接器需要以不同的方式處理這個類，因為它在操作系統中可能不存在

366
00:41:03,560 --> 00:41:08,160
上運行它。

367
00:41:08,160 --> 00:41:15,860
另一個實例將是框架的weak linking。

368
00:41:15,860 --> 00:41:25,720
所以在EssentialApp上，作為一個練習，我將鏈接到一個非常新的框架，

369
00:41:25,720 --> 00:41:34,520
這就是在 iOS 15 中也有介紹的代碼位置UI框架。

370
00:41:34,520 --> 00:41:43,240
再次強調，由於我們的應用程序支持較舊版本的 iOS，如果我們將此依賴性設為默認

371
00:41:43,240 --> 00:41:51,560
在必需的情況下，這將導致在 iOS 14或更高版本上運行時應用程序崩潰。

372
00:41:51,560 --> 00:41:57,000
但是我們可以選擇將鏈接類型設為可選。

373
00:41:57,000 --> 00:42:05,520
這樣做的目的是告訴鏈接器，該框架在應用程序運行時可能不存在。

374
00:42:05,520 --> 00:42:07,260
應用程序運行。

375
00:42:07,260 --> 00:42:17,400
所以鏈接器正在為該情況做準備。

376
00:42:17,400 --> 00:42:22,920
這是重要的，因為鏈接器的一項工作就是確定哪些符號絕對

377
00:42:22,920 --> 00:42:34,120
會存在，而哪些符號可能需要在運行時處理。

378
00:42:34,120 --> 00:42:39,080
所以我們有符號，這些名稱是指代碼和數據。

379
00:42:39,080 --> 00:42:42,800
我們知道，編譯器會產生對象文件。

380
00:42:42,800 --> 00:42:47,720
這些對象文件僅僅是這些代碼和數據片段的集合。

381
00:42:47,720 --> 00:42:53,000
它們包含可執行的代碼，但他們無法自行執行。

382
00:42:53,000 --> 00:42:56,200
雖然它們是編譯過的代碼，但卻未完全生成完成。

383
00:42:56,200 --> 00:43:07,320
它們缺少的部分，是連結器需要黏合和修補的地方。

384
00:43:07,320 --> 00:43:14,480
在我們的例子中，SceneDelegate調用了一個NullStore的初始化程序。

385
00:43:14,480 --> 00:43:19,000
而NullStore是在不同的文件中定義的。

386
00:43:19,000 --> 00:43:25,760
當編譯器試圖編譯SceneDelegate時，它將此視為一種承諾或合同，

387
00:43:25,760 --> 00:43:30,960
就好像在某個地方有一個文件，定義了一個名為NullStore的類，它包含一個初始化程序

388
00:43:30,960 --> 00:43:33,240
帶有簽名。

389
00:43:33,240 --> 00:43:40,040
對於編譯器來說，這就足夠了，它將NullStore的初始化器標記為未定義的

390
00:43:40,040 --> 00:43:44,200
在它產生的物件檔案中的符號。

391
00:43:44,200 --> 00:43:49,920
但當連結器處理該物件檔案時，它實際上需要解析這個符號。

392
00:43:49,920 --> 00:44:00,660
所以它會在它收到的輸入中尋找實際的符號定義。

393
00:44:00,660 --> 00:44:09,600
如您所記，輸入是來自同一目標的物件檔案，以及

394
00:44:09,600 --> 00:44:13,560
連接到庫和框架。

395
00:44:13,560 --> 00:44:18,720
這裡的重點是連結器要么找到該符號的定義並嵌入到

396
00:44:18,720 --> 00:44:24,880
二進制中，要么失敗並帶來連結器錯誤。

397
00:44:24,880 --> 00:44:31,840
這很重要，因為在執行時，並無組件能查找

398
00:44:31,840 --> 00:44:34,480
符號，因為這樣做效率不高。

399
00:44:34,480 --> 00:44:37,240
所以連結器必須解析所有的符號。

400
00:44:37,240 --> 00:44:44,280
所以它創建的可執行檔包含了所有解析其符號的信息。

401
00:44:44,280 --> 00:44:50,560
有些符號可以存在於其他模組中，如動態框架。

402
00:44:50,560 --> 00:45:01,760
這就是我們的HTTPClient的情況，它在EssentialFeed框架中定義。

403
00:45:01,760 --> 00:45:08,320
鏈接器將包含有關確實在何處以及如何加載此符號的信息。

404
00:45:08,320 --> 00:45:17,360
或者在鏈接對系統框架，比如UIKit或Foundation，它將嵌入

405
00:45:17,360 --> 00:45:24,960
他們可用的位置以及如何加載他們的信息。

406
00:45:24,960 --> 00:45:32,280
需要注意的是，運行時，操作系統中有一個名為加載器的組件，

407
00:45:32,280 --> 00:45:35,560
將可執行文件加載到內存中。

408
00:45:35,560 --> 00:45:40,120
但是，它也將根據信息加載其他模組，如系統框架，

409
00:45:40,120 --> 00:45:49,600
從可執行文件中，鏈接器已經包含的。

410
00:45:49,600 --> 00:45:50,600
回到鏈接器。

411
00:45:50,600 --> 00:46:00,960
鏈接器接受兩種類型的輸入文件，目標文件，或.o，和庫。

412
00:46:00,960 --> 00:46:09,080
Dylibs是動態庫，TBDs是基於文本的，Dylib Stubs，還有.ar歸檔是靜態的

413
00:46:09,080 --> 00:46:11,200
庫。

414
00:46:11,200 --> 00:46:13,200
那麼庫是什麼呢？

415
00:46:13,200 --> 00:46:22,560
庫是定義不屬於您正在構建目標的符號的文件。

416
00:46:22,560 --> 00:46:28,360
動態庫是可供可執行碼使用的代碼和數據片段的文件。

417
00:46:28,360 --> 00:46:29,360
使用。

418
00:46:29,360 --> 00:46:34,800
作為系統一部分分發的系統框架包含了這種動態庫。

419
00:46:34,800 --> 00:46:42,880
就像我们提到的，UIKit，Foundation，MapKit，和所有其他的。

420
00:46:42,880 --> 00:46:47,680
但你也可以創建自己的動態庫，而且很有可能使用過第三方的動態

421
00:46:47,680 --> 00:46:51,960
庫。

422
00:46:51,960 --> 00:47:02,840
TBD文件，或者基於文本的Dylib Stubs，這些只用於分發SDK，以減少

423
00:47:02,840 --> 00:47:08,880
尺寸，所以他們基本上只是輕量版本的框架，只含有名稱

424
00:47:08,880 --> 00:47:15,880
的符號，不包含主體，因為主體只在運行時需要。

425
00:47:15,880 --> 00:47:24,240
最後，靜態存檔，或靜態庫，那些.a檔案只是物件的集合

426
00:47:24,240 --> 00:47:29,520
檔案，或者.o檔案，這些都是使用ar工具進行構建的。

427
00:47:29,520 --> 00:47:35,720
按照ar文檔的說法，ar工具創建並維護分組檔案合併為

428
00:47:35,720 --> 00:47:36,720
一個存檔。

429
00:47:36,720 --> 00:47:41,200
這與你可能熟悉的zip格式差不多。

430
00:47:41,200 --> 00:47:49,760
所以.a實質上就像是物件檔案的zip。

431
00:47:49,760 --> 00:47:54,600
關於連接，有一個關於靜態和動態

432
00:47:54,600 --> 00:47:55,600
庫之間很重要的區別值得一提。

433
00:47:55,600 --> 00:48:00,320
但請注意，這只是他們之間眾多區別中的一項。

434
00:48:00,320 --> 00:48:07,560
所以不要只用這些資訊來決定你在專案中要採用哪一個。

435
00:48:07,560 --> 00:48:10,800
這需要進一步的詳盡分析。

436
00:48:10,800 --> 00:48:14,880
我們在這裡只關注鍵結。

437
00:48:14,880 --> 00:48:21,840
所以在使用非系統動態庫的時候, 鍵結器不能做任何改善，如

438
00:48:21,840 --> 00:48:24,680
排除未使用的符號。

439
00:48:24,680 --> 00:48:29,680
鍵結器採取了謹慎的策略，所以這些庫會以

440
00:48:29,680 --> 00:48:31,640
他們的完整大小被安裝或嵌入。

441
00:48:31,640 --> 00:48:37,280
在另一方面，鍵結器可以與靜態庫更有效地協作。

442
00:48:37,280 --> 00:48:42,240
所以如果你引用了一個靜態鍵結的庫中的符號，鍵結器會把

443
00:48:42,240 --> 00:48:47,760
包含該符號的相對應的對象文件從檔案庫中解析出來並包含

444
00:48:47,760 --> 00:48:49,780
在可執行文件中。

445
00:48:49,780 --> 00:48:53,040
但它不會包含其他的文件。

446
00:48:53,040 --> 00:49:00,240
這樣做的效果是最終的可執行檔將接近只包含它實際使用的符號，

447
00:49:00,240 --> 00:49:11,280
當然，還有在同一文件中定義的其他符號。

448
00:49:11,280 --> 00:49:20,600
那讓我們回顧一下今天學到了什麼。

449
00:49:20,600 --> 00:49:27,800
所以，我們了解到從源文件到可執行文件的編譯過程，

450
00:49:27,800 --> 00:49:31,360
依賴於兩個主要組件。

451
00:49:31,360 --> 00:49:38,280
編譯器接受源文件作為輸入，產生物件檔案作為輸出，

452
00:49:38,280 --> 00:49:43,480
以及鏈接器，將這些物件文件和參考其他鏈接模組組合成最終的

453
00:49:43,480 --> 00:49:45,760
可執行文件。

454
00:49:45,760 --> 00:49:52,480
我們知道蘋果創建了一個獨特的生態系統，依賴於兩個編譯器，Clang用於C基礎的

455
00:49:52,480 --> 00:49:59,240
語言，如C或Objective-C，以及Swift編譯器用於Swift。

456
00:49:59,240 --> 00:50:06,400
我們探索了構建系統如何使用依賴性創建構建圖形，我們

457
00:50:06,400 --> 00:50:14,720
闡述了增量構建如何以不同且更為高效的方式運作，與完全重新構建有所區別。

458
00:50:14,720 --> 00:50:18,960
我們深入討論了構建系統中的依賴性是什麼。

459
00:50:18,960 --> 00:50:29,320
由構建規則所提供的內置依賴性，明確的依賴性或目標依賴性。

460
00:50:29,320 --> 00:50:34,760
您標記對同一專案或子專案中其他目標的依賴性。

461
00:50:34,760 --> 00:50:41,400
在連結二進制文件與函式庫下列出的隱式依賴性。

462
00:50:41,400 --> 00:50:49,720
構建階段的順序以及方案編輯器中目標的順序。

463
00:50:49,720 --> 00:50:56,360
我們可以通過為我們的運行腳本聲明輸入和輸出來幫助構建系統，

464
00:50:56,360 --> 00:51:04,400
避免使用自動連結選項，並通過目標

465
00:51:04,400 --> 00:51:08,720
依賴性或連結二進制文件與庫來增加明確和隱式依賴性。

466
00:51:08,720 --> 00:51:09,720
就是這樣。

467
00:51:09,720 --> 00:51:15,160
謝謝你的耐心。如果有任何問題，我會很高興回答它們。

468
00:51:39,720 --> 00:51:52,600
哦，我們可以隨時在Slack上討論他。

469
00:51:52,600 --> 00:51:57,240
哦，對不起，我有...

470
00:51:57,240 --> 00:52:03,680
等一下，好吧。

471
00:52:03,680 --> 00:52:14,680
好的，你能看見我，能聽到我嗎？

472
00:52:14,680 --> 00:52:15,680
可以。

473
00:52:15,680 --> 00:52:16,680
好酷。

474
00:52:16,680 --> 00:52:28,600
所以我對非Xcode IDE有一個問題，這是由JetBrains開發的AppCode。

475
00:52:28,600 --> 00:52:38,680
據我所知，Xcode build是我們用於建立的CommandLine程序。

476
00:52:38,680 --> 00:52:46,880
所以Xcode只是一個華麗而美觀的介面，但基本上所有事情都在CommandLine中發生。

477
00:52:46,880 --> 00:52:51,480
環境。

478
00:52:51,480 --> 00:52:56,280
所以你知道我們在AppCode中有什麼不同嗎？

479
00:52:56,280 --> 00:52:59,440
你認為，那邊是如何運作的？

480
00:52:59,440 --> 00:53:08,360
也許他們發明了一些新的東西，或者他們只是複製了我們在Xcode中的相同順序，相同流程

481
00:53:08,360 --> 00:53:13,600
我們在Xcode中有的。

482
00:53:13,600 --> 00:53:21,920
有趣的問題，其實幾年前我自己也用過AppCode。

483
00:53:21,920 --> 00:53:26,600
而我知道Mike曾經是AppCode的粉絲。

484
00:53:26,600 --> 00:53:34,840
我所知道的是，他們其實並沒有在背後使用Xcode build，但我可能記錯了。

485
00:53:34,840 --> 00:53:45,320
所以他們只是像Swfit C或是，我認為是LLVM這樣的編譯命令。

486
00:53:45,320 --> 00:53:47,920
為了進行Clang編譯線。

487
00:53:47,920 --> 00:53:57,000
或者Xcode build實際上是嵌入在Xcode裡，所以我不認為AppCode能夠使用

488
00:53:57,000 --> 00:53:58,000
那個。

489
00:53:58,000 --> 00:54:04,440
我認為他們有自己的組件，這些組件會分析專案檔並嘗試去

490
00:54:04,440 --> 00:54:06,680
進行編譯。

491
00:54:06,680 --> 00:54:15,400
所以這就是我認為並不是很多開發者使用和AppCode這樣的不同IDE的一個原因。

492
00:54:15,400 --> 00:54:19,600
因為它們可能實際上產生與Xcode不同的結果。

493
00:54:19,600 --> 00:54:27,640
所以當那種情況發生時，你基本上只能自求多福，特別是如果你在做任何事情，

494
00:54:27,640 --> 00:54:34,560
不知道，脫離常規，幾乎沒有任何可用的幫助。

495
00:54:34,560 --> 00:54:42,400
我像平行地使用它，所以在某個時刻我知道AppCode對於重構真的很好，

496
00:54:42,400 --> 00:54:48,960
並找到實體和類似的用法等等。

497
00:54:48,960 --> 00:54:56,920
所以對於那個，是的，我肯定更喜歡AppCode，但我仍然會盡我所能，

498
00:54:56,920 --> 00:55:03,200
並使用Xcode建築以確保一切都在檢查和我的AppCode的變化，

499
00:55:03,200 --> 00:55:04,920
不會破壞任何東西。

500
00:55:04,920 --> 00:55:07,600
是的，這裡也有CI的幫助。

501
00:55:07,600 --> 00:55:12,680
我不確定我是否完全回答了你的問題。

502
00:55:12,680 --> 00:55:16,800
對,基本上這就是我自己使用AppCode的方式。

503
00:55:16,800 --> 00:55:22,840
我只用它來寫代碼，編輯代碼，進行編碼自身，但是當我設定

504
00:55:22,840 --> 00:55:29,200
某些東西，當我添加目標，甚至當我為不同的檔案改變目標形狀時，我

505
00:55:29,200 --> 00:55:31,000
更傾向於使用Xcode。

506
00:55:31,000 --> 00:55:37,080
我只是想知道是否有可能完全切換到AppCode，因為現在我必須

507
00:55:37,080 --> 00:55:42,160
打開ID，Xcode和AppCode。

508
00:55:42,160 --> 00:55:53,240
對, 基本上這回答了我的問題，如果我可以再問一個，因為 

509
00:55:53,240 --> 00:55:55,080
我已經在講話了，對。

510
00:55:55,080 --> 00:56:01,840
我對這些像Tuist這類新的奇特工具感到好奇。

511
00:56:01,840 --> 00:56:10,760
實際上它使用YAML文件來生成Xcode項目，所以你不會有任何衝突


512
00:56:10,760 --> 00:56:18,040
當您重構或像合併衝突等大型計劃時，是否會遇到任何問題。

513
00:56:18,040 --> 00:56:24,800
你認為，這像不像一種可以被應用於大型產品項目的東西

514
00:56:24,800 --> 00:56:30,920
還是這只是一種可以玩一玩、然後就忘掉的玩具？

515
00:56:30,920 --> 00:56:33,000
是的，我知道這件事。

516
00:56:33,000 --> 00:56:39,720
我只想快速提一下首個主題，關於AppCode。

517
00:56:39,720 --> 00:56:49,320
我真的不覺得你可以不必透過Xcode，因為Apple在它成為主要工具上實在太努力了

518
00:56:49,320 --> 00:56:59,040
所以我認為我們無法這麼做。

519
00:56:59,040 --> 00:57:05,720
這就是當你使用任何第三方工具時，將你及你的團隊負擔的其中一個風險

520
00:57:05,720 --> 00:57:14,400
像是AppCode或者你剛提到的其他工具，我現在會開始談論他們。

521
00:57:14,400 --> 00:57:20,360
但當您使用第三方工具，總是存在風險，可能會在

522
00:57:20,360 --> 00:57:28,360
未來的版本中不工作，可能因為這導致您的工作流程完全破裂。

523
00:57:28,360 --> 00:57:32,480
所以這是一種風險，有時並不值得承擔。

524
00:57:32,480 --> 00:57:41,680
所以我們強烈推薦的方案是始終使用來自Apple的默認工具，

525
00:57:41,680 --> 00:57:44,960
這些工具隨著時間進行維護。

526
00:57:44,960 --> 00:57:53,920
自iOS 2以來，我一直在做這個，而實際上沒有一個真正消失，而第三方

527
00:57:53,920 --> 00:57:56,560
工具出現並消失。

528
00:57:56,560 --> 00:58:06,760
對於你的另一個問題，我認為Xcode項目，有很多工具可以

529
00:58:06,760 --> 00:58:09,440
生成一個Xcode項目。

530
00:58:09,440 --> 00:58:18,560
是的，我知道有些團隊使用這些，它們可以非常有用，特別是像你說的，用於避免

531
00:58:18,560 --> 00:58:23,480
因為如果沒有將專案File提交到源控制中，就不會有

532
00:58:23,480 --> 00:58:28,960
在添加File或刪除File等操作時產生衝突。

533
00:58:28,960 --> 00:58:38,320
但再次強調，你正在增加這種風險，比如我不知道，這兩者可能不支援任何

534
00:58:38,320 --> 00:58:46,000
新的SDK或建置版本，然後你就無法動彈。

535
00:58:46,000 --> 00:58:49,920
所以再次提醒，聽之任之。

536
00:58:49,920 --> 00:58:57,680
我的傾向是保持使用標準工具，除非我真的需要。

537
00:58:57,680 --> 00:59:05,040
例如，如果我們在過去的幾個月或幾週中看到很多衝突，我們可以

538
00:59:05,040 --> 00:59:10,640
在團隊中討論，好的，這些衝突從何而來？

539
00:59:10,640 --> 00:59:12,680
有哪些可用的解決方案？

540
00:59:12,680 --> 00:59:19,400
因為有時候一種解決方案可能就是轉移到我在

541
00:59:19,400 --> 00:59:29,800
另一堂講座中展示的XC config檔案，或是有其他選項，不必要把所有項目生成

542
00:59:29,800 --> 00:59:31,560
移至第三方。

543
00:59:31,560 --> 00:59:38,160
但是，這是每個團隊必須自行決定的事情。

544
00:59:38,160 --> 00:59:45,560
但我認為，讓許多人開始依賴所有這些

545
00:59:45,560 --> 00:59:53,640
第三方，而不確定他們是否真的需要它們，實際上可能更損害，反觀這些真正需要的團隊數量很小

546
00:59:53,640 --> 00:59:58,200
那些真正需要這些項目的團隊。

547
00:59:58,200 --> 01:00:03,240
所以，我認為這是一種微妙的結論。

548
01:00:03,240 --> 01:00:08,720
好吧，這不僅僅是要避免合併衝突。

549
01:00:08,720 --> 01:00:17,520
當你讀這個YAML檔案時，它也更容易閱讀，你可以看到像自訂的構建

550
01:00:17,520 --> 01:00:22,560
規則，構建階段、腳本或其他內容。

551
01:00:22,560 --> 01:00:28,760
你可以現在就在這里看到， 在Xcode項目中，你需要跳過不同的

552
01:00:28,760 --> 01:00:34,200
選項卡並搜尋特定的參數，特定的部分。

553
01:00:34,200 --> 01:00:37,320
Xcode項目中發生的事情並不太明朗。

554
01:00:37,320 --> 01:00:42,200
它的界面太過繁華。

555
01:00:42,200 --> 01:00:45,960
這也是Xcode項目的問題。

556
01:00:45,960 --> 01:00:53,520
是的，我不知道你有沒有看到，我認為這是本系列講座的第一場

557
01:00:53,520 --> 01:01:01,720
我實際上展示了PBX文件格式及其結構。

558
01:01:01,720 --> 01:01:04,700
所以這就是支持Xcode項目的文件。

559
01:01:04,700 --> 01:01:13,440
所以，我對此部分同意，但不完全同意，因為蘋果仍然知道什麼

560
01:01:13,440 --> 01:01:14,440
它在做什麼。

561
01:01:14,440 --> 01:01:20,760
所以我需要在這一點上相信他們。

562
01:01:20,760 --> 01:01:30,280
根據我的經驗，即便是培養初級開發人員使用一個他們需要生成

563
01:01:30,280 --> 01:01:38,680
他們的project File，並需要做一些自定義的事情來添加對一個YAML的新設置，所有這些

564
01:01:38,680 --> 01:01:42,040
都可能複雜化他們的交互方式。

565
01:01:42,040 --> 01:01:47,760
如果你們的團隊成員都接受這件事情，那麼這可能是一個非常好的

566
01:01:47,760 --> 01:01:50,620
特定案例的決定。

567
01:01:50,620 --> 01:01:56,280
但我們正在這裡教導的內容不能以此為基礎建立為標準。

568
01:01:56,280 --> 01:02:00,560
所以，對，這可以說是一種自定義的解決方案。

569
01:02:00,560 --> 01:02:01,560
對。

570
01:02:01,560 --> 01:02:02,560
好的。

571
01:02:02,560 --> 01:02:03,560
謝謝。

572
01:02:03,560 --> 01:02:04,560
感謝您的解答。

573
01:02:04,560 --> 01:02:05,560
感謝您的問題。

574
01:02:05,560 --> 01:02:06,560
嗨。

575
01:02:06,560 --> 01:02:10,080
非常感謝您的選舉。

576
01:02:10,080 --> 01:02:12,760
這對我來說非常有益。

577
01:02:12,760 --> 01:02:20,240
雖然我有一個稍微特別的問題，特別是針對Swift版本。

578
01:02:20,240 --> 01:02:25,560
基本上，這裡有一個東西叫Swift ABI，這是幾年前介紹的，

579
01:02:25,560 --> 01:02:35,680
它基本上提供了一種方式讓不同Swift運行時版本加載Swift符號

580
01:02:35,680 --> 01:02:39,520
由舊版本的編譯器編譯的。

581
01:02:39,520 --> 01:02:45,320
我的問題是，你認為在你的應用程式中有幾個模塊，

582
01:02:45,320 --> 01:02:51,320
例如，核心模塊多年來完全沒有被修改，你認為這合理嗎？

583
01:02:51,320 --> 01:02:59,080
因此，你重新編譯它並提交二進制檔案到存儲庫或HTTP伺服器以便下載

584
01:02:59,080 --> 01:03:01,960
到Swift Package manager，舉例來說。

585
01:03:01,960 --> 01:03:09,000
你認為每次Swift編譯器版本發布時重新編譯它合理嗎？

586
01:03:09,000 --> 01:03:16,800
與其配合，還是你認為只要它在運作就可，例如，

587
01:03:16,800 --> 01:03:25,480
保留一個已經編譯的Swift 5.0的庫，並且將它與一堆框架、動態庫

588
01:03:25,480 --> 01:03:31,560
和最終執行檔（例如，用Swift 5.4編譯的）打包在一起。

589
01:03:31,560 --> 01:03:36,120
這是一個非常有趣的話題。

590
01:03:36,120 --> 01:03:44,960
所以對於我見到的人來說，你在ABI的情況上非常清楚。

591
01:03:44,960 --> 01:03:54,400
對於那些可能缺乏這種深度的人來說，基本上這個ABI特性，

592
01:03:54,400 --> 01:03:59,240
像Ruslan說的，我認為在Swift 5中才添加的。

593
01:03:59,240 --> 01:04:10,160
所以在這之前，所有的執行檔都綁定到他們實際編譯的Swift版本。

594
01:04:10,160 --> 01:04:16,240
你不能夠用 Swift 3.0 編譯某些東西，然後與 Swift 4.0 一起使用

595
01:04:16,240 --> 01:04:20,960
這就是因為這個 ABI 的差異。

596
01:04:20,960 --> 01:04:30,880
這就是為什麼如果你以前使用過 Swift，有些 Swift libraries 實際上是

597
01:04:30,880 --> 01:04:39,480
系統庫被嵌入到你的應用程式或架構中，只有這樣才能運行這些

598
01:04:39,480 --> 01:04:45,040
在運行時，因為像我說的，它們真的非常依賴於你

599
01:04:45,040 --> 01:04:52,000
用來編譯它們的 Swift 的版本，而在運行時，系統可能有不同的版本，你只會

600
01:04:52,000 --> 01:04:54,520
導致崩潰。

601
01:04:54,520 --> 01:05:02,840
但自從 Swift 5出現，我認為，這個問題得到了解決，這一直是一個目標，但其他的

602
01:05:02,840 --> 01:05:09,400
功能延遲了 ABI 的穩定性。

603
01:05:09,400 --> 01:05:17,480
現在我們有了這種穩定性，我們可以，像Ruslan說的，我們可以混合和合併，

604
01:05:17,480 --> 01:05:25,520
所以我們可以使用編譯的Swift 5模組和編譯的Swift 5.4或5.5模組一起使用，

605
01:05:25,520 --> 01:05:29,140
等等，甚至是未來的版本。

606
01:05:29,140 --> 01:05:38,520
我認為只要一切運作正常，我並不認為這是大問題，即使Swift的發佈

607
01:05:38,520 --> 01:05:46,880
不是過於頻繁，所以每幾個月重新編譯這些模組一次

608
01:05:46,880 --> 01:05:52,660
並不是太大的問題。

609
01:05:52,660 --> 01:06:00,960
另一方面，新版本的Swift可能不適合那個程式庫，

610
01:06:00,960 --> 01:06:05,240
因此可能需要一些變更，也需要考量進來。

611
01:06:05,240 --> 01:06:12,680
另一方面，這就像是更為謹慎的方法，更具前瞻性的方法

612
01:06:12,680 --> 01:06:19,840
是你可能希望將新功能用於那個Swift代碼，所以像最新的異步

613
01:06:19,840 --> 01:06:26,000
API或Swift添加的任何新事物。

614
01:06:26,000 --> 01:06:34,240
但是像我說的，如果你對你的模塊感到滿意，如果測試通過並且看似

615
01:06:34,240 --> 01:06:45,640
合適地運作，我看不出有重新編譯或重新部署該模塊的需要。

616
01:06:45,640 --> 01:06:51,000
所以嗯，這就是我看待的方式。

617
01:06:51,000 --> 01:06:56,360
沒有明確的答案是你應該還是不應該，更像是真的

618
01:06:56,360 --> 01:07:02,400
取決於整個情況。

619
01:07:02,400 --> 01:07:07,880
當然，像需要多少時間來構建，如果你需要像一個特殊的

620
01:07:07,880 --> 01:07:13,120
建立該項目的機器或配置，這裡有許多縱向的部分

621
01:07:13,120 --> 01:07:16,040
我建議您考慮一下。

622
01:07:16,040 --> 01:07:23,040
好的，非常感謝你的回答。

623
01:07:23,040 --> 01:07:25,040
還有其他問題嗎？

624
01:07:25,040 --> 01:07:31,040
哦，Sergey正在揮手。

625
01:07:31,040 --> 01:07:40,880
好的，還有一個問題，可能這並不與目前的主題100%相關，

626
01:07:40,880 --> 01:07:47,520
但我剛從認識的人那裡獲得了她們的觀點，他們是這麼認為的。

627
01:07:47,520 --> 01:07:57,580
我想問你，對於把一些項目嵌套在其他項目裡面，你有什麼看法呢？

628
01:07:57,580 --> 01:08:04,620
就像在一種情況下，我們可以有一個項目和不同的目標用於不同的框架

629
01:08:04,620 --> 01:08:11,440
或是不同的平台，比如一個項目然後我們有tvOS, macOS, iOS 和不同的

630
01:08:11,440 --> 01:08:21,080
框架或者我們可以把每一個目標包裹在它自己的項目中然後把這個項目嵌入到

631
01:08:21,080 --> 01:08:24,600
像一個大的工作區。

632
01:08:24,600 --> 01:08:32,720
這感覺像是哪種方法更好，並如何影響建構時間？

633
01:08:32,720 --> 01:08:34,200
你懂了嗎？

634
01:08:34,200 --> 01:08:36,040
嗯，我想我懂了。

635
01:08:36,040 --> 01:08:45,360
所以您在問，製作這些專案間的子依賴性是否是更好的版本，

636
01:08:45,360 --> 01:08:51,160
像是將一個專案嵌入到另一個專案中，或者保持它們在同一級別，或者只是保持所有

637
01:08:51,160 --> 01:08:55,600
目標在相同的專案中，如這些不同的設定方式。

638
01:08:55,600 --> 01:09:01,880
再次，我認為在某個程度上，當問題複雜到一定程度，答案總是

639
01:09:01,880 --> 01:09:12,160
那就看情況，而在這種情況下，我要說我真的不喜歡這種子專案設定。

640
01:09:12,160 --> 01:09:18,640
我認為對我來說這有點不自然。

641
01:09:18,640 --> 01:09:26,680
所以這就是我喜歡在essential feeds use case repo中的標準設定方式的原因，其中所有的

642
01:09:26,680 --> 01:09:29,120
這些專案都在同一級別。

643
01:09:29,120 --> 01:09:36,360
就像我解釋這些找到的隱性依賴性，基本上建置系統會得到

644
01:09:36,360 --> 01:09:45,800
它需要的所有資訊，而不使用這個選項去添加明確的目標依賴性。

645
01:09:45,800 --> 01:09:50,360
我看不出另一個原因去嵌入它們。

646
01:09:50,360 --> 01:09:55,920
當然，如果它是一個不同的專案，比如從第三方來的或是像

647
01:09:55,920 --> 01:10:01,520
那樣的，我看到的如果你不使用，我不知道，Swift Package manager或者

648
01:10:01,520 --> 01:10:09,320
另一個依賴管理器，你就從某人那裡得到一個項目，你想要

649
01:10:09,320 --> 01:10:18,440
與它做連結，再一次，你可以使用子項目的方式，或者將其保持在你的

650
01:10:18,440 --> 01:10:20,520
工作區的同一級別。

651
01:10:20,520 --> 01:10:23,520
這也是個人的偏好。

652
01:10:23,520 --> 01:10:33,960
差異其實並不大，所以你只在你的Xcode proj中得到一個專案參考

653
01:10:33,960 --> 01:10:35,680
檔案。

654
01:10:35,680 --> 01:10:45,240
我猜可能會變得過於擁擠的地方就像你得到所有這些方案

655
01:10:45,240 --> 01:10:49,600
在同一個工作空間裡面。

656
01:10:49,600 --> 01:10:53,640
所以可能會有點過多。

657
01:10:53,640 --> 01:11:01,480
要單獨啟動這個專案並且在不啟動的情況下处理Embed專案

658
01:11:01,480 --> 01:11:02,480
那個大的。

659
01:11:02,480 --> 01:11:03,480
是的。

660
01:11:03,480 --> 01:11:08,520
例如，如果你在專案中包裹了一些小的Model並且你將它嵌套在大的

661
01:11:08,520 --> 01:11:16,480
一個裡，你可以啟動它而不會把所有東西都置於你的記憶體中並且進行你的範例app包裹

662
01:11:16,480 --> 01:11:22,200
環繞你當前的範圍，一切都運作得很好。

663
01:11:22,200 --> 01:11:30,920
然後，你就可以將它鑲嵌在大的專案中，並且使你的工作流程與

664
01:11:30,920 --> 01:11:32,000
大的那個區分開來。

665
01:11:32,000 --> 01:11:39,520
我認為那是你唯一需要考慮的事情，就像你是否會推出

666
01:11:39,520 --> 01:11:43,440
只有這個專案單獨進行或者不進行？

667
01:11:43,440 --> 01:11:48,520
那是我以前唯一考慮過的方式，現在我只是在等什麼可能存在的

668
01:11:48,520 --> 01:11:50,520
障礙。

669
01:11:50,520 --> 01:11:59,160
那麼關於管理不同目標的方法，基本上是

670
01:11:59,160 --> 01:12:04,760
我們如何管理項目中的目標集。

671
01:12:04,760 --> 01:12:10,680
所以我認為有一件事要考慮，我對此一直有不好的經驗，那就是

672
01:12:10,680 --> 01:12:17,440
項目越大，像目標、項目在工作區中的數量越多，

673
01:12:17,440 --> 01:12:19,440
Xcode需要做的工作就越多。

674
01:12:19,440 --> 01:12:25,820
因此，例如，如果你使用像20個CocoaPods的源文件，每一次

675
01:12:25,820 --> 01:12:29,640
當你打開那個項目，Xcode 需要將所有東西建立索引。

676
01:12:29,640 --> 01:12:35,000
所以它需要處理許多符號，許多框架，有時候這可能導致

677
01:12:35,000 --> 01:12:36,000
不好的體驗。

678
01:12:36,000 --> 01:12:45,400
像我們的範例，它只是一個帶有框架的簡短應用程式，事實上有兩個框架，

679
01:12:45,400 --> 01:12:46,400
不同的項目。

680
01:12:46,400 --> 01:12:48,040
所以設置相當小。

681
01:12:48,040 --> 01:12:56,120
但如果你將其放大，它可能真的導致某些難以維護的東西。

682
01:12:56,120 --> 01:13:05,120 
所以這就是為什麼從該計劃中獲得的一個建議是依賴於模塊化

683
01:13:05,120 --> 01:13:12,240
並實際上試圖讓盡可能多的模塊不相互依賴。

684
01:13:12,240 --> 01:13:17,520
對於初學者來說，你可以把所有東西保持在同一個庫中，比如 git 倉庫

685
01:13:17,520 --> 01:13:20,400
可以是一個，但是你可以在那裡擁有多個項目。

686
01:13:20,400 --> 01:13:25,200
就像你說的，如果我只需要在這裡工作的話，我不知道，以此為例，Feed，

687
01:13:25,200 --> 01:13:29,040
EssentialFeed架構，我甚至不需要打開工作區。

688
01:13:29,040 --> 01:13:35,080
我只需要打開該專案，處理一部分文件，然後在那裡運行我的測試，

689
01:13:35,080 --> 01:13:37,180
確保一切都井然有序。

690
01:13:37,180 --> 01:13:47,520
然後我就獲得了非常好的開發體驗，因為測試需要的時間少，像是少了些。

691
01:13:47,520 --> 01:13:48,800
索引的速度更快。

692
01:13:48,800 --> 01:13:56,440
由於自動完成被關閉和所有那些東西，Xcode可能不會每五分鐘就重新啟動

693
01:13:56,440 --> 01:13:57,440
等等。

694
01:13:57,440 --> 01:14:06,800
根據我的經驗，大型專案總是在索引和建立周圍有這些問題。

695
01:14:06,800 --> 01:14:13,440
因此，您能創建的設定越是解耦越好。

696
01:14:13,440 --> 01:14:17,080
但這是你逐步會去接近的事情。

697
01:14:17,080 --> 01:14:22,440
所以我不會建議一開始就,我不知道,使用20個每個都只有一個檔案的模組

698
01:14:22,440 --> 01:14:25,200
只是為了達到目的就用10行。

699
01:14:25,200 --> 01:14:33,300
因此，在進行中建立專案，根據出現的情況界定模組，你可以使用這種方式

700
01:14:33,300 --> 01:14:39,560
也在程式中，你在概念上分離它們。

701
01:14:39,560 --> 01:14:44,640
你實際上並未將它們劃分到不同的目標和框架中，但你將它們保持

702
01:14:44,640 --> 01:14:47,920
分隔並清楚彼此。

703
01:14:47,920 --> 01:14:51,140
如果你需要提取它們，你可以。

704
01:14:51,140 --> 01:15:00,120
所以這都是你和你的團隊在做這些決定時需要考慮的事情。

705
01:15:00,120 --> 01:15:07,280
但我見過許多不良的工作流程，它需要花費大量的時間來建構整個

706
01:15:07,280 --> 01:15:10,080
東西，來測試它。

707
01:15:10,080 --> 01:15:15,360
只是用Xcode與之配合是一種無法忍受的體驗。

708
01:15:15,360 --> 01:15:22,320
雖然隨著時間的推移可能有所改善，但無論如何，都是值得考慮的事物。

709
01:15:22,320 --> 01:15:28,120
是的，我完全同意你所說的一切。

710
01:15:28,120 --> 01:15:34,760
我曾經有過與一個非常大的項目合作的經驗，那個叫Build的項目仿佛花了45分鐘。

711
01:15:34,760 --> 01:15:44,480
我就去吃午餐，然後我只是，對，它裡面有這70個子項目，實在是，

712
01:15:44,480 --> 01:15:46,040
實在是非常大，非常龐大的項目。

713
01:15:46,040 --> 01:15:51,680
而我在用Xcode時遇到了很多困難，而AppCode在前兩秒就凍結了。

714
01:15:51,680 --> 01:15:56,400
就像是無計可施。

715
01:15:56,400 --> 01:15:59,640
我購買了AppCode，但它完全無法運作。

716
01:15:59,640 --> 01:16:03,280
就像我連打字都做不到。

717
01:16:03,280 --> 01:16:07,200
我知道，我感同身受。

718
01:16:07,200 --> 01:16:08,200
我放棄了。

719
01:16:08,200 --> 01:16:11,440
所以現在我覺得還好。

720
01:16:11,440 --> 01:16:17,480
這是因為你開發者的體驗非常糟糕。

721
01:16:17,480 --> 01:16:22,560
我在類似的項目中經历过，你正在頭腦中切換上下文，

722
01:16:22,560 --> 01:16:27,560
你試圖完成一個任務，你有你的想法，可能已完成了實施，然而

723
01:16:27,560 --> 01:16:33,040
從構建，從測試獲取反饋需要如此之長的時間，導致你無法

724
01:16:33,040 --> 01:16:34,920
掌握你的思路。

725
01:16:34,920 --> 01:16:39,920
而你可能在此期間切換了上下文，或者跟別人聊天，或者做了其他事情。

726
01:16:39,920 --> 01:16:43,000
然後你需要返回到整個工作流程。

727
01:16:43,000 --> 01:16:45,440
這太糟糕了。

728
01:16:45,440 --> 01:16:51,000
而這對業務也是有害的，因為有了明智的決策，這是不需要的

729
01:16:51,000 --> 01:16:52,000
發生。

730
01:16:52,000 --> 01:17:00,120
比如這可能是，我不知道，人們不知道如何管理的結果

731
01:17:00,120 --> 01:17:01,120
那麼的混亂。

732
01:17:01,120 --> 01:17:04,740
所以他們從一些小事情開始，他們不知道如何將其擴大。

733
01:17:04,740 --> 01:17:12,320
然後一切都變成了一團糟，很多人都提出了這些理論，就是

734
01:17:12,320 --> 01:17:16,800
每隔一段時間你就要從頭開始編寫你的項目。

735
01:17:16,800 --> 01:17:23,360
而這並不是很好，因為他們用同樣的原則，還是會依照原樣編寫

736
01:17:23,360 --> 01:17:24,400
的方式。

737
01:17:24,400 --> 01:17:29,240
所以再過三四年，還會是一樣。

738
01:17:29,240 --> 01:17:39,760
所以我思考這就是為何這門課程建立在主程式，主要的課程之上。

739
01:17:39,760 --> 01:17:47,480
這就是我們關於模塊化和潔淨架構的所有建議之所在，

740
01:17:47,480 --> 01:17:51,040
潔淨設計，模塊間的低耦合。

741
01:17:51,040 --> 01:17:57,880
所有這些原則如果你希望進行一個你不討厭的項目的話都非常重要。

742
01:17:57,880 --> 01:17:59,240
你並不厭倦。

743
01:17:59,240 --> 01:18:01,840
所以，就是這樣。

744
01:18:01,840 --> 01:18:06,520
無論如何，謝謝你們邀請我。

745
01:18:06,520 --> 01:18:13,280
如果對於這些議題有任何特定問題，我們可以，一如往常，Slack就是

746
01:18:13,280 --> 01:18:20,140
解決方案，我們會嘗試給出一個堅實的答案。

747
01:18:20,140 --> 01:18:23,820
有時候需要時間來做到這一點，但這沒關係。

748
01:18:23,820 --> 01:18:31,560
我沒有回答到Ruslan的觀點，所以45分鐘的建立其實是未處理的技術債務和或者


749
01:18:31,560 --> 01:18:33,920
團隊中缺少建構工程師。

750
01:18:33,920 --> 01:18:35,580
對，那非常正確。

751
01:18:35,580 --> 01:18:40,940
但有時候即使增加建構工程師到團隊中也無法解決問題。

752
01:18:40,940 --> 01:18:49,100
所以我曾經在一個專案上工作，我們在增加建構工程師到團隊後，

753
01:18:49,100 --> 01:18:58,560
實際上進入了一個每四個小時就進行一次在 CI 上的建構以及運行測試的週期。

754
01:18:58,560 --> 01:19:05,500
那份情況真的很糟糕，因為你每次想要在 pull request 上得到回饋，

755
01:19:05,500 --> 01:19:12,880
或者某些事情，你必須等上四個小時然後才能獲得一些結果，有時候還會失敗

756
01:19:12,880 --> 01:19:16,340
然後開始查看為什麼會出現那樣的情況。

757
01:19:16,340 --> 01:19:23,800
所以如果到達了，我認為問題在於如果你讓它達到45分鐘，像當


758
01:19:23,800 --> 01:19:29,840
它已過去，我知道10、15分鐘，你開始，你需要開始問像是為什麼的問題

759
01:19:29,840 --> 01:19:31,340
這個需要這麼久？

760
01:19:31,340 --> 01:19:33,820
我們怎麼可以改善它？

761
01:19:33,820 --> 01:19:40,760
例如，我知道我們，Kyle和Mike在指導會議上談過這個。

762
01:19:40,760 --> 01:19:47,720
我們如何能夠重新編譯，測試，並只重新部署那些有變動的模組？

763
01:19:47,720 --> 01:19:53,780
所以當你知道你的改變只影響到，我不

764
01:19:53,780 --> 01:19:56,440
知道，像是只有一個元件。

765
01:19:56,440 --> 01:20:03,420
所以有不同的方法可以用來改善這些，但你首先

766
01:20:03,420 --> 01:20:04,740
必須關心它。

767
01:20:04,740 --> 01:20:13,340
所以如果團隊把這變成了高優先順序，那我相信肯定可以找到解決方案


768
01:20:13,340 --> 01:20:16,380
當然，如果知識在那裡。

769
01:20:16,380 --> 01:20:19,300
好的。

770
01:20:19,300 --> 01:20:21,040
這很好。

771
01:20:21,040 --> 01:20:27,020
感謝你們願意留到最後並參與這個演講。

772
01:20:27,020 --> 01:20:28,820
這很好。

773
01:20:28,820 --> 01:20:32,380
所以感謝你們，希望很快再見。

774
01:20:32,380 --> 01:20:34,740
再見。