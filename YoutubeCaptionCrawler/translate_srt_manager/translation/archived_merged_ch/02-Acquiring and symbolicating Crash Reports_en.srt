

1
00:00:00,800 --> 00:00:07,040
大家好，歡迎回來參加我們的工具系列講座。今天我們將談論 Crash reports。

2
00:00:08,000 --> 00:00:14,800
我知道這對許多開發者來說是個遣人不樂的話題。我記得我經常為此而苦惱

3
00:00:14,800 --> 00:00:21,040
每當我被分配去修復一個 Crash，卻完全無法理解該報告本身

4
00:00:21,040 --> 00:00:26,720
以及如何將所有的資訊組織在一起。為了這個，我們在這個系列中，

5
00:00:26,720 --> 00:00:34,080
我們試著揭秘如何著手修復 Crash 的過程。今天我們將著重於

6
00:00:34,080 --> 00:00:40,080
如何獲取 Crash reports 以及如何進行符號化操作，這是從

7
00:00:40,080 --> 00:00:48,880
Crash 到修復的重要部分。所以今天我們將介紹我們可以獲取 Crash reports 的方式。我們將看到什麼


8
00:00:48,880 --> 00:00:55,680
Symbolication是什麼以及它如何運作，我們將解釋Symbolication的不同層次

9
00:00:55,680 --> 00:01:00,640
以及如何獲取完全Symbolicated的崩潰報告，這樣我們就可以正確地閱讀它。

10
00:01:04,160 --> 00:01:11,120
當我們與其他人分享我們的應用程式時，我們有以下選擇。我們可以內部共享

11
00:01:11,120 --> 00:01:20,480
通過TestFlight在我們的團隊內部，這是Apple提供的一項服務，你可以上傳你的應用程式

12
00:01:20,480 --> 00:01:26,240
構建到AppStore並與明確的使用者列表在內部共享。

13
00:01:29,120 --> 00:01:34,800
你也可以通過Firebase Distribution或者其他第三方服務來分享。

14
00:01:36,400 --> 00:01:43,520
它們與TestFlight非常相似，只是在這種情況下，你將分發一個定向

15
00:01:43,520 --> 00:01:50,800
或企業版的構建再到一個明確使用者的列表，而與TestFlight不同的是

16
00:01:50,800 --> 00:01:56,880
你分發的是AppStore版本的你的構建。而你總是可以手動執行，

17
00:01:57,520 --> 00:02:07,040
也就是說建立、歸檔並導出為IPA檔案，並按你想要的方式傳送該IPA檔案，

18
00:02:07,040 --> 00:02:16,800
透過電郵或其他共享選項，使用者將用Xcode或其他工具來安裝它。

19
00:02:19,280 --> 00:02:25,840
你也可以在你的團隊之外分享，即外部，而主要的機制就是

20
00:02:25,840 --> 00:02:33,200
AppStore，這是你的應用程式變為公開的地方，所以AppStore上的每個人都可以下載。

21
00:02:33,200 --> 00:02:38,320
在你的應用程式分發給客戶之後，你可以藉由收集

22
00:02:38,320 --> 00:02:46,080
崩潰報告和診斷日誌來找到改進它的方法。為此，Apple提供一個報告服務，該服務收集來自

23
00:02:46,080 --> 00:02:54,160
使用TestFlight或AppStore分發的應用程式的用戶的日誌。該服務可以識別出

24
00:02:54,160 --> 00:03:01,840
將過去一年的日誌轉換為可以下載的Crash、energy和metric報告，然後將它們發送出去

25
00:03:01,840 --> 00:03:11,360
給用戶。一般而言，該服務會執行以下操作。它從應用程序和應用程序

26
00:03:11,360 --> 00:03:18,800
在用戶設備上運行的擴展收集日誌。它將這些日誌進行符號化，這意味著替換記憶體位址

27
00:03:18,800 --> 00:03:25,600
為人類可讀的名稱，我們將在這堂課中深入瞭解符號化。該服務

28
00:03:25,600 --> 00:03:33,680
將堆疊跟蹤與日誌進行比較以辨識並將相似日誌集合到報告中。將個人用戶數據從日誌中移除

29
00:03:33,680 --> 00:03:41,680
存於日誌中。它提供事件發生的獨特設備的總數。提供

30
00:03:41,680 --> 00:03:47,440
每份報告的日誌樣本集，並每日更新報告。

31
00:03:47,440 --> 00:03:53,280
注意，此服務僅從用戶選擇加入的設備收集日誌


32
00:03:53,280 --> 00:03:58,560
與開發者分享這些資訊，所以要考慮你可能沒有完整的

33
00:03:58,560 --> 00:04:04,720
圖片，因為一些用戶可能因為隱私擔憂或甚至缺乏

34
00:04:04,720 --> 00:04:12,560
對他們被要求做什麼的理解而不同意分享這一點。所以你看到這裡的設定，

35
00:04:12,560 --> 00:04:20,800
與應用開發者分享選項，該選項默認情況下是關閉的，你也會看到提示

36
00:04:21,360 --> 00:04:28,080
TestFlight用戶在他們的應用崩潰時獲得的。要麼這個，要麼那個。

37
00:04:31,920 --> 00:04:37,040
由該服務編譯的所有報告都可以在Xcode的組織者中找到，具有

38
00:04:37,040 --> 00:04:43,440
在Crashes部分下，或者你也可以在AppStoreConnect儀表板上查看它

39
00:04:43,440 --> 00:04:51,440
目前我們將主要關注Crash組織者。想看它如何運作，我們切換到Xcode。


40
00:04:53,840 --> 00:04:58,640
我在窗口組織器中選擇了我的應用程序

41
00:04:58,640 --> 00:05:08,880
然後我將選擇崩潰部分，這顯示了當前選定的應用程序的所有崩潰，

42
00:05:08,880 --> 00:05:16,880
無論它們來自AppStore還是TestFlight版本。第一列包含每個報告或者，

43
00:05:16,880 --> 00:05:25,040
可以說是崩潰的組。第二列包含來自AppStore和

44
00:05:25,040 --> 00:05:31,200
每個報告或說是崩潰的整組。第二列包含了堆疊追蹤的

45
00:05:31,200 --> 00:05:38,640
崩潰線程，並且在右邊還有一個助手提供了關於

46
00:05:38,640 --> 00:05:45,520
應用版本，一些如設備類型，應用版本，操作系統，版本釋放等的統計信息。

47
00:05:45,520 --> 00:05:54,640
您可以看到筆記，或者通過使用這個標籤選擇器，甚至TestFlight用戶的評論。

48
00:05:57,120 --> 00:06:01,920
當你處理完當機問題後，你終於可以將它標記為已解決。

49
00:06:04,640 --> 00:06:08,480
所以這就是這個Crash organizer的主要概念。

50
00:06:08,480 --> 00:06:11,840
當然還有更多的事情，但我會讓你自己去發現。

51
00:06:11,840 --> 00:06:17,120
這個Crashes organizer就是Apple提供的一個現成解決方案，用於監控你的app當機情況。

52
00:06:17,680 --> 00:06:24,720
這是一個不錯的工具，所以請隨意使用它。但你必須知道還有其他替代品。

53
00:06:24,720 --> 00:06:30,880
像Firebase Crashlytics、Sentry、Instabug等第三方服務，

54
00:06:30,880 --> 00:06:35,680
也可以做類似的錯誤報告收集工作，並將它們顯示在儀表板上。

55
00:06:35,680 --> 00:06:40,240
在Apple的報告服務和第三方調查之間有一個重要區別是，

56
00:06:40,240 --> 00:06:45,600
以下。Apple只會從選擇共享的設備中收集報告

57
00:06:45,600 --> 00:06:51,680
與開發人員共享這些報告，如我之前所示。在第三方服務的情況下，

58
00:06:51,680 --> 00:06:57,120
他們可能不會詢問用戶的選擇，因此他們可以收集所有報告

59
00:06:57,120 --> 00:06:58,640
從用戶的設備。

60
00:06:58,640 --> 00:07:04,000
TestFlight和AppStore為您應用的每個提交版本收集崩潰報告。

61
00:07:04,000 --> 00:07:09,200
如果您在提交時包含符號信息，Apple的服務也會進行符號化，

62
00:07:09,200 --> 00:07:10,640
構建到AppStore。

63
00:07:14,640 --> 00:07:20,640
符號化的過程就是使崩潰報告可以提供給

64
00:07:20,640 --> 00:07:26,640
AppStore。符號化的過程就是使崩潰報告可以提供給

65
00:07:26,640 --> 00:07:32,640
透過將地址和位元替換為您專案中的檔案和實體名稱的方式，由開發人員進行。

66
00:07:34,640 --> 00:07:39,120
來自客戶的崩潰報告，發送診斷和使用資訊以此方式呈現

67
00:07:39,120 --> 00:07:44,640
在Crash的組織者中。您的應用程式的TestFlight用戶自動與您共享崩潰報告，

68
00:07:44,640 --> 00:07:50,640
無論設備是否設定為共享診斷和使用數據，而AppStore

69
00:07:50,640 --> 00:07:56,640
用戶必須選擇與您共享這些數據，就像我之前在設定中所示。

70
00:08:00,640 --> 00:08:08,640
無論您是使用Apple的服務還是第三方服務，都有一類報告

71
00:08:08,640 --> 00:08:16,640
這些報告缺失或者無法被服務收集，為了得到這些你需要

72
00:08:16,640 --> 00:08:22,640
從設備中手動收集，我們會在一會兒看到這究竟意味著什麼，但現在

73
00:08:22,640 --> 00:08:30,640
讓我們專注於報告的類型。首先，有watchdog事件，如慢速app的啟動時間、慢速app的恢復時間等等，

74
00:08:30,640 --> 00:08:38,640
如果你記得的話，watchdog是一個只終止無回應app的服務。

75
00:08:38,640 --> 00:08:46,640
還有無效的代碼簽名Crashes，以及熱力事件，

76
00:08:46,640 --> 00:08:54,640
當一個裝置因為app過度使用太多CPU而過熱，或者是Jetsam事件，其中app的記憶體使用量過高，

77
00:08:54,640 --> 00:09:04,640
因此，我們已經談論過如何透過Crash組織者自動收集Crash報告，

78
00:09:04,640 --> 00:09:12,640
接下來看看如何手動進行。也就是說，為了收集這些特別類型的Crashes，

79
00:09:12,640 --> 00:09:18,640
或者是任何類型的，你可以在不需要任何服務協助的情況下，手動進行。這種方式就像是+

80
00:09:18,640 --> 00:09:24,640
備用方案，使用者可以將他們的設備連接到電腦並收集日誌和崩潰

81
00:09:24,640 --> 00:09:32,640
報告，並與開發者共享。對於這點，我們將使用來自

82
00:09:32,640 --> 00:09:40,640
Xcode的另一個視窗，也就是設備與模擬器，如你們看到我現在已經連接了我的iPhone SE2，

83
00:09:42,640 --> 00:09:50,640
當我選擇它時，有很多關於此設備的調試信息。最重要的部分

84
00:09:50,640 --> 00:09:58,640
就是查看設備日誌，它將顯示我在所選設備上的所有日誌。讓我

85
00:09:58,640 --> 00:10:07,640
使這個視窗變大。所以在這裡，我們有一個包含我目前設備上所有日誌的列表，我們可以

86
00:10:07,640 --> 00:10:17,640
透過更改選擇或右擊來檢查這些日誌，我們準備進行以下操作


87
00:10:17,640 --> 00:10:24,640
刪除它們的選項，導出它們，這只會複製這個日誌檔案，這是一個文本文件在

88
00:10:24,640 --> 00:10:34,640
我的電腦上，或者觸發一個實現再次符號化，額，就是重複整個符號化的過程。

89
00:10:36,640 --> 00:10:44,640
所以這就是你如何手動從連接的設備中收集它們。或者你可以共享它們

90
00:10:44,640 --> 00:10:54,640
直接從設備上。在iOS上你去設置，隱私，分析和改進，分析

91
00:10:54,640 --> 00:11:02,640
數據，然後你會得到一個與我剛才向你展示的日誌完全相同的列表，然後你可以開啟每個日誌

92
00:11:02,640 --> 00:11:10,640
進行單獨的查看，並共享它。如果你正在尋找一個特別的報告，該日誌名稱

93
00:11:10,640 --> 00:11:18,640
從應用程式的二進制名稱開始，並且它有一個時間戳，或者對於高內存來說，它是一個 Jetsam 事件

94
00:11:18,640 --> 00:11:30,640
使用 Crash 報告。這是在 iOS 上。在 macOS 上，我們可以使用 console 應用程式。然後我們再次看到一個列表，

95
00:11:30,640 --> 00:11:39,640
這次是我在 Mac 上，更具體地說，在模擬器上發生的 Crash，我們可以對其進行檢查，

96
00:11:39,640 --> 00:11:48,640
然後也有一個分享按鈕允許我們分享 Crash。或者右鍵點擊將在

97
00:11:48,640 --> 00:11:55,640
Finder 中顯示它，然後我們可以採取該文本文件並隨意使用它。所以這就是一些

98
00:11:55,640 --> 00:12:03,640
手動收集這些報告的方法選項。注意，你只需要這種方法

99
00:12:03,640 --> 00:12:09,640
當你知道一個或多個使用者遇到了 Crash，但你無法在 Xcode Organizer 中找到它

100
00:12:09,640 --> 00:12:16,640
或者在第三方的服務平台上，或者是前面提到的幾種類型的 Crash

101
00:12:16,640 --> 00:12:27,640
這些都無法透過 organizer 獲得。如果你在 Debugging 你的應用程式時遇到 Crash

102
00:12:27,640 --> 00:12:34,640
使用 Xcode，debugger 會跳出 Crash，這樣你就可以檢查你的應用程式狀態。如果你希望

103
00:12:34,640 --> 00:12:41,640
為這個問題收集完整的 Crash 報告，你必須脫離 debugger，為了這麼做你可以

104
00:12:41,640 --> 00:12:52,640
使用 Xcode 菜單，debug，這裡有一個 detach 的選項。所以你只需脫離 debugger

105
00:12:52,640 --> 00:12:57,640
然後 Crash 報告將在你，我不知道，你在 Debugging 時重現 Crash 的情況下產生

106
00:12:57,640 --> 00:13:03,640
您想看到Crash報告會是什麼樣子。透過這樣做，您允許應用程序完成

107
00:13:03,640 --> 00:13:11,640
崩潰，並讓作業系統產生您想看的Crash報告。

108
00:13:11,640 --> 00:13:19,640
現在讓我們談論symbolication。當一個應用程序Crashes，作業系統收集診斷信息

109
00:13:19,640 --> 00:13:24,640
關於應用程序在Crash時正在做什麼。Crash報告中最重要的部分之一是

110
00:13:24,640 --> 00:13:32,640
報告在十六進制地址的Thread backtraces。您將這些backtraces翻譯

111
00:13:32,640 --> 00:13:39,640
為可讀的函數名稱和源碼中的行數，這個過程稱為symbolication，並且

112
00:13:39,640 --> 00:13:46,640
然後使用該資訊來了解您的應用程序為何崩潰。在許多情況下，Crash被組織起來

113
00:13:46,640 --> 00:13:53,640
在Xcode中，系統會自動將崩潰報告進行符號化。一般而言，符號化是一種

114
00:13:53,640 --> 00:13:59,640
機制，用於轉化或翻譯我們的設備在運行時如何看待我們的應用程序的方式，以內存

115
00:13:59,640 --> 00:14:07,640
地址和指令的形式，如左列所示，回到我們作為開發者如何看待它的方式，以函數

116
00:14:07,640 --> 00:14:15,640
名稱和文件的形式，如我們在右列中看到的。換句話說，符號化的過程是

117
00:14:15,640 --> 00:14:27,640
將內存地址替換為人類可讀的函數名稱和行號。

118
00:14:27,640 --> 00:14:33,640
讓我們來看一下我使用EssentialApp項目生成的一個崩潰報告。

119
00:14:33,640 --> 00:14:39,640
因為符號化的最常見用途是將設備上由操作系統生成的包含內存地址和指令的崩潰報告

120
00:14:39,640 --> 00:14:45,640
轉為人類能讀懂的格式。

121
00:14:45,640 --> 00:14:56,640
提到明確的檔案名稱，函式名稱，和行數。這是指記憶體地址

122
00:14:56,640 --> 00:15:05,640
來自這個 Crash 報告的 backtrace 部分。但這不只是 symbolication 的唯一用途。

123
00:15:05,640 --> 00:15:14,640
Xcode 使用 symbolication 來在 Debugging 或運行 Instruments 時解析和顯示符號。

124
00:15:14,640 --> 00:15:19,640
在 runtime 將記憶體地址轉譯為二進制地址，

125
00:15:19,640 --> 00:15:25,640
然後使用除錯符號將這些二進制地址轉換為相應的檔案名稱，

126
00:15:25,640 --> 00:15:31,640
函式名稱和行數的過程相當複雜，涉及多種工具。如果你需要深入了解

127
00:15:31,640 --> 00:15:39,640
這些細節，我建議你查看這個來自 WWDC 2021 的 session，這個 session 的名字叫

128
00:15:39,640 --> 00:15:49,640
Symbolication Beyond the Basics。我會在演講文章中增加一個鏈接。

129
00:15:49,640 --> 00:15:55,640
為了進行符號化，我們需要獲取與二進制文件對應的調試符號

130
00:15:55,640 --> 00:16:02,640
由進程或我們想要符號化的Crash報告加載。調試符號是額外的信息

131
00:16:02,640 --> 00:16:09,640
在構建過程中產生，補充了我們構建的二進制文件。這些調試信息使我們能夠

132
00:16:09,640 --> 00:16:15,640
在Xcode上調試應用程序，剖析以及進行符號化。你可以將其看作是一種

133
00:16:15,640 --> 00:16:22,640
二進制碼中的指令和我們的源文件以及實體之間的映射。調試符號或調試

134
00:16:22,640 --> 00:16:28,640
信息是在構建過程中產生，並且要麼嵌入到二進制文件中，要麼作為

135
00:16:28,640 --> 00:16:36,640
比如DSYM的單獨文件儲存。有的不同類型調試信息是由Xcode產生的

136
00:16:36,640 --> 00:16:45,640
建置系統。我們將快速地過一遍它們。首先，函數起始位置，這些擁有最少的

137
00:16:45,640 --> 00:16:50,640
源代碼細節，因為它們只包含每個函數開始的地址，但沒有其他的

138
00:16:50,640 --> 00:16:57,640
資訊，所以它們不包含函數名稱或是檔案名稱等事項。函數起始位置的

139
00:16:57,640 --> 00:17:05,640
資訊被嵌入到二進制檔中，主要是供除錯器使用。所以這只是每個

140
00:17:05,640 --> 00:17:14,640
函數開始的地址。接下來的層級是 enlist symbol tables。它們包含有額外的資訊，

141
00:17:14,640 --> 00:17:20,640
除了函數起始位置以外，因此它們包含函數名稱，並且也被嵌入到二進制檔中。

142
00:17:20,640 --> 00:17:25,640
雖然它們包含比函數起始位置更多的資訊，但是它們仍然缺少重要的

143
00:17:25,640 --> 00:17:32,640
進行完整符號化所需的資訊。例如，關於本地或私有函數的資訊


144
00:17:32,640 --> 00:17:42,640
可能會缺少。此外，這許多符號都會在發布版建構中被剔除，這代表它們被排除了。

145
00:17:42,640 --> 00:17:50,640
符號表被一大堆建構設定所影響，這些都包含剔除名稱。

146
00:17:50,640 --> 00:18:01,640
所以在複製過程中剔除除錯符號，剔除連接產品，剔除樣式，剔除Swift符號。

147
00:18:01,640 --> 00:18:07,640
所以總結一下，功能開始和編列符號表只擁有部分需要的資訊

148
00:18:07,640 --> 00:18:14,640
做為符號化。它們直接包含在二進位數據中。實際上，所有你

149
00:18:14,640 --> 00:18:21,640
生產的二進位數據都至少會包含功能開始的資訊。然而編列符號表的訊息

150
00:18:21,640 --> 00:18:27,640
則取決於我提到的建構設定，所以可能有，也可能沒有。要注意的重點是


151
00:18:27,640 --> 00:18:34,640
你應該從這裡得出的結論是，如果你見到的符號化應用得不完全，所以只看到部分的

152
00:18:34,640 --> 00:18:39,640
信息，可能是因為它僅使用了部分層次的調試符號來完成，

153
00:18:39,640 --> 00:18:46,640
並且缺少了最重要和最完整層次的調試符號，這就是DWARF。

154
00:18:46,640 --> 00:18:55,640
那我們來談談DWARF。就像我說的，DWARF是調試信息詳細程度最豐富的層次。

155
00:18:55,640 --> 00:19:01,640
它試圖描述所有事物，像函數名稱、文件名稱、行數以及甚至包括

156
00:19:01,640 --> 00:19:08,640
編譯優化的信息。對於符號化來說，編譯優化是一個棘手的主題，

157
00:19:08,640 --> 00:19:15,640
因為我們需要所有關於已經應用的優化信息。這些優化基本上就是

158
00:19:15,640 --> 00:19:23,640
source code 變動會改變編譯器在生成二進制檔前所做的更動，所以結果是最佳化的。

159
00:19:23,640 --> 00:19:29,640
一個編譯器優化的例子是将函式的內容直接插入，而不是定義該

160
00:19:29,640 --> 00:19:35,640
函式然後調用它，這樣會需要更多的時間和記憶體，因為體內容和參數需要被

161
00:19:35,640 --> 00:19:45,640
加載到棧上。所以作為一個習題，在我們的 EssentialApp 的項目中，在 SceneDelegate，

162
00:19:45,640 --> 00:19:54,640
willConnectToScene 函式調用了一個 configureWindow 函式，並且是唯一一

163
00:19:54,640 --> 00:20:01,640
個調用這個函式的函式。所以如果我們在發行版本中啟用了優化，編譯器可能會

164
00:20:01,640 --> 00:20:09,640
選擇把 configureWindow 函式直接插入到原處。這意味著它將取出函式体，刪除這個函式，

165
00:20:09,640 --> 00:20:15,640
因此它將永遠不會存在，並將調用地點替換為函數的主體。

166
00:20:15,640 --> 00:20:24,640
這將導致執行更快，因為我們不需要在堆疊上加載這個函數，

167
00:20:24,640 --> 00:20:33,640
但這實在難以符號化，因為我們需要所有關於源代碼的資訊，

168
00:20:33,640 --> 00:20:39,640
以及在優化前的狀態，已應用了哪些優化等等。所以除非我們有完整的

169
00:20:39,640 --> 00:20:48,640
DWARF信息，我們實在無法反向符號化。這僅僅是一個練習。

170
00:20:48,640 --> 00:20:53,640
再次，對於有關調試符號以及他們如何被用於符號化的更多細節，

171
00:20:53,640 --> 00:20:57,640
請回顧我推薦的WWDC會議。

172
00:21:00,640 --> 00:21:07,640
buildSetting debugInformationFormat控制調試信息的格式。

173
00:21:07,640 --> 00:21:18,640
它有兩種選項，DWARF和與DSYM的DWARF。起初，這可能會令人困惑，因為兩種選項都

174
00:21:18,640 --> 00:21:28,640
包含DWARF，但是這兩種選項間調試資訊的詳細程度是不同的。

175
00:21:28,640 --> 00:21:35,640
獨立使用DWARF將生成直接包含在生成的二進制檔中的調試資訊，

176
00:21:35,640 --> 00:21:45,640
而與DSYM的DWARF則將創造可能的最多調試資訊並在DSYM檔案裡輸出。

177
00:21:45,640 --> 00:21:53,640
如你可能知道，Apple建議在調試建立時使用DWARF設置，並在發布建立時使用與DSYM的DWARF，

178
00:21:53,640 --> 00:22:01,640
因為發布建立需要來自DSYM的所有額外細節以進行象徵解讀和更多。

179
00:22:01,640 --> 00:22:09,640
就效能方面來說，產生並儲存所有的調試資訊可能需要時間和額外的儲存空間。

180
00:22:09,640 --> 00:22:14,640
這就是為什麼我們並不總是需要完整等級的調試資訊細節。

181
00:22:14,640 --> 00:22:24,640
如果我們使用DWARF與DSYM進行調試建構，它將需要消耗更多時間，

182
00:22:24,640 --> 00:22:30,640
但我們希望調試建構可以快速完成，所以我們不進行這樣的操作。

183
00:22:30,640 --> 00:22:38,640
另一方面，我們希望優化釋出版本的建構，這就是為什麼我們作為編譯器，

184
00:22:38,640 --> 00:22:44,640
要應用各種優化方式，如減少二進制大小或使代碼運行更快，

185
00:22:44,640 --> 00:22:53,640
我們已在之前的建構設定課程中談過這個問題，關於優化的選項。

186
00:22:53,640 --> 00:23:00,640
但這裡最重要的一點是，我們希望釋出版本的建構要是優化的，

187
00:23:00,640 --> 00:23:07,640
因此我們也想要生成DSYM，以便我們可以將其符號化。

188
00:23:07,640 --> 00:23:13,640
這也減小了已安裝的應用程式大小，因為在用戶的設備上安裝時，

189
00:23:13,640 --> 00:23:18,640
我們僅附上應用程式二進位碼，但沒有DSYM。

190
00:23:18,640 --> 00:23:25,640
當你以DSYM調試信息格式構建時，你會看到你建造的每個二進位碼都有一個DSYM資料夾，

191
00:23:25,640 --> 00:23:28,640
並且已經開啟設定。

192
00:23:28,640 --> 00:23:32,640
然後你將使用這些DSYM進行符號化。

193
00:23:32,640 --> 00:23:35,640
所以，讓我們看看他們的樣子。

194
00:23:35,640 --> 00:23:44,640
我這裡有一份DSYM的副本，所以這就是EssentialApp, DSYM。

195
00:23:44,640 --> 00:23:50,640
如果我們使用“顯示程序包內容”，你會看到它有一個內容資料夾，

196
00:23:50,640 --> 00:23:55,640
其中包括了Info.plist以及包含DWARF資料夾的資源資料夾。

197
00:23:55,640 --> 00:24:03,640
最後，有一個1.7兆字節的二進制文件，其中包含所有這些調試符號，關係，

198
00:24:03,640 --> 00:24:07,640
以及我在DWARF格式中提到的所有其他資訊。

199
00:24:07,640 --> 00:24:12,640
所以它的樣子就是這樣。

200
00:24:12,640 --> 00:24:20,640
請注意，如果您正在使用Bitcode並上傳您的應用，Apple服務將重新編譯您的應用，

201
00:24:20,640 --> 00:24:23,640
所以你將得到一套新的DSYMs。

202
00:24:23,640 --> 00:24:29,640
您應該使用我剛剛顯示的Xcode Organizer來下載這些，但這次選擇檔案，

203
00:24:29,640 --> 00:24:36,640
我將選擇我的應用，對於每次建立，這裡都有一個下載調試符號按鈕，

204
00:24:36,640 --> 00:24:43,640
這將下載所有新的DSYMs到我的檔案夾中。

205
00:24:43,640 --> 00:24:46,640
現在讓我們看看符號化實際上是如何工作的。


206
00:24:46,640 --> 00:24:52,640
對於這一點，我將使用一個三種狀態的backtrace樣本，

207
00:24:52,640 --> 00:24:58,640
不加符號（unsymbolicated）、部分加符號（partially symbolicated）和完全加符號（fully symbolicated）。

208
00:24:58,640 --> 00:25:05,640
在未應用任何符號化（symbolication）的設備上生成的崩潰報告看起來就像這樣。

209
00:25:05,640 --> 00:25:07,640
至少回溯部分（the backtrace section）是這樣。

210
00:25:07,640 --> 00:25:09,640
這只是地址和偏移量。

211
00:25:09,640 --> 00:25:15,640
因此，除非你知道如何閱讀二進制代碼，否則這對我們來說沒有用。

212
00:25:15,640 --> 00:25:23,640
每一行中的地址加偏移量就是我之前提到的函數開始調試符號的結果。

213
00:25:23,640 --> 00:25:31,640
由於它們只包含每個功能開始的地址，這就是你在這裡看到的。

214
00:25:31,640 --> 00:25:35,640
沒有其他信息，如函數名。

215
00:25:35,640 --> 00:25:40,640
所以，如你所見，這是相當無用的。

216
00:25:40,640 --> 00:25:45,640
在這樣一個崩潰報告上運行symbolication，但沒有DSYM的存取權，

217
00:25:45,640 --> 00:25:48,640
將導致部分的symbolication。

218
00:25:48,640 --> 00:25:53,640
這是因為symbolication將使用嵌入在二進制文件中的調試符號

219
00:25:53,640 --> 00:25:58,640
以及存在於機器上的系統框架的調試符號。

220
00:25:58,640 --> 00:26:05,640
部分symbolicated的崩潰報告對於一些回溯幀有函數名。

221
00:26:05,640 --> 00:26:14,640
以及您的二進制文件的十六進制地址。

222
00:26:14,640 --> 00:26:19,640
部分symbolicated的崩潰報告可能包含足夠的資訊來理解崩潰，

223
00:26:19,640 --> 00:26:23,640
這取決於崩潰的類型以及回溯中哪些幀被symbolicated。

224
00:26:23,640 --> 00:26:29,640
然而，您仍應該在Xcode中symbolicate崩潰報告，使報告完全symbolicated，

225
00:26:29,640 --> 00:26:34,640
這將使您對崩潰有完整的理解。

226
00:26:34,640 --> 00:26:42,640
最後，當所有的偵錯符號都可用時，我們可以獲得完全符號化的Crash 報告

227
00:26:42,640 --> 00:26:45,640
供符號化工具使用。

228
00:26:45,640 --> 00:26:53,640
它在回溯的每一幀上都有函式名稱，因此包括我們的應用程式二進位碼，

229
00:26:53,640 --> 00:26:56,640
例子中是 touch canvas。

230
00:26:56,640 --> 00:27:02,640
每一幀代表指定Thread正在運行的單一功能代碼

231
00:27:02,640 --> 00:27:07,640
並且提供了來自您的應用程式和在您的應用程式Crash時執行的OS framers的函式視圖

232
00:27:07,640 --> 00:27:11,640
在您的應用程式Crash的時刻。

233
00:27:11,640 --> 00:27:16,640
完全符號化的Crash 報告讓您最了解Crash的內容。

234
00:27:16,640 --> 00:27:22,640
完全符號化的Crash 報告需要使用完整詳細的偵錯資訊來進行符號化，

235
00:27:22,640 --> 00:27:29,640
所以我們需要所有二進位碼的desims。

236
00:27:29,640 --> 00:27:37,640
如果我們回到我收集的其中一份完整Crash 報告

237
00:27:37,640 --> 00:27:43,640
並查看二進制圖像部分，

238
00:27:43,640 --> 00:27:52,640
我們看到每個二進制有一個獨特的標識符。

239
00:27:52,640 --> 00:28:01,640
並且這個標識符將被用來連接回與該二進制對應的desim，

240
00:28:01,640 --> 00:28:07,640
因為二進制與其對應的desim之間有一一對應的關係，

241
00:28:07,640 --> 00:28:14,640
由這個獨特的ID表示。

242
00:28:14,640 --> 00:28:27,640
因此，在我們的EssentialApp的例子中，我們看到我們的標識符0, 4, bc, 39, a9，等等。

243
00:28:27,640 --> 00:28:35,640
我們可以使用dwarfdump命令從desims和app binaries中檢索ID。

244
00:28:35,640 --> 00:28:38,640
讓我們看看它是如何工作的。

245
00:28:38,640 --> 00:28:45,640
首先，如果我對像EssentialApp這樣的app binary使用 --UUID，


246
00:28:45,640 --> 00:28:51,640
它將打印一個UUID，這個非常類似我剛剛顯示的那一個。

247
00:28:51,640 --> 00:28:58,640
實際上是一樣的，只是格式不同，所以它仍然是0，4，bc，39，a9，

248
00:28:58,640 --> 00:29:07,640
只是在崩潰報告中顯示的ID全都是小寫的，並沒有破折號，

249
00:29:07,640 --> 00:29:14,640
而 dwarfdump 使用的則帶有一些破折號，並全部是大寫的。

250
00:29:14,640 --> 00:29:21,640
但除此之外，所有的數字和字母都是一樣的，我向你保證。

251
00:29:21,640 --> 00:29:26,640
所以這就是如何打印app二進制的UUID。

252
00:29:26,640 --> 00:29:32,640
如果你想打印出desim的UUID，使用相同的指令，

253
00:29:32,640 --> 00:29:38,640
你會發現這是相同的ID，因為這兩個是匹配的。

254
00:29:38,640 --> 00:29:48,640
同一個Image，同一個desim，他們對應到我剛剛展示給你們的Crash report。

255
00:29:48,640 --> 00:29:55,640
所以像我說的，每一份Crash report，每一個binary都會被確實匹配到一個desim，

256
00:29:55,640 --> 00:30:01,640
並且匹配是基於這個UUID完成的。

257
00:30:01,640 --> 00:30:04,640
每一次的build UUID都會對每一次的build唯一，

258
00:30:04,640 --> 00:30:14,640
所以即使你從同一份確切的來源重新建構，每一次這個UUID都將會變更。

259
00:30:14,640 --> 00:30:20,640
這就是為何它對應到你試圖符號化的build的確切desims是如此重要。

260
00:30:20,640 --> 00:30:25,640
此外，當用Crash reports的檔案名和行數回到原始檔案時，

261
00:30:25,640 --> 00:30:29,640
確保你在查看的是碼的確切版本，

262
00:30:29,640 --> 00:30:44,640
否則這行數可能會不準確，因為那個檔案可能在此期間有所改變。

263
00:30:44,640 --> 00:30:48,640
Xcode Organizer可以自動處理符號化。

264
00:30:48,640 --> 00:30:54,640
它將搜尋所有的本地檔案並找到每個二進制所需的desim並執行符號化。

265
00:30:54,640 --> 00:31:01,640
回到以前，我們習慣手動進行這個過程，而且由於其核心保持不變，

266
00:31:01,640 --> 00:31:10,640
我認為理解其工作原理是有價值的，因此你如果需要就可以介入。

267
00:31:10,640 --> 00:31:24,640
在你取得Crash report後，你可以使用mdefind命令與這些com Apple Xcode desim UUIDs，

268
00:31:24,640 --> 00:31:33,640
並且你貼上從你的Crash report獲得的desim UUID或ID，

269
00:31:33,640 --> 00:31:45,640
而mdefind在背後使用Spotlight，它將搜索你機器上的所有desims並找到與ID匹配的那個。

270
00:31:45,640 --> 00:31:51,640
所以這就是門後進行匹配的方法。

271
00:31:51,640 --> 00:32:02,640
最後，當我們擁有所有像Crash report和desim這樣的信息，我們就可以自行觸發symbolication。

272
00:32:02,640 --> 00:32:14,640
為此，Xcode app內的dvd Foundation框架下有一個叫做SymbolicateCrash的工具，

273
00:32:14,640 --> 00:32:22,640
我們只需要傳遞減號d和desim和Crash的路徑。

274
00:32:22,640 --> 00:32:29,640
這將重新進行symbolication。

275
00:32:29,640 --> 00:32:37,640
或者你可以使用a2s命令，但這並不會進行全部的symbolication，

276
00:32:37,640 --> 00:32:45,640
因為a2s會將地址轉換為符號，你需要傳入每個明確的地址去轉換成一個符號，

277
00:32:45,640 --> 00:32:54,640
所以它不會將您的完整 Crash 報告進行符號化。如果您想做這件事，您可以使用我剛剛展示的 SymbolicateCrash。

278
00:32:54,640 --> 00:33:03,640
若要在 Crash 報告中識別來自操作系統框架的符號，您需要從設備中收集系統框架的符號。

279
00:33:03,640 --> 00:33:12,640
對於 iOS，iPadOS，watchOS 和 tvOS，Xcode 會自動從您連接到您的 Mac 的每個設備中複製這些符號。

280
00:33:12,640 --> 00:33:22,640
對於 macOS 和 Mac Catalyst 應用程序，使用在 macOS 版本與 Crash 報告中命名的 macOS 版本上的 Xcode 進行 Crash 日誌符號化。

281
00:33:22,640 --> 00:33:25,640
這有點複雜。

282
00:33:25,640 --> 00:33:33,640
但請知道，系統框架的符號專為該裝置的操作系統版本和 CPU 架構設定。

283
00:33:33,640 --> 00:33:45,640
例如，運行 iOS 13.1.0 的 iPhone 的符號並非與運行 iOS 13.1.2 的 iPhone 的符號相同。

284
00:33:45,640 --> 00:33:55,640
所以每個版本都有其專屬的符號，並且你需要確切的符號來進行符號化。

285
00:33:55,640 --> 00:34:02,640
如前所述，如果你在使用 Bitcode，則需要在 AppStoreConnect 網站上重新編譯後下載 D-DSYMs。

286
00:34:02,640 --> 00:34:19,640
你可以透過使用 Xcode 組織工具下載除錯符號來實現這一點，或者你也可以直接去 AppStoreConnect 的網站上下載。

287
00:34:19,640 --> 00:34:25,640
最後，我們來談談一分鐘的故障排除。

288
00:34:25,640 --> 00:34:35,640
因為有時候我們的符號化就是不起作用，所以我們得到的崩潰報告可能只是部分符號化，或者更糟，未經符號化。

289
00:34:35,640 --> 00:34:44,640
為了解決這一問題，請確保你盡最大努力在你的機器上有每一個Image binary對應的D-DSYMs，並由Spotlight進行索引。

290
00:34:44,640 --> 00:34:56,640
一個好的方法是，如果構建被上傳到AppStoreConnect，那麼去Xcode organizer並直接從Apple下載除錯符號，然後試著重新進行符號化。

291
00:34:56,640 --> 00:35:06,640
如果你的構建並未上傳到AppStoreConnect，試著從你的CI下載D-DSYMs，或者如果他們在本地創建了存檔，就從同事那裡獲取它們。

292
00:35:06,640 --> 00:35:15,640
如果您正在使用像Firebase Crashlytics這樣的第三方服務，請按照文檔中的步驟進行，並確保您的設定是正確的。

293
00:35:15,640 --> 00:35:25,640
這樣的第三方服務通常有一個建立步驟，他們會將D-DSYMs上傳到服務器，所以確保該建立步驟能夠正常運行。

294
00:35:25,640 --> 00:35:37,640
就是這樣。謝謝你。