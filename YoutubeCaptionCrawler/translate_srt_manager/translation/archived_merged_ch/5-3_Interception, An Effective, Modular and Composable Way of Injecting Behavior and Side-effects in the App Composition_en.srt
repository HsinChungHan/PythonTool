

1
00:00:00,633 --> 00:00:03,333
你好 Mike，嗨 Caio，在上一個

2
00:00:03,333 --> 00:00:04,700
講座中我們創建了

3
00:00:04,700 --> 00:00:07,433
加載器組合來組織

4
00:00:07,433 --> 00:00:08,133
遠程

5
00:00:08,133 --> 00:00:10,700
與 LocalFeedLoader 或任何類型的

6
00:00:10,700 --> 00:00:12,633
FeedLoader

7
00:00:12,633 --> 00:00:15,500
以便我們可以從主加載器中加載

8
00:00:15,500 --> 00:00:16,300
在這種情況下

9
00:00:16,300 --> 00:00:19,166
遠程的，然後備用是本地的

10
00:00:19,166 --> 00:00:20,633
緩存

11
00:00:20,633 --> 00:00:24,133
但是我們從未向緩存添加過任何東西

12
00:00:24,133 --> 00:00:27,433
確實我們並未儲存 feed

13
00:00:27,433 --> 00:00:30,533
因此，如果無法從遠程加載

14
00:00:30,533 --> 00:00:32,633
它將永遠不會從緩存加載任何東西

15
00:00:32,633 --> 00:00:36,300
它將永遠是空的，這是對的

16
00:00:36,300 --> 00:00:38,466
這是因為我們正在將

17
00:00:38,466 --> 00:00:39,666
查詢

18
00:00:39,666 --> 00:00:43,833
和指令分開，所以加載是一種查詢

19
00:00:43,833 --> 00:00:47,733
確實，而儲存代表

20
00:00:47,733 --> 00:00:51,033
副作用，因為它會改變

21
00:00:51,033 --> 00:00:52,300
狀態

22
00:00:52,300 --> 00:00:55,100
確實，所以我們不希望加載

23
00:00:55,100 --> 00:00:56,300
操作

24
00:00:56,300 --> 00:00:59,600
執行改變或改動系統

25
00:00:59,600 --> 00:01:00,800
狀態

26
00:01:00,800 --> 00:01:03,833
但我們希望將加載與


27
00:01:03,833 --> 00:01:06,466
所以每次我們從遠程加載東西時都會進行儲存

28
00:01:06,466 --> 00:01:07,500
從遠程加載

29
00:01:07,500 --> 00:01:10,533
我們可以將其儲存到本地緩存或者

30
00:01:10,533 --> 00:01:12,933
內存緩存或者任何類型的

31
00:01:12,933 --> 00:01:14,466
我們可以創建的緩存

32
00:01:14,466 --> 00:01:17,600
以滿足我們的使用案例，好的

33
00:01:17,600 --> 00:01:20,933
所以我們在講述攔截

34
00:01:20,933 --> 00:01:25,433
這裡的加載和注入

35
00:01:25,433 --> 00:01:27,833
在組件中保存的副效應

36
00:01:27,833 --> 00:01:29,100
組成

37
00:01:29,100 --> 00:01:32,300
正確的，我們已經實現了

38
00:01:32,300 --> 00:01:35,266
保存的使用案例，所以我們需要做的

39
00:01:35,266 --> 00:01:36,133
就是

40
00:01:36,133 --> 00:01:39,333
將其與加載組合起來

41
00:01:39,333 --> 00:01:42,066
正確的，LocalFeedLoader擁有

42
00:01:42,066 --> 00:01:43,100
實現

43
00:01:43,100 --> 00:01:45,900
緩存邏輯的方法，所以我們需要將

44
00:01:45,900 --> 00:01:46,766
組建

45
00:01:46,766 --> 00:01:49,033
從遠程加載與LocalFeed

46
00:01:49,033 --> 00:01:49,900
Loader

47
00:01:49,900 --> 00:01:53,500
的保存操作組合起來，正確的，但我們不希望

48
00:01:53,500 --> 00:01:55,900
RemoteFeedLoader知道LocalFeedLoader

49
00:01:55,900 --> 00:01:57,666
的存在

50
00:01:57,666 --> 00:01:59,666
為了尊重模組化，它們不應該

51
00:01:59,666 --> 00:02:02,300
知道其他具體的組件

52
00:02:02,300 --> 00:02:04,700
正確的，所以我們可以在

53
00:02:04,700 --> 00:02:05,733
組合的地方做到這一點

54
00:02:05,733 --> 00:02:08,466
例如，我們可以在這個

55
00:02:08,466 --> 00:02:09,733
後備級別

56
00:02:09,733 --> 00:02:13,566
使用具體的 LocalFeedLoader

57
00:02:13,566 --> 00:02:15,333
我們可以在這邊執行邊效果

58
00:02:15,333 --> 00:02:16,866
就在這裡

59
00:02:16,866 --> 00:02:19,666
所以我們可以儲存我們在

60
00:02:19,666 --> 00:02:21,200
成功加載中得到的feed

61
00:02:21,200 --> 00:02:24,300
對吧，但現在我們的組合

62
00:02:24,300 --> 00:02:27,433
不再具有可組合性是的吧

63
00:02:27,433 --> 00:02:29,833
因為它只能組合具體的

64
00:02:29,833 --> 00:02:31,500
LocalFeedLoader

65
00:02:31,500 --> 00:02:34,466
就是這樣，這是一種解決方案，但並不是 

66
00:02:34,466 --> 00:02:36,466
一種非常可組合的解決方案

67
00:02:36,466 --> 00:02:39,566
所以讓我們嘗試其他的，另一個

68
00:02:39,566 --> 00:02:42,066
解決方案將是加入

69
00:02:42,066 --> 00:02:45,266
一個儲存方法至 FeedLoader

70
00:02:45,266 --> 00:02:46,466
協議中

71
00:02:46,466 --> 00:02:50,400
但是，一個 FeedLoader 應該只負責加載

72
00:02:50,400 --> 00:02:53,666
確實，因為不是每個 FeedLoader

73
00:02:53,666 --> 00:02:56,700
都能儲存，例如

74
00:02:56,700 --> 00:02:59,033
RemoteFeedLoader 就無法

75
00:02:59,033 --> 00:03:00,633
進行儲存

76
00:03:00,633 --> 00:03:03,200
在 FeedLoader 協議中增加這個儲存函數

77
00:03:03,200 --> 00:03:04,700
我們違反了 ISP，也就是接口

78
00:03:04,700 --> 00:03:07,566
分離原則

79
00:03:07,566 --> 00:03:08,933
以及可能違反了 LSP，也就是 Liskov

80
00:03:08,933 --> 00:03:11,900
替代原則

81
00:03:11,900 --> 00:03:13,666
替代原則

82
00:03:13,666 --> 00:03:16,400
確實如此，我們可以做的另一件事就是

83
00:03:16,400 --> 00:03:17,566
創建一種新的類型

84
00:03:17,566 --> 00:03:20,933
來攔截並注入對於

85
00:03:20,933 --> 00:03:22,533
變異的副作用

86
00:03:22,533 --> 00:03:26,066
在組合中的話換句話說

87
00:03:26,066 --> 00:03:29,266
我們會攔截 FeedLoaders 並且

88
00:03:29,266 --> 00:03:29,733
添加

89
00:03:29,733 --> 00:03:32,766
新的行為

90
00:03:32,766 --> 00:03:34,533
那麼如何向一種

91
00:03:34,533 --> 00:03:35,900
已經存在的類型

92
00:03:35,900 --> 00:03:39,033
添加行為，並且不改變該類型呢？

93
00:03:39,033 --> 00:03:42,700
使用裝飾器，對吧？所以我們需要

94
00:03:42,700 --> 00:03:45,733
一個裝飾器

95
00:03:45,733 --> 00:03:48,000
所以這堂課的目標就是攔截

96
00:03:48,000 --> 00:03:49,266
遠端加載器的載入

97
00:03:49,266 --> 00:03:51,333
並當我們取得成功的結果時

98
00:03:51,333 --> 00:03:52,533
我們保存它，並添加上

99
00:03:52,533 --> 00:03:55,566
這種行為

100
00:03:55,566 --> 00:03:56,466
使用裝飾器

101
00:03:56,466 --> 00:03:59,566
一如往常，讓我們從測試開始

102
00:03:59,566 --> 00:04:01,100
因此，這種新型態將裝飾

103
00:04:01,100 --> 00:04:03,200
FeedLoader 協議

104
00:04:03,200 --> 00:04:04,300
並添加保存功能

105
00:04:04,300 --> 00:04:07,266
對它來說

106
00:04:07,266 --> 00:04:08,133
讓我們就叫它

107
00:04:08,133 --> 00:04:14,133
FeedLoaderCacheDecorator

108
00:04:14,133 --> 00:04:16,866
所以FeedLoaderCacheDecorator將會

109
00:04:16,866 --> 00:04:17,833
也是

110
00:04:17,833 --> 00:04:20,066
一個FeedLoader，這將實現Feed

111
00:04:20,066 --> 00:04:21,900
Loader協議

112
00:04:21,900 --> 00:04:24,233
像所有其他的裝飾器，它維護

113
00:04:24,233 --> 00:04:25,100
相同的

114
00:04:25,100 --> 00:04:28,300
介面像被裝飾物，我們想要

115
00:04:28,300 --> 00:04:30,300
維護相同的載入行為

116
00:04:30,300 --> 00:04:33,033
但注入會使系統

117
00:04:33,033 --> 00:04:35,033
變異的儲存操作

118
00:04:35,033 --> 00:04:36,466
所以讓我們先從測試開始，確保

119
00:04:36,466 --> 00:04:38,866
裝飾器維護著與被裝飾物

120
00:04:38,866 --> 00:04:42,466
相同的載入行為

121
00:04:42,466 --> 00:04:44,700
所以期望的是系統

122
00:04:44,700 --> 00:04:45,600
在測試下

123
00:04:45,600 --> 00:04:48,700
應該完成成功的飼料

124
00:04:48,700 --> 00:04:52,233
當裝飾的加載器成功時

125
00:04:52,233 --> 00:04:54,866
給定的飼料，所以我們只是

126
00:04:54,866 --> 00:04:55,666
測試著

127
00:04:55,666 --> 00:04:57,833
我們通過裝飾來維護相同的載入行為

128
00:04:57,833 --> 00:04:58,700
裝飾

129
00:04:58,700 --> 00:05:00,933
加載器，我們可以使用相同的

130
00:05:00,933 --> 00:05:02,000
輔助器

131
00:05:02,000 --> 00:05:05,100
從以前的講座，我們只需要

132
00:05:05,100 --> 00:05:06,300
導入

133
00:05:06,300 --> 00:05:09,600
EssentialFeed 就好

134
00:05:09,600 --> 00:05:11,733
現在讓我們創建新的類型，

135
00:05:11,733 --> 00:05:14,700
FeedLoaderCacheDecorator

136
00:05:14,700 --> 00:05:16,866
所以 FeedLoaderCacheDecorator 是一個

137
00:05:16,866 --> 00:05:17,900
FeedLoader

138
00:05:17,900 --> 00:05:20,300
並且你會用另一個

139
00:05:20,300 --> 00:05:22,633
裝載器來實例化它，這就是所裝飾的對象

140
00:05:22,633 --> 00:05:25,666
就是我們所裝飾的裝載器，然後一步步的

141
00:05:25,666 --> 00:05:26,133
一步步的

142
00:05:26,133 --> 00:05:28,133
我們將注入保存

143
00:05:28,133 --> 00:05:29,266
操作

144
00:05:29,266 --> 00:05:32,633
進去，太棒了，讓我們先運行測試

145
00:05:32,633 --> 00:05:33,333
先來

146
00:05:33,333 --> 00:05:35,433
因為我們現象還沒有

147
00:05:35,433 --> 00:05:36,833
實現任何行為所以需要失敗

148
00:05:36,833 --> 00:05:40,866
尚未實現就失敗了，不錯

149
00:05:40,866 --> 00:05:43,500
為了讓它通過，我們需要將

150
00:05:43,500 --> 00:05:44,066
消息

151
00:05:44,066 --> 00:05:46,700
轉發給被裝飾者，這證明我們

152
00:05:46,700 --> 00:05:49,166
保持了相同的加載行為

153
00:05:49,166 --> 00:05:53,166
讓我們再運行一次測試。 都能通過，不錯

154
00:05:53,166 --> 00:05:56,466
所以我們的測試只檢查了成功的情況，那錯誤的呢?

155
00:05:56,466 --> 00:05:59,033
對，如果出錯會怎樣？

156
00:05:59,033 --> 00:06:00,300
情況呢？

157
00:06:00,300 --> 00:06:02,800
確實，我們可以透過增加一個測試案例

158
00:06:02,800 --> 00:06:04,700
來增加覆蓋率，同時也檢查

159
00:06:04,700 --> 00:06:07,666
在失敗的情況下會發生什麼。 所以，如果

160
00:06:07,666 --> 00:06:09,333
被裝飾的裝載器

161
00:06:09,333 --> 00:06:12,066
失敗了，裝飾者也應該轉發

162
00:06:12,066 --> 00:06:12,933
這個錯誤

163
00:06:12,933 --> 00:06:15,166
這證明它保持了相同的加載行為

164
00:06:15,166 --> 00:06:16,866
保持了相同的加載行為


165
00:06:16,866 --> 00:06:18,133
並且應該通過，因為我們是

166
00:06:18,133 --> 00:06:20,066
轉發信息

167
00:06:20,066 --> 00:06:23,433
讓我們進行測試，好的，通過了

168
00:06:23,433 --> 00:06:27,100
讓我們提交，所以FeedLoaderCache

169
00:06:27,100 --> 00:06:28,066
裝飾器

170
00:06:28,066 --> 00:06:31,266
傳遞裝飾器裝載器結果

171
00:06:31,266 --> 00:06:33,500
在兩種情況下都是對的，無論是

172
00:06:33,500 --> 00:06:35,100
成功或失敗

173
00:06:35,100 --> 00:06:39,600
那就是這樣，但現在我們有重複

174
00:06:39,600 --> 00:06:41,733
因為這個裝載器和

175
00:06:41,733 --> 00:06:44,133
之前演講中創建的裝載器完全相同

176
00:06:44,133 --> 00:06:48,233
對於FeedLoader組合，好的，我們可以

177
00:06:48,233 --> 00:06:49,166
提取它

178
00:06:49,166 --> 00:06:52,400
在測試助手中，好的所以由於這是

179
00:06:52,400 --> 00:06:53,166
繼續

180
00:06:53,166 --> 00:06:55,166
共享範疇，讓我們給它一個更好的

181
00:06:55,166 --> 00:06:56,633
名稱，這是一個

182
00:06:56,633 --> 00:06:59,166
FeedLoaderStub，因為它實現了

183
00:06:59,166 --> 00:07:01,266
FeedLoader協定

184
00:07:01,266 --> 00:07:04,933
讓我們將它移至助手文件夾

185
00:07:04,933 --> 00:07:07,166
我們可以在組合中重用它

186
00:07:07,166 --> 00:07:08,133
測試

187
00:07:08,133 --> 00:07:11,500
讓我們只是重命名這以便於

188
00:07:11,500 --> 00:07:15,733
現在我們可以刪除並進行測試

189
00:07:15,733 --> 00:07:18,933
好的，通過了，讓我們提交

190
00:07:18,933 --> 00:07:21,333
將 FeedLoaderStub 提取到共享的

191
00:07:21,333 --> 00:07:22,133
範疇

192
00:07:22,133 --> 00:07:26,233
以移除重複

193
00:07:26,233 --> 00:07:28,066
您也可以移動獨特的 feed

194
00:07:28,066 --> 00:07:30,066
工廠方法

195
00:07:30,066 --> 00:07:32,933
到共享的測試助手，讓我們將它

196
00:07:32,933 --> 00:07:34,866
變為內部的現在

197
00:07:34,866 --> 00:07:38,700
好，讓我們導入 EssentialFeed

198
00:07:38,700 --> 00:07:42,133
模組，我們可以重用它

199
00:07:42,133 --> 00:07:46,700
在兩個測試中，讓我們運行測試

200
00:07:46,700 --> 00:07:50,133
通過的話，提取

201
00:07:50,133 --> 00:07:52,533
獨特的 feed 工廠助手到共享的

202
00:07:52,533 --> 00:07:55,666
範疇以移除重複

203
00:07:55,666 --> 00:07:59,333
最後，我們也可以重用 expect

204
00:07:59,333 --> 00:08:03,566
助手方法好，但 expect 方法

205
00:08:03,566 --> 00:08:07,566
正在使用 XCTest 實例方法

206
00:08:07,566 --> 00:08:10,700
確實，expectation 和 wait

207
00:08:10,700 --> 00:08:14,066
屬於 XCTestCase 實例

208
00:08:14,066 --> 00:08:17,166
所以我們可以將它移到延伸

209
00:08:17,166 --> 00:08:20,533
到XCTestCase類別的延伸

210
00:08:20,533 --> 00:08:26,066
XCTestCase+FeedLoader

211
00:08:26,066 --> 00:08:31,266
好，那麼讓我們將此移到到延伸

212
00:08:31,266 --> 00:08:34,633
到XCTestCase類別的延伸

213
00:08:34,633 --> 00:08:37,266
但它不應該是私有的是的，我們

214
00:08:37,266 --> 00:08:40,366
也需要 EssentialFeed

215
00:08:40,366 --> 00:08:43,033
好的，我們現在可以在

216
00:08:43,033 --> 00:08:45,200
composite和decorator中都重用這個輔助

217
00:08:45,200 --> 00:08:46,866
測試

218
00:08:46,866 --> 00:08:50,366
我們運行測試

219
00:08:50,366 --> 00:08:53,733
通過，太好了但現在

220
00:08:53,733 --> 00:08:56,866
每個XCTestCase實例都有

221
00:08:56,866 --> 00:08:59,600
訪問這個方法的權限，即使那些

222
00:08:59,600 --> 00:09:00,700
對此無所謂的

223
00:09:00,700 --> 00:09:03,200
FeedLoader協議，所以我們在

224
00:09:03,200 --> 00:09:05,433
暴露那些對所有XCTestCase來說並不

225
00:09:05,433 --> 00:09:08,300
必要的方法，

226
00:09:08,300 --> 00:09:09,833
這並不理想。

227
00:09:09,833 --> 00:09:13,333
對吧，我們想讓多個XCTestCase

228
00:09:13,333 --> 00:09:16,233
能訪問這個方法，但只有

229
00:09:16,233 --> 00:09:18,000
關注

230
00:09:18,000 --> 00:09:21,433
FeedLoader協議的那些才能這樣做。所以一種方式是

231
00:09:21,433 --> 00:09:22,533
創建一個XCTestCase的子類

232
00:09:22,533 --> 00:09:25,600
就像FeedLoaderTestCase

233
00:09:25,600 --> 00:09:31,100
然後我們只為

234
00:09:31,100 --> 00:09:34,000
這個子類添加擴展

235
00:09:34,000 --> 00:09:34,533
就是這樣

236
00:09:34,533 --> 00:09:37,833
類型的類，我們需要讓我們的測試

237
00:09:37,833 --> 00:09:42,233
是FeedLoaderTestCase的子類型

238
00:09:42,233 --> 00:09:45,100
這是可以的，但問題是在

239
00:09:45,100 --> 00:09:47,266
未來我們可能想要進行組合

240
00:09:47,266 --> 00:09:49,266
這個類別與其他操作

241
00:09:49,266 --> 00:09:50,700
可以被重複使用

242
00:09:50,700 --> 00:09:53,433
但你只能繼承自一個類別

243
00:09:53,433 --> 00:09:53,733
所以

244
00:09:53,733 --> 00:09:56,700
類別繼承並非可組合的，你

245
00:09:56,700 --> 00:09:58,933
只能繼承自一個類別

246
00:09:58,933 --> 00:10:01,833
是的，但這裡有一個解決方案

247
00:10:01,833 --> 00:10:02,700
那就是

248
00:10:02,700 --> 00:10:05,900
使用協定和協定擴展

249
00:10:05,900 --> 00:10:09,900
準確無誤，一個類別可以符合

250
00:10:09,900 --> 00:10:12,700
多個協定並繼承

251
00:10:12,700 --> 00:10:15,433
他們擴展的實作

252
00:10:15,433 --> 00:10:17,733
且你可以使協定只限於

253
00:10:17,733 --> 00:10:20,000
特定類別

254
00:10:20,000 --> 00:10:22,633
所以此協定是可組合的，但只能

255
00:10:22,633 --> 00:10:24,233
被XCTestCase子類型所繼承

257
00:10:27,900 --> 00:10:30,133
這是一個很棒的Swift特性可以讓我們如此操作

259
00:10:32,466 --> 00:10:35,600
就結束了，所以我們的測試案例需要再次

260
00:10:35,600 --> 00:10:38,466
從XCTestCase繼承

261
00:10:38,466 --> 00:10:41,600
但他們也得到協定

262
00:10:41,600 --> 00:10:42,466
初始擴展

263
00:10:42,466 --> 00:10:44,233
因為他們符合FeedLoader

264
00:10:44,233 --> 00:10:46,300
TestCase協定

265
00:10:46,300 --> 00:10:48,533
所以那是為什麼Swift的協定可以組合得更好

266
00:10:48,533 --> 00:10:50,300
比類別更好

267
00:10:50,300 --> 00:10:51,500
你可以通過多種方式驗證

268
00:10:51,500 --> 00:10:54,066
採用protocols並繼承他們所有的

269
00:10:54,066 --> 00:10:59,100
擴充性，太棒了 讓我們跑一下這些測試

270
00:10:59,100 --> 00:11:01,266
測試都通過了，所以我們排除了所有

271
00:11:01,266 --> 00:11:02,466
的重複

272
00:11:02,466 --> 00:11:04,700
是的 很重要 誠實地說，你不會

273
00:11:04,700 --> 00:11:06,866
想要跳過重造(decoding)階段

274
00:11:06,866 --> 00:11:09,900
你需要從兩方面移除重複的部分

275
00:11:09,900 --> 00:11:10,866
即是出品端

276
00:11:10,866 --> 00:11:16,533
和測試端，那確實如此 讓我們提交吧

277
00:11:16,533 --> 00:11:19,600
提取FeedLoader測試助手到一個

278
00:11:19,600 --> 00:11:21,033
共享的protocol擴充功能裡

279
00:11:21,033 --> 00:11:24,366
以移除重複

280
00:11:24,366 --> 00:11:26,366
而且像平常一樣在我們繼續前讓我們

281
00:11:26,366 --> 00:11:28,233
創建makeSUT

282
00:11:28,233 --> 00:11:30,366
工廠方法以消除更多

283
00:11:30,366 --> 00:11:33,500
的重複

284
00:11:33,500 --> 00:11:37,833
讓我們跑一下這些測試又通過了

285
00:11:37,833 --> 00:11:40,000
所以別忘了繼續重造

286
00:11:40,000 --> 00:11:42,066
產品和測試的代碼

287
00:11:42,066 --> 00:11:47,033
我們希望兩邊都保持乾淨 讓我們提交

288
00:11:47,033 --> 00:11:49,900
提取這個SUT創建進工廠

289
00:11:49,900 --> 00:11:50,800
方法裡

290
00:11:50,800 --> 00:11:54,933
就這麼簡單 好的 到目前為止我們的測試

291
00:11:54,933 --> 00:11:57,833
只證明了緩存裝飾器就是

292
00:11:57,833 --> 00:11:59,033
一個FeedLoader

293
00:11:59,033 --> 00:12:01,666
並且保持載入裝飾者的邏輯

294
00:12:01,666 --> 00:12:03,600
裝飾者

295
00:12:03,600 --> 00:12:06,233
現在該測試實際的

296
00:12:06,233 --> 00:12:07,666
突變副作用

297
00:12:07,666 --> 00:12:11,033
正在保存操作好了

298
00:12:11,033 --> 00:12:14,533
所以，載入緩存的載入飼料

299
00:12:14,533 --> 00:12:17,833
在加載成功並緩存

300
00:12:17,833 --> 00:12:19,200
已加載的結果

301
00:12:19,200 --> 00:12:21,733
我們將需要新的元件

302
00:12:21,733 --> 00:12:22,700
負責

303
00:12:22,700 --> 00:12:26,633
對於緩存，我們可以稱之為

304
00:12:26,633 --> 00:12:30,466
緩存並我們想確認

305
00:12:30,466 --> 00:12:33,900
加載成功後，緩存系統

306
00:12:33,900 --> 00:12:37,333
收到保存訊息

307
00:12:37,333 --> 00:12:40,366
這極其重要因為

308
00:12:40,366 --> 00:12:43,833
裝飾者並沒有緩存裝飾者

309
00:12:43,833 --> 00:12:48,300
協調加載和緩存

310
00:12:48,300 --> 00:12:51,200
的確，它攔截加載，然後在

311
00:12:51,200 --> 00:12:53,266
成功後它需要發送訊息

312
00:12:53,266 --> 00:12:56,233
給緩存以保存已加載的飼料

313
00:12:56,233 --> 00:12:57,433
就是這樣

314
00:12:57,433 --> 00:12:59,266
但在測試中，我們不會使用

315
00:12:59,266 --> 00:13:01,100
真實的緩存系統，我們使用的是

316
00:13:01,100 --> 00:13:03,266
這裡的間諜，將捕獲所有

317
00:13:03,266 --> 00:13:04,800
收到的訊息

318
00:13:04,800 --> 00:13:06,533
並且在這個測試的結尾我們想要

319
00:13:06,533 --> 00:13:09,100
確認我們收到了儲存的

320
00:13:09,100 --> 00:13:12,133
來自給定feed的信息，並且何時

321
00:13:12,133 --> 00:13:14,066
應該這樣做？

322
00:13:14,066 --> 00:13:17,900
在加載成功結果後

323
00:13:17,900 --> 00:13:20,933
就是這樣，所以我們將 loader 的結果

324
00:13:20,933 --> 00:13:24,066
設定為成功的 feed

325
00:13:24,066 --> 00:13:26,466
同樣的 feed 我們期望被保存在

326
00:13:26,466 --> 00:13:28,633
緩存中

327
00:13:28,633 --> 00:13:31,433
所以我們需要創建一個 CacheSpy 來使用

328
00:13:31,433 --> 00:13:35,733
在測試中

329
00:13:35,733 --> 00:13:38,533
並且我們需要傳遞一個緩存到 make

330
00:13:38,533 --> 00:13:39,433
sut

331
00:13:39,433 --> 00:13:40,700
並且因為我們不想破壞

332
00:13:40,700 --> 00:13:44,466
其他測試，讓我們給出一個默認值

333
00:13:44,466 --> 00:13:46,833
現在我們可以將緩存傳遞到

334
00:13:46,833 --> 00:13:49,900
裝飾器

335
00:13:49,900 --> 00:13:51,733
現在我們需要思考我們這裡需要什麼樣的

336
00:13:51,733 --> 00:13:53,600
緩存

337
00:13:53,600 --> 00:13:56,866
我們需要實現緩存用例的 LocalFeedLoader 嗎？

338
00:13:56,866 --> 00:14:00,066
對我們可以，但我們不想要那樣

340
00:14:03,266 --> 00:14:05,733
那是因為 local FeedLoader

341
00:14:05,733 --> 00:14:07,333
是具體的類型

342
00:14:07,333 --> 00:14:09,833
並且它有依賴性，所以我們將需要

343
00:14:09,833 --> 00:14:10,466
創建

344
00:14:10,466 --> 00:14:13,600
在我們的測試中的所有這些依賴性

345
00:14:13,600 --> 00:14:16,700
如果其中一個依賴性改變了

346
00:14:16,700 --> 00:14:20,466
它將破壞我們的測試，所以我們可以測試

347
00:14:20,466 --> 00:14:21,333
這個裝飾器

348
00:14:21,333 --> 00:14:23,500
與LocalFeedLoader的整合

349
00:14:23,500 --> 00:14:25,100
具體的類別

350
00:14:25,100 --> 00:14:27,500
但是我們的測試會更脆弱並且

351
00:14:27,500 --> 00:14:28,800
這個裝飾器將會

352
00:14:28,800 --> 00:14:31,666
更少的組合性我們想要測試

353
00:14:31,666 --> 00:14:32,633
裝飾器

354
00:14:32,633 --> 00:14:34,800
在隔離中，我們需要有

355
00:14:34,800 --> 00:14:35,833
一個抽象化

356
00:14:35,833 --> 00:14:39,100
這也允許更多組合性

357
00:14:39,100 --> 00:14:41,833
正如我們有Feed

358
00:14:41,833 --> 00:14:43,033
Loader的抽象化一樣

359
00:14:43,033 --> 00:14:46,366
對於加載，我們可以有一個新的

360
00:14:46,366 --> 00:14:47,500
抽象化

361
00:14:47,500 --> 00:14:51,733
用於保存我們可以稱之為FeedSaver

362
00:14:51,733 --> 00:14:58,000
或FeedCache對，我喜歡FeedCache

363
00:14:58,000 --> 00:15:00,133
好的，那麼Feed

364
00:15:00,133 --> 00:15:01,100
Cache

365
00:15:01,100 --> 00:15:03,666
應該有什麼方法，所以FeedCache是一個

366
00:15:03,666 --> 00:15:06,133
用於快取用例的抽象化

367
00:15:06,133 --> 00:15:08,933
我們已經有一個實現了

368
00:15:08,933 --> 00:15:10,133
保存方法

369
00:15:10,133 --> 00:15:15,500
所以這就是我們想要的介面

370
00:15:15,500 --> 00:15:18,700
我們想要一個傳遞

371
00:15:18,700 --> 00:15:19,100
feed

372
00:15:19,100 --> 00:15:21,900
這個是FeedImages的數組，以及一個

373
00:15:21,900 --> 00:15:22,533
完成

374
00:15:22,533 --> 00:15:25,166
帶有結果類型的閉包，即是

375
00:15:25,166 --> 00:15:26,000
要麼是

376
00:15:26,000 --> 00:15:30,233
成功的VOID或者是一個錯誤

377
00:15:30,233 --> 00:15:34,300
好的，那麼spy需要遵守

378
00:15:34,300 --> 00:15:35,266
FeedCache

379
00:15:35,266 --> 00:15:38,933
否則它將無法編譯，明白了嗎

380
00:15:38,933 --> 00:15:40,933
spy的實現就是

381
00:15:40,933 --> 00:15:42,000
簡單地

382
00:15:42,000 --> 00:15:45,266
捕獲信息，就這樣，讓我們來運行

383
00:15:45,266 --> 00:15:46,366
測試

384
00:15:46,366 --> 00:15:48,000
它應該會失敗，因為我們還沒有

385
00:15:48,000 --> 00:15:52,000
執行保存操作

386
00:15:52,000 --> 00:15:54,933
很好，失敗了，緩存沒有

387
00:15:54,933 --> 00:15:55,500
接收

388
00:15:55,500 --> 00:16:00,533
到保存信息，所以我們現在要實現它

389
00:16:00,533 --> 00:16:03,600
所以現在，當我們加載結果

390
00:16:03,600 --> 00:16:06,800
從decoratee loader

391
00:16:06,800 --> 00:16:10,466
我們需要緩存一個成功的結果

392
00:16:10,466 --> 00:16:12,633
否則我們只傳遞一個空數組

393
00:16:12,633 --> 00:16:13,900
就這樣，現在。


394
00:16:13,900 --> 00:16:16,533
好的，僅僅是為了滿足編譯器和

395
00:16:16,533 --> 00:16:17,033
當然

396
00:16:17,033 --> 00:16:20,466
轉發完成

397
00:16:20,466 --> 00:16:24,866
讓我們在屬性中獲取cache

398
00:16:24,866 --> 00:16:27,900
然後讓我們運行測試

399
00:16:27,900 --> 00:16:31,900
好的，通過了，太棒了

400
00:16:31,900 --> 00:16:36,133
讓我們提交，所以FeedLoaderCache

401
00:16:36,133 --> 00:16:37,100
裝飾器

402
00:16:37,100 --> 00:16:41,333
在loader成功時緩存加載的feed

403
00:16:41,333 --> 00:16:44,633
就是這樣，我們還需要

404
00:16:44,633 --> 00:16:47,733
在loader失敗時有個情況

405
00:16:47,733 --> 00:16:51,100
確實是這樣，所以載入

406
00:16:51,100 --> 00:16:54,233
在loader失敗時不會緩存，我們

407
00:16:54,233 --> 00:16:56,800
只應在成功時更改系統狀態

408
00:16:56,800 --> 00:17:00,066
所以我們再次創建一個cache

409
00:17:00,066 --> 00:17:03,733
我們模擬一次loader失敗，我們執行

410
00:17:03,733 --> 00:17:04,000
載入

411
00:17:04,000 --> 00:17:07,666
操作並且我們預期沒有訊息

412
00:17:07,666 --> 00:17:13,333
在失敗情況下，讓我們運行測試

413
00:17:13,333 --> 00:17:17,166
好的，失敗了，因為我們是

414
00:17:17,166 --> 00:17:20,300
不論如何保存，在失敗中

415
00:17:20,300 --> 00:17:20,866
情況下

416
00:17:20,866 --> 00:17:23,166
我們只是保存了一個空的feed，這不是

417
00:17:23,166 --> 00:17:25,733
我們想要的

418
00:17:25,733 --> 00:17:28,633
讓我們使用if let代替，如果我們可以

419
00:17:28,633 --> 00:17:29,666
獲取feed

420
00:17:29,666 --> 00:17:33,033
將結果取出，然後我們將其緩存

421
00:17:33,033 --> 00:17:36,066
只在成功的情況下執行，讓我們運行

422
00:17:36,066 --> 00:17:38,000
測試

423
00:17:38,000 --> 00:17:42,400
通過，讓我們提交

424
00:17:42,400 --> 00:17:45,200
FeedLoaderCacheDecorator 不會

425
00:17:45,200 --> 00:17:46,700
在加載器上緩存 Feed

426
00:17:46,700 --> 00:17:51,566
失敗，我們可以在這裡做任何重構嗎？

427
00:17:51,566 --> 00:17:55,100
是的，我們可以消除 if 語句

428
00:17:55,100 --> 00:17:58,533
並代之以 map，好的

429
00:17:58,533 --> 00:18:01,100
如果你真的不喜歡 if 語句

430
00:18:01,100 --> 00:18:02,766
你可以使用 map

431
00:18:02,766 --> 00:18:06,400
所以我們映射結果，只有

432
00:18:06,400 --> 00:18:07,266
在成功的情況下調用

433
00:18:07,266 --> 00:18:10,933
在成功結果的情況下

434
00:18:10,933 --> 00:18:14,466
我們可以添加副效應在此處進行保存

435
00:18:14,466 --> 00:18:18,933
保存 feed

436
00:18:18,933 --> 00:18:21,666
並我們返回 feed 以保持

437
00:18:21,666 --> 00:18:22,533
相同的

438
00:18:22,533 --> 00:18:25,600
結果類型，就是這樣

439
00:18:25,600 --> 00:18:28,766
好的，測試通過

440
00:18:28,766 --> 00:18:30,633
如果你想從你的代碼中消除 if 語句

441
00:18:30,633 --> 00:18:33,666
這是一種方法

442
00:18:33,666 --> 00:18:38,000
讓我們提交，用 map 替換 if try 語句

443
00:18:38,000 --> 00:18:41,333
用 map替換，但如果你更喜歡 if try

444
00:18:41,333 --> 00:18:42,233
語句

445
00:18:42,233 --> 00:18:44,533
那也没问题，重要的是

446
00:18:44,533 --> 00:18:46,233
行為要正確

447
00:18:46,233 --> 00:18:49,666
測試也要全都通過

448
00:18:49,666 --> 00:18:53,100
完成了，這就是所有 decorator

449
00:18:53,100 --> 00:18:54,133
需要做的事情

450
00:18:54,133 --> 00:18:57,433
只是注入儲存操作

451
00:18:57,433 --> 00:19:00,866
到裝飾過的 loader

452
00:19:00,866 --> 00:19:02,700
所以loader 不需要知道

453
00:19:02,700 --> 00:19:04,466
關於儲存或緩存

454
00:19:04,466 --> 00:19:05,900
緩存是不需要知道關於

455
00:19:05,900 --> 00:19:08,066
加載 我們的組合型態

456
00:19:08,066 --> 00:19:10,533
仍然可以組成，它們不依賴

457
00:19:10,533 --> 00:19:12,133
具體的型態

458
00:19:12,133 --> 00:19:14,933
而且裝飾器也可以組合

459
00:19:14,933 --> 00:19:18,300
因為我們依賴的是抽象的

460
00:19:18,300 --> 00:19:21,033
看看這些簡單的測試，這就是

461
00:19:21,033 --> 00:19:22,400
我們所需要的

462
00:19:22,400 --> 00:19:24,866
就這樣，現在讓我們移動這個型態的

463
00:19:24,866 --> 00:19:26,866
現在進行生產 

464
00:19:26,866 --> 00:19:29,433
好的，我們應該將 FeedCache

465
00:19:29,433 --> 00:19:31,200
這個抽象的

466
00:19:31,200 --> 00:19:33,333
所以我認為 FeedCache 應該與

467
00:19:33,333 --> 00:19:34,533
FeedLoader 在一起

468
00:19:34,533 --> 00:19:38,000
它不依賴任何其他模塊


469
00:19:38,000 --> 00:19:40,400
那麼，FeedLoader就在

470
00:19:40,400 --> 00:19:42,700
Feed Feature中

471
00:19:42,700 --> 00:19:45,333
這看起來像是增加

472
00:19:45,333 --> 00:19:49,033
FeedCache的好地方

473
00:19:49,033 --> 00:19:50,766
所以它是一個公開的協議，因為它是

474
00:19:50,766 --> 00:19:53,733
由其他模組實現的

475
00:19:53,733 --> 00:19:57,733
好，讓我們運行測試

476
00:19:57,733 --> 00:20:01,500
仍然通過，讓我們提交

477
00:20:01,500 --> 00:20:03,600
將FeedCache移至Feed Feature

478
00:20:03,600 --> 00:20:05,266
生產組

479
00:20:05,266 --> 00:20:10,133
好的，我們還可以讓Local

480
00:20:10,133 --> 00:20:13,833
FeedLoader實現FeedCache

481
00:20:13,833 --> 00:20:16,066
抽象，因為它已經實現了

482
00:20:16,066 --> 00:20:16,933
FeedCache

483
00:20:16,933 --> 00:20:20,233
抽象，已经使用了缓存用例

484
00:20:20,233 --> 00:20:25,666
是的，完全正確，再次運行測試

485
00:20:25,666 --> 00:20:29,266
通過了，讓我們提交

486
00:20:29,266 --> 00:20:31,900
讓LocalFeedLoader實現

487
00:20:31,900 --> 00:20:33,666
FeedCache協議

488
00:20:33,666 --> 00:20:35,333
所以我們可以與

489
00:20:35,333 --> 00:20:39,033
裝飾器進行合成，太棒了

490
00:20:39,033 --> 00:20:42,233
好的，也應該將

491
00:20:42,233 --> 00:20:44,933
緩存裝飾器移到生產中的

492
00:20:44,933 --> 00:20:46,400
EssentialApp模組

493
00:20:46,400 --> 00:20:53,900
暫時如此

494
00:20:53,900 --> 00:20:56,533
所以，初始化將會是

495
00:20:56,533 --> 00:20:57,600
公開的

496
00:20:57,600 --> 00:21:00,400
是公開的，而 load 功能也是

497
00:21:00,400 --> 00:21:01,666
公開的

498
00:21:01,666 --> 00:21:05,333
但是依賴性是私有的

499
00:21:05,333 --> 00:21:08,866
好的，所以我們把它移到了

500
00:21:08,866 --> 00:21:09,900
EssentialApp

501
00:21:09,900 --> 00:21:12,633
模塊，我們需要導入 Essential

502
00:21:12,633 --> 00:21:13,266
App

503
00:21:13,266 --> 00:21:17,333
模塊，讓我們再次執行測試

504
00:21:17,333 --> 00:21:20,533
通過，那我們提交

505
00:21:20,533 --> 00:21:23,033
把 FeedLoaderCacheDecorator 移到

506
00:21:23,033 --> 00:21:24,766
生產環境

507
00:21:24,766 --> 00:21:27,333
這裡有任何重構的可能性嗎，看起來相當

508
00:21:27,333 --> 00:21:29,433
乾淨

509
00:21:29,433 --> 00:21:32,300
我們再看看生產側

510
00:21:32,300 --> 00:21:33,733
看起來不錯

511
00:21:33,733 --> 00:21:36,866
除了這個閉包外

512
00:21:36,866 --> 00:21:38,466
我們不關心保存的結果

513
00:21:38,466 --> 00:21:40,700
就是這個裝飾器能做的沒有

514
00:21:40,700 --> 00:21:41,433
其他東西了

515
00:21:41,433 --> 00:21:44,533
當保存失敗時候的反應狀態，對吧？

516
00:21:44,533 --> 00:21:46,533
我們是忽視錯誤，但對一個

517
00:21:46,533 --> 00:21:47,833
讀程式碼的人來說

518
00:21:47,833 --> 00:21:50,133
並不是很明顯為什麼。那我們為何不

519
00:21:50,133 --> 00:21:52,300
改為使用擴展呢？

520
00:21:52,300 --> 00:21:54,300
以便說明這就是我們在做的

521
00:21:54,300 --> 00:21:55,600
我們正在忽視

522
00:21:55,600 --> 00:21:58,766
結果，所以保存

523
00:21:58,766 --> 00:22:03,100
忽視結果

524
00:22:03,100 --> 00:22:06,466
所以這被稱為文件記錄，對嗎

525
00:22:06,466 --> 00:22:09,033
我們不需要這種方法，但它

526
00:22:09,033 --> 00:22:10,066
闡明了

527
00:22:10,066 --> 00:22:13,266
我們的意圖，我們想要忽略結果

528
00:22:13,266 --> 00:22:15,666
我們不在乎結果，我很喜歡

529
00:22:15,666 --> 00:22:16,533
這點

530
00:22:16,533 --> 00:22:19,900
因為它使代碼變得更

531
00:22:19,900 --> 00:22:20,866
容易閱讀

532
00:22:20,866 --> 00:22:23,900
特別是當你回來

533
00:22:23,900 --> 00:22:27,033
以後，否則你可能會覺得

534
00:22:27,033 --> 00:22:28,000
這是一個錯誤

535
00:22:28,000 --> 00:22:31,500
沒有處理結果，的確

536
00:22:31,500 --> 00:22:33,900
你正在為你的

537
00:22:33,900 --> 00:22:35,333
未來的自己送禮

538
00:22:35,333 --> 00:22:38,233
或者對別人，如果你在團隊中工作

539
00:22:38,233 --> 00:22:38,866
就是這樣

540
00:22:38,866 --> 00:22:42,700
讓我們運行測試，通過

541
00:22:42,700 --> 00:22:46,633
好的，讓我們提交，所以創建

542
00:22:46,633 --> 00:22:49,900
saveIgnoringResult 方法以闡明

543
00:22:49,900 --> 00:22:53,833
意圖，好的，這就是

544
00:22:53,833 --> 00:22:56,400
FeedLoaderCacheDecorator 的所有內容

545
00:22:56,400 --> 00:22:58,866
你應該對

546
00:22:58,866 --> 00:23:01,200
FeedImageDataLoader 做同樣的事

547
00:23:01,200 --> 00:23:04,000
的確，所以你可以把你的

548
00:23:04,000 --> 00:23:04,633
模組連接起來

549
00:23:04,633 --> 00:23:06,466
並將這副作用添加到

550
00:23:06,466 --> 00:23:08,633
具體類型中或者你可以

551
00:23:08,633 --> 00:23:10,766
遵循指令查詢分離並

552
00:23:10,766 --> 00:23:13,200
將加載與保存分離

553
00:23:13,200 --> 00:23:16,000
然後組成這些函數，這是一種

554
00:23:16,000 --> 00:23:16,700
選擇

555
00:23:16,700 --> 00:23:19,333
作為工程師的你應該

556
00:23:19,333 --> 00:23:20,533
做出這個決定

557
00:23:20,533 --> 00:23:23,200
何時使用一種或何時使用另一種

558
00:23:23,200 --> 00:23:24,633
如果你需要模塊化

559
00:23:24,633 --> 00:23:26,866
你可以裝飾並組成你的

560
00:23:26,866 --> 00:23:28,633
組件

561
00:23:28,633 --> 00:23:31,600
當你不需要模塊化的簡單用例

562
00:23:31,600 --> 00:23:33,733
可能你可以走向更具體的

563
00:23:33,733 --> 00:23:37,900
單體方法，好的

564
00:23:37,900 --> 00:23:40,766
那麼讓我們組成我們的類型並看看

565
00:23:40,766 --> 00:23:42,233
它看起來如何

566
00:23:42,233 --> 00:23:44,466
所以每次我們從遠端加載時我們

567
00:23:44,466 --> 00:23:45,500
想保存

568
00:23:45,500 --> 00:23:48,000
收到的飼料到LocalFeed

569
00:23:48,000 --> 00:23:49,333
Loader

570
00:23:49,333 --> 00:23:53,433
就是這樣，所以我們需要裝飾

571
00:23:53,433 --> 00:23:57,833
用Local作為緩存的RemoteFeedLoader

572
00:23:57,833 --> 00:24:01,900
FeedLoader，就是這麼確定的

573
00:24:01,900 --> 00:24:04,466
好，就這樣，讓我們運行應用程式看看

574
00:24:04,466 --> 00:24:10,766
看是否可以運行

575
00:24:10,766 --> 00:24:14,533
好的，它正在加載，我們得到了這個資料流

576
00:24:14,533 --> 00:24:16,866
來自遠程

577
00:24:16,866 --> 00:24:19,100
並且我們預期它已經存入了

578
00:24:19,100 --> 00:24:21,433
本地加載器

579
00:24:21,433 --> 00:24:24,133
所以讓我們也組織一下遠程圖像

580
00:24:24,133 --> 00:24:24,933
加載器

581
00:24:24,933 --> 00:24:27,833
但這次是影帶FeedImageData

582
00:24:27,833 --> 00:24:29,900
LoaderCacheDecorator

583
00:24:29,900 --> 00:24:32,233
所以我們正在裝飾遠程圖像

584
00:24:32,233 --> 00:24:33,833
加載器，與

585
00:24:33,833 --> 00:24:37,733
本地圖像加載器作為緩存

586
00:24:37,733 --> 00:24:41,733
讓我們運行應用程序

587
00:24:41,733 --> 00:24:44,700
仍然在運行所以我們正在保存

588
00:24:44,700 --> 00:24:45,433
的結果是

589
00:24:45,433 --> 00:24:47,666
將RemoteFeedLoader的結果保存到Local

590
00:24:47,666 --> 00:24:49,333
FeedLoader

591
00:24:49,333 --> 00:24:51,100
以及將遠程圖像

592
00:24:51,100 --> 00:24:53,666
加載器的結果保存到本地圖像加載器

593
00:24:53,666 --> 00:24:55,333
證明這一點，因為我們已經

594
00:24:55,333 --> 00:24:58,466
將這個遠程請求的結果進行了緩存

595
00:24:58,466 --> 00:25:01,333
我們可以停止運行該應用，我們可以

596
00:25:01,333 --> 00:25:03,033
再次運行應用程式

597
00:25:03,033 --> 00:25:07,600
只用本地加載器進行組合

598
00:25:07,600 --> 00:25:10,400
所以如果運行成功並進行了緩存，則可以


599
00:25:10,400 --> 00:25:11,900
使用本地加載器的應用

600
00:25:11,900 --> 00:25:12,766
應該展示

601
00:25:12,766 --> 00:25:17,200
那裡的緩存數據，看，就是了

602
00:25:17,200 --> 00:25:20,133
太棒了，所以當你想要

603
00:25:20,133 --> 00:25:20,700
添加

604
00:25:20,700 --> 00:25:22,933
一個新的行為到一種類型，而不

605
00:25:22,933 --> 00:25:23,900
改變它

606
00:25:23,900 --> 00:25:26,400
你使用裝飾器，當你想要

607
00:25:26,400 --> 00:25:27,200
組合

608
00:25:27,200 --> 00:25:29,666
符合共同界面的類型

609
00:25:29,666 --> 00:25:30,466
你使用

610
00:25:30,466 --> 00:25:33,033
Composite，所以讓我們看一下

611
00:25:33,033 --> 00:25:33,833
圖表

612
00:25:33,833 --> 00:25:36,533
與裝飾器我們介紹的

613
00:25:36,533 --> 00:25:37,433
FeedCache

614
00:25:37,433 --> 00:25:39,266
抽象化，LocalFeedLoader

615
00:25:39,266 --> 00:25:41,333
實現，就像LocalFeed

616
00:25:41,333 --> 00:25:43,733
Loader也實現了FeedLoader

617
00:25:43,733 --> 00:25:45,266
我們可以將此分為兩個

618
00:25:45,266 --> 00:25:46,933
未來的組件，一個

619
00:25:46,933 --> 00:25:48,300
實現FeedCache和一個

620
00:25:48,300 --> 00:25:50,133
實現FeedLoader

621
00:25:50,133 --> 00:25:52,633
裝飾器裝飾任何

622
00:25:52,633 --> 00:25:54,300
FeedLoader的實現

623
00:25:54,300 --> 00:25:58,300
任何FeedCache的實現

624
00:25:58,300 --> 00:26:01,333
在圖像加載端，我們添加了

625
00:26:01,333 --> 00:26:03,666
FeedImageDataCache協議

626
00:26:03,666 --> 00:26:05,733
由LocalFeedImageDataLoader實現

627
00:26:05,733 --> 00:26:07,833
實作就像它實作

628
00:26:07,833 --> 00:26:10,300
FeedImageDataLoader，我們可以

629
00:26:10,300 --> 00:26:11,900
將此分為兩個組件在

630
00:26:11,900 --> 00:26:13,200
將來

631
00:26:13,200 --> 00:26:15,033
和 FeedImageDataLoaderCache

632
00:26:15,033 --> 00:26:16,700
裝飾器裝飾

633
00:26:16,700 --> 00:26:19,833
任何 FeedImageDataLoader 以添加

634
00:26:19,833 --> 00:26:21,333
儲存功能

635
00:26:21,333 --> 00:26:24,533
的任何 FeedImageDataCache

636
00:26:24,533 --> 00:26:27,200
所以這段程式碼非常可組合且

637
00:26:27,200 --> 00:26:28,933
當你需要這種可組性時

638
00:26:28,933 --> 00:26:32,066
這就是你該如何做，就是這樣，而

639
00:26:32,066 --> 00:26:33,433
壞處是

640
00:26:33,433 --> 00:26:36,133
你的組成可能開始變得更

641
00:26:36,133 --> 00:26:37,433
複雜

642
00:26:37,433 --> 00:26:40,000
這就是為什麼你也應該測試

643
00:26:40,000 --> 00:26:41,433
整個組成

644
00:26:41,433 --> 00:26:43,600
以證明類型正確地組成

645
00:26:43,600 --> 00:26:45,100
正確的

646
00:26:45,100 --> 00:26:47,733
確實，這將是

647
00:26:47,733 --> 00:26:49,200
下次講座的主題

648
00:26:49,200 --> 00:26:52,300
我們下次見，再見各位

649
00:26:52,300 --> 00:27:06,133
再見
