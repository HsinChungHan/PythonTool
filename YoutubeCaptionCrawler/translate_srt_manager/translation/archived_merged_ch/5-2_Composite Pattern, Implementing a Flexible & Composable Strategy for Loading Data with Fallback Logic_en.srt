

1
00:00:00,633 --> 00:00:03,266
嗨，Mike，嘿，Caio

2
00:00:03,266 --> 00:00:05,733
在這次課程中，你將學會如何

3
00:00:05,733 --> 00:00:06,466
整合

4
00:00:06,466 --> 00:00:09,733
擁有共通介面的物件

5
00:00:09,733 --> 00:00:12,933
用Composite design pattern

6
00:00:12,933 --> 00:00:15,566
好的，目標是將

7
00:00:15,566 --> 00:00:16,233
遠端

8
00:00:16,233 --> 00:00:19,500
與LocalFeedLoader以及邏輯

9
00:00:19,500 --> 00:00:22,533
盡可能首先從遠端讀取

10
00:00:22,533 --> 00:00:25,266
如果失敗了，則嘗試從本地讀取

11
00:00:25,266 --> 00:00:26,533
就是這樣

12
00:00:26,533 --> 00:00:29,566
他們都共享一個共通的介面

13
00:00:29,566 --> 00:00:32,366
FeedLoader協議就是他們共同

14
00:00:32,366 --> 00:00:33,833
實現的

15
00:00:33,833 --> 00:00:36,066
而且我們想創建一個新的組件

16
00:00:36,066 --> 00:00:38,466
也有相同的介面

17
00:00:38,466 --> 00:00:41,733
就是帶著我們想要的邏輯，但使用者們

18
00:00:41,733 --> 00:00:44,000
不需要知道這的composite結構

19
00:00:44,000 --> 00:00:45,433
他們會一致地將

20
00:00:45,433 --> 00:00:48,866
這種組合視為Feed

21
00:00:48,866 --> 00:00:51,033
Loader與普通的FeedLoader

22
00:00:51,033 --> 00:00:53,033
介面一樣，沒錯

23
00:00:53,033 --> 00:00:54,800
FeedImage也是

24
00:00:54,800 --> 00:00:56,866
DataLoader也一樣

25
00:00:56,866 --> 00:00:58,633
不同的是我們可能

26
00:00:58,633 --> 00:01:00,233
優先要先


27
00:01:00,233 --> 00:01:03,733
在從遠端加載前，檢查我們是否本地有影像

28
00:01:03,733 --> 00:01:06,400
所以其實這是相反的邏輯

29
00:01:06,400 --> 00:01:08,066
基本上這就是這樣

30
00:01:08,066 --> 00:01:10,533
確實如此，因為影像下載花費相當大

31
00:01:10,533 --> 00:01:12,000
所以嘗試先從本地加載影像

32
00:01:12,000 --> 00:01:14,066
如果失敗的話

33
00:01:14,066 --> 00:01:15,900
則從遠端加載，但這的想法就是

34
00:01:15,900 --> 00:01:18,866
它們兩者都有共享的介面，我們可以

35
00:01:18,866 --> 00:01:19,666
都

36
00:01:19,666 --> 00:01:22,400
創建一個複合體

37
00:01:22,400 --> 00:01:23,833
它們也實現了該介面，所以

38
00:01:23,833 --> 00:01:26,066
客戶端無須知道

39
00:01:26,066 --> 00:01:27,733
這種組合

40
00:01:27,733 --> 00:01:28,633
他們可以將整個複合體

41
00:01:28,633 --> 00:01:31,100
統一對待

42
00:01:31,100 --> 00:01:32,233
通過FeedImageDataLoader協議

43
00:01:32,233 --> 00:01:35,433
確實如此，讓我們先從Feed開始

44
00:01:35,433 --> 00:01:38,000
Loader

45
00:01:38,000 --> 00:01:38,766
我們需要從遠端加載，如果

46
00:01:38,766 --> 00:01:41,333
失敗的話

47
00:01:41,333 --> 00:01:41,833
它會從本地加載，好的，就如平常

48
00:01:41,833 --> 00:01:45,433
讓我們從一個測試開始

49
00:01:45,433 --> 00:01:47,600
好的，那麼

50
00:01:47,600 --> 00:01:49,333
讓我們創建

51
00:01:49,333 --> 00:01:52,366
一個RemoteWithLocal

52
00:01:52,366 --> 00:01:57,033
FallbackFeedLoaderTests

53
00:01:57,033 --> 00:02:00,066
正如你所說的，我們希望能傳遞一个

54
00:02:00,066 --> 00:02:01,433
遠端資訊流

55
00:02:01,433 --> 00:02:04,366
當遠端加載成功時

56
00:02:04,366 --> 00:02:04,766
好的

57
00:02:04,766 --> 00:02:07,333
因此首先做的測試是嘗試從

58
00:02:07,333 --> 00:02:08,300
複合組件 

59
00:02:08,300 --> 00:02:10,700
它應該提供遠端資訊流如果它

60
00:02:10,700 --> 00:02:11,666
成功的

61
00:02:11,666 --> 00:02:14,700
從遠程加載，到目前為止，我們已經

62
00:02:14,700 --> 00:02:16,633
測試我們的組件

63
00:02:16,633 --> 00:02:20,233
使用間諜，但是這次嘗試

64
00:02:20,233 --> 00:02:23,666
一種不同的測試雙份，名為Stub

65
00:02:23,666 --> 00:02:28,233
好的，讓我們創建我們的斷言

66
00:02:28,233 --> 00:02:31,333
所以我們期望加載資訊流，所以讓我們

67
00:02:31,333 --> 00:02:34,300
有一個接收到的資訊流，我們將

68
00:02:34,300 --> 00:02:35,566
將它進行比較

69
00:02:35,566 --> 00:02:38,633
使用一個經過Stub的結果，我們稱它為

70
00:02:38,633 --> 00:02:41,733
remoteFeed，好的，所以

71
00:02:41,733 --> 00:02:44,400
接收到的資訊流應該和

72
00:02:44,400 --> 00:02:45,033
Stub的

73
00:02:45,033 --> 00:02:48,633
遠端資訊流完全一樣，所以要捕獲

74
00:02:48,633 --> 00:02:50,466
接收到的資訊流我們需要首先

75
00:02:50,466 --> 00:02:51,666
調用加載

76
00:02:51,666 --> 00:02:54,466
在待測系統中，SUT，並且我們

77
00:02:54,466 --> 00:02:56,866
得到一份回報

78
00:02:56,866 --> 00:02:58,933
並要捕獲從

79
00:02:58,933 --> 00:02:59,900
結果中獲得的資訊流

80
00:02:59,900 --> 00:03:02,933
我們需要一個外部屬性變數

81
00:03:02,933 --> 00:03:05,333
型別為 FeedImage 的陣列，因為

82
00:03:05,333 --> 00:03:06,400
這就是資訊串流

83
00:03:06,400 --> 00:03:09,566
一個資訊串流是 FeedImage 的陣列好嗎？

84
00:03:09,566 --> 00:03:11,433
而這邊我們可以捕捉收到的

85
00:03:11,433 --> 00:03:13,900
資訊串流，所以如果我們得到一個成功的

86
00:03:13,900 --> 00:03:15,733
資訊串流，我們可以捕捉到收到的

87
00:03:15,733 --> 00:03:16,933
資訊串流然後

88
00:03:16,933 --> 00:03:20,133
我們可以確認他們完全一樣

89
00:03:20,133 --> 00:03:23,266
和被模擬的遠端資訊串流完全一樣，如果

90
00:03:23,266 --> 00:03:24,300
它失敗

91
00:03:24,300 --> 00:03:27,333
我們希望帶出一個錯誤訊息原本期待

92
00:03:27,333 --> 00:03:29,666
成功讀取資訊串流結果

93
00:03:29,666 --> 00:03:32,766
結果卻獲得了另一種結果，就是這樣

94
00:03:32,766 --> 00:03:35,200
而因為我們在

95
00:03:35,200 --> 00:03:36,300
switch 敘述中有失敗的斷言

96
00:03:36,300 --> 00:03:39,100
我們可以在 switch 敘述中移動等於斷言

97
00:03:39,100 --> 00:03:41,433
也在 switch 敘述中

98
00:03:41,433 --> 00:03:44,233
對，我們只是重新命名資訊串流，我們

99
00:03:44,233 --> 00:03:45,500
不需要這個外部的

100
00:03:45,500 --> 00:03:48,000
變數，就這樣，但因為我們現在並沒有

101
00:03:48,000 --> 00:03:49,666
捕捉一個價值，所以現在我們需要

102
00:03:49,666 --> 00:03:51,266
一個期待的結果

103
00:03:51,266 --> 00:03:54,633
所以我們可以在這裡完成並等待

104
00:03:54,633 --> 00:03:57,033
以等候超時的期望值

105
00:03:57,033 --> 00:03:58,766
這樣我們確定在測試結束時

106
00:03:58,766 --> 00:04:01,433
會執行到 closure，否則

107
00:04:01,433 --> 00:04:02,066
我們將會得到

108
00:04:02,066 --> 00:04:05,200
一個失敗，確實最後

109
00:04:05,200 --> 00:04:08,233
我們實例化我們的測試系統

110
00:04:08,233 --> 00:04:10,933
它將是一個RemoteWithLocal

111
00:04:10,933 --> 00:04:11,566
Fallback

112
00:04:11,566 --> 00:04:14,300
FeedLoader，所以我們需要先從一

113
00:04:14,300 --> 00:04:15,266
遠程

114
00:04:15,266 --> 00:04:20,300
加載器和本地加載器開始

115
00:04:20,300 --> 00:04:22,866
所以下一步我們需要創建我們的類型

116
00:04:22,866 --> 00:04:24,366
是RemoteWithLocal

117
00:04:24,366 --> 00:04:27,500
FallbackFeedLoader，好的在這裡我們

118
00:04:27,500 --> 00:04:29,433
獲得了RemoteFeedLoader和Local

119
00:04:29,433 --> 00:04:30,233
FeedLoader

120
00:04:30,233 --> 00:04:32,533
作為依賴，所以我們需要導入

121
00:04:32,533 --> 00:04:33,833
EssentialFeed，因為

122
00:04:33,833 --> 00:04:35,600
那裡有RemoteFeedLoader和

123
00:04:35,600 --> 00:04:37,733
LocalFeedLoader存在

124
00:04:37,733 --> 00:04:40,000
確實，我們在這裡傳遞的是具體的

125
00:04:40,000 --> 00:04:41,166
類型

126
00:04:41,166 --> 00:04:44,866
具體的RemoteFeedLoader

127
00:04:44,866 --> 00:04:50,066
和具體的LocalFeedLoader


128
00:04:50,066 --> 00:04:52,300
所以我們需要創建我們的遠程加載器

129
00:04:52,300 --> 00:04:53,333
這就是具體的

130
00:04:53,333 --> 00:04:55,600
RemoteFeedLoader但現在我們需要

131
00:04:55,600 --> 00:04:56,800
創建依賴項

132
00:04:56,800 --> 00:05:00,066
對於RemoteFeedLoader它需要

133
00:05:00,066 --> 00:05:03,266
URL和客戶端，所以我們需要創建一個

134
00:05:03,266 --> 00:05:05,433
URL

135
00:05:05,433 --> 00:05:07,433
現在我們需要創建一個客戶端，現在我們

136
00:05:07,433 --> 00:05:08,866
該創建哪個客戶端呢

137
00:05:08,866 --> 00:05:11,166
我們不想使用真正的HTTP

138
00:05:11,166 --> 00:05:12,133
客戶端

139
00:05:12,133 --> 00:05:15,333
並實際執行請求正確

140
00:05:15,333 --> 00:05:17,600
我們已經 測試過 RemoteFeed

141
00:05:17,600 --> 00:05:18,533
加載器

142
00:05:18,533 --> 00:05:21,600
我們不想再次測試正確

143
00:05:21,600 --> 00:05:23,833
我們想要測試 RemoteWithLocal

144
00:05:23,833 --> 00:05:25,600
FallbackFeedLoader

145
00:05:25,600 --> 00:05:29,266
與未來無關

146
00:05:29,266 --> 00:05:31,100
如果 RemoteFeedLoader 需要更多

147
00:05:31,100 --> 00:05:32,300
依賴項

148
00:05:32,300 --> 00:05:35,500
我不想破壞這個測試是的

149
00:05:35,500 --> 00:05:39,166
確實，例如，我們希望添加

150
00:05:39,166 --> 00:05:41,900
任何類型的訪問令牌依賴於

151
00:05:41,900 --> 00:05:43,500
RemoteFeedLoader

152
00:05:43,500 --> 00:05:45,833
我們需要來進行這個測試，我們需要來

153
00:05:45,833 --> 00:05:47,166
在這裡並給出一個模擬的

154
00:05:47,166 --> 00:05:50,233
令牌，即便這個測試並不關心

155
00:05:50,233 --> 00:05:52,800
訪問令牌

156
00:05:52,800 --> 00:05:54,633
所以每次我們改變了 RemoteFeed

157
00:05:54,633 --> 00:05:56,533
Loader 或者 LocalFeedLoader 那裡

158
00:05:56,533 --> 00:05:58,800
也有其自身的依賴項

159
00:05:58,800 --> 00:06:00,800
我們可能會打破這個測試，這

160
00:06:00,800 --> 00:06:02,700
完全不相關

161
00:06:02,700 --> 00:06:05,100
這就是為什麼我們需要對

162
00:06:05,100 --> 00:06:06,700
抽象概念進行測試

163
00:06:06,700 --> 00:06:09,500
而不是具體類型，否則我們

164
00:06:09,500 --> 00:06:12,133
會結束於集成測試

165
00:06:12,133 --> 00:06:15,166
確實，它們有自身的價值，但是

166
00:06:15,166 --> 00:06:18,133
在這個情況下，我們不需要它們，是的

167
00:06:18,133 --> 00:06:20,133
我們正在測試 RemoteWithLocal 

168
00:06:20,133 --> 00:06:22,700
FallbackFeedLoader 在單元級別上

169
00:06:22,700 --> 00:06:25,833
因此，我們不希望具體的細節

170
00:06:25,833 --> 00:06:27,100
在未來破壞這個測試

171
00:06:27,100 --> 00:06:29,100
我們希望對

172
00:06:29,100 --> 00:06:30,533
抽象進行測試

173
00:06:30,533 --> 00:06:33,433
來單獨的測試這個元件

174
00:06:33,433 --> 00:06:34,633
沒錯

175
00:06:34,633 --> 00:06:36,866
並且我們已經有一個抽象，那就是

176
00:06:36,866 --> 00:06:37,833
FeedLoader

177
00:06:37,833 --> 00:06:40,933
協議

178
00:06:40,933 --> 00:06:43,666
所以我們不需要暴露這裡的具體

179
00:06:43,666 --> 00:06:44,866
類型

180
00:06:44,866 --> 00:06:46,800
我們只需使用抽象即

181
00:06:46,800 --> 00:06:49,266
協定，就是這樣

182
00:06:49,266 --> 00:06:51,833
現在我們不需要使用真正的 Remote

183
00:06:51,833 --> 00:06:52,700
FeedLoader

184
00:06:52,700 --> 00:06:56,533
在測試時，我們可以創建

185
00:06:56,533 --> 00:06:59,833
一個 stub 或 spy 或 mock

186
00:06:59,833 --> 00:07:02,133
這樣我們可以保護這個測試免受

187
00:07:02,133 --> 00:07:03,666
未來變化的影響

188
00:07:03,666 --> 00:07:06,133
我們正在測試 RemoteWithLocal

189
00:07:06,133 --> 00:07:07,566
FallbackFeedLoader

190
00:07:07,566 --> 00:07:10,866
在隔離狀況下，不過還有另一個

191
00:07:10,866 --> 00:07:12,300
現在的問題

192
00:07:12,300 --> 00:07:15,733
我們可以獲得參數的順序

193
00:07:15,733 --> 00:07:19,666
remote 和 local 錯誤，並且編譯器

194
00:07:19,666 --> 00:07:22,133
將無法幫助我們，它不會指導我們如何

195
00:07:22,133 --> 00:07:23,833
區分兩者

196
00:07:23,833 --> 00:07:27,033
對，這顯然是錯誤的順序，但編譯器完全接受

197
00:07:27,033 --> 00:07:30,066
它沒有問題

198
00:07:30,066 --> 00:07:30,866
因為我們正在使用的是抽象

199
00:07:30,866 --> 00:07:32,633
並非具體類型

200
00:07:32,633 --> 00:07:34,233
對，正是如此，你該怎麼辦

201
00:07:34,233 --> 00:07:37,333
當你沒有編譯時間

202
00:07:37,333 --> 00:07:38,800
保證呢

203
00:07:38,800 --> 00:07:40,400
呢

204
00:07:40,400 --> 00:07:43,166
你寫的是精確的測試，這就是

205
00:07:43,166 --> 00:07:44,866
我們正在做的事情，我們正在寫

206
00:07:44,866 --> 00:07:45,900
測試

207
00:07:45,900 --> 00:07:48,700
所以測試可以保證正確的順序

208
00:07:48,700 --> 00:07:50,233
因為你在測試行為

209
00:07:50,233 --> 00:07:52,866
如果你把順序搞錯了，那行為

210
00:07:52,866 --> 00:07:54,233
將會出錯

211
00:07:54,233 --> 00:07:57,266
就是這樣，所以這裡有一個取捨，我們

212
00:07:57,266 --> 00:07:58,133
可以選擇

213
00:07:58,133 --> 00:08:00,300
用具體的類型，但那樣的話我們的

214
00:08:00,300 --> 00:08:01,500
測試將會

215
00:08:01,500 --> 00:08:04,533
綁定到具體的類型，每一次

216
00:08:04,533 --> 00:08:06,233
這些具體的類型發生變化

217
00:08:06,233 --> 00:08:09,433
我們的測試就會失效，如果我們選擇

218
00:08:09,433 --> 00:08:10,866
抽象化

219
00:08:10,866 --> 00:08:13,100
我們可能會失去一點編譯時間

220
00:08:13,100 --> 00:08:14,466
的保證

221
00:08:14,466 --> 00:08:16,633
但由於我們有測試，我對此感到滿意

222
00:08:16,633 --> 00:08:18,000
是的

223
00:08:18,000 --> 00:08:21,100
確實，我們也可以創建特定的

224
00:08:21,100 --> 00:08:22,300
抽象化

225
00:08:22,300 --> 00:08:25,433
表示 feed 的遠程和本地

226
00:08:25,433 --> 00:08:28,233
產生地，對，我們可以

227
00:08:28,233 --> 00:08:30,400
創建一個 RemoteFeedLoader 協議

228
00:08:30,400 --> 00:08:31,900
該協議繼承自 FeedLoader

229
00:08:31,900 --> 00:08:34,133
完全按照協定來，可以創建一個

230
00:08:34,133 --> 00:08:34,766
本地的

231
00:08:34,766 --> 00:08:37,200
FeedLoader 協定，他們也繼承了

232
00:08:37,200 --> 00:08:38,866
FeedLoader 協定 

233
00:08:38,866 --> 00:08:41,333
我們可以在這裡標註出來，就是

234
00:08:41,333 --> 00:08:42,766
這樣

235
00:08:42,766 --> 00:08:44,466
所以現在你會得到編譯時期的

236
00:08:44,466 --> 00:08:46,366
保證，並且我們可以創建

237
00:08:46,366 --> 00:08:49,200
兩種類型的 Stub，RemoteLoader 的

238
00:08:49,200 --> 00:08:50,366
Stub 

239
00:08:50,366 --> 00:08:53,666
以及 LocalLoaderStub，一個執行

240
00:08:53,666 --> 00:08:55,200
RemoteFeedLoader

241
00:08:55,200 --> 00:08:57,200
及另一個執行本地的

242
00:08:57,200 --> 00:08:58,300
FeedLoader

243
00:08:58,300 --> 00:09:02,000
對，編譯器現在會告訴我們

244
00:09:02,000 --> 00:09:04,000
順序錯誤 

245
00:09:04,000 --> 00:09:07,733
我們必須修正，這就對了。

246
00:09:07,733 --> 00:09:10,800
對，所以這個解決方案也解決了

247
00:09:10,800 --> 00:09:13,733
具體實現的問題。

248
00:09:13,733 --> 00:09:14,300
也

249
00:09:14,300 --> 00:09:17,500
解決了順序問題，對，現在 

250
00:09:17,500 --> 00:09:20,233
我們有這些類型只是為了標註

251
00:09:20,233 --> 00:09:22,133
這兩個組件是不同的。

252
00:09:22,133 --> 00:09:23,900
組件

253
00:09:23,900 --> 00:09:26,366
我們可以讓具體類型

254
00:09:26,366 --> 00:09:27,100
實現

255
00:09:27,100 --> 00:09:30,133
這些協定與擴展

256
00:09:30,133 --> 00:09:32,000
所以具體的類型存在於 Essential 內

257
00:09:32,000 --> 00:09:33,833
Feed模組，所以我們需要

258
00:09:33,833 --> 00:09:36,633
添加名為EssentialFeed的模組。

259
00:09:36,633 --> 00:09:37,333
遠程的

260
00:09:37,333 --> 00:09:39,833
FeedLoader在我們提及具體的

261
00:09:39,833 --> 00:09:40,366
類型

262
00:09:40,366 --> 00:09:42,300
我們可以使其實現遠程的

263
00:09:42,300 --> 00:09:44,233
FeedLoader協議

264
00:09:44,233 --> 00:09:46,633
就是這樣，你可以用同樣的方法

265
00:09:46,633 --> 00:09:48,366
對本地的進行操作

266
00:09:48,366 --> 00:09:50,066
這就完成了，現在你回到了

267
00:09:50,066 --> 00:09:51,833
編譯時期的安全性

268
00:09:51,833 --> 00:09:53,033
如你所見，它們名稱與具體的類型相同，遠程的

269
00:09:53,033 --> 00:09:55,100
FeedLoader 和 LocalFeedLoader

270
00:09:55,100 --> 00:09:56,933
但由於它們在不同的模組中

271
00:09:56,933 --> 00:09:59,500
所以我們不會有命名衝突

272
00:09:59,500 --> 00:10:02,133
我只是認為我們不需要它，因為我們

273
00:10:02,133 --> 00:10:04,133
已經擁有測試

274
00:10:04,133 --> 00:10:05,500
是的，但知道你可以

275
00:10:05,500 --> 00:10:07,833
使用這種技巧還是很好的

276
00:10:07,833 --> 00:10:08,933
以便我們可以透過類型註釋來捕捉

277
00:10:08,933 --> 00:10:11,500
可能的錯誤

278
00:10:11,500 --> 00:10:12,233
利用編譯器的幫助，但因為

279
00:10:12,233 --> 00:10:14,700
我們正在進行TDD

280
00:10:14,700 --> 00:10:16,700
因此我們不需要這種方式

281
00:10:16,700 --> 00:10:18,300
我很高興能夠選擇簡單的

282
00:10:18,300 --> 00:10:20,466
解決方案，直接使用這種抽象化手段

283
00:10:20,466 --> 00:10:21,266
在這裡

284
00:10:21,266 --> 00:10:24,366
你認為呢同意的，我認為它

285
00:10:24,366 --> 00:10:25,433
提供給我們

286
00:10:25,433 --> 00:10:28,133
更多的自由，比創建新的

287
00:10:28,133 --> 00:10:29,033
類型

288
00:10:29,033 --> 00:10:31,100
而我們同時擁有的組件更少

289
00:10:31,100 --> 00:10:32,300
時間

290
00:10:32,300 --> 00:10:34,933
正確的，更少的組件代表更少的程式碼

291
00:10:34,933 --> 00:10:36,366
更少的複雜性

292
00:10:36,366 --> 00:10:39,833
簡化，沒錯，且由於我們現在

293
00:10:39,833 --> 00:10:42,000
不再擁有編譯器的保證，我甚至想要重新命名

294
00:10:42,000 --> 00:10:43,900
這些屬性，對，因為沒有

296
00:10:47,333 --> 00:10:50,533
遠端 anymore，也沒有本地 anymore

297
00:10:50,533 --> 00:10:53,200
這些觀念因為具體類型的消失而消失

298
00:10:53,200 --> 00:10:54,933
確實如此，這意味著我們有了更多的

300
00:10:57,033 --> 00:10:58,300
靈活性，

301
00:10:58,300 --> 00:11:01,033
使用抽象化的東西其實我們現在有的

302
00:11:01,033 --> 00:11:01,733
實際上

303
00:11:01,733 --> 00:11:04,866
是一個主要的加載器和一個

304
00:11:04,866 --> 00:11:08,300
後備加載器，就這麼簡單。

305
00:11:08,300 --> 00:11:12,833
這意味著我們有一個主要的加載器

306
00:11:12,833 --> 00:11:15,200
實例

307
00:11:15,200 --> 00:11:18,700
和一個後備加載器實例

308
00:11:18,700 --> 00:11:20,633
透過使用抽象化，我們使我們的代碼

309
00:11:20,633 --> 00:11:22,633
通過命名使事物更靈活

310
00:11:22,633 --> 00:11:24,366
我們也使我們的程式碼更靈活

311
00:11:24,366 --> 00:11:25,433
這就是命名如此重要的原因

312
00:11:25,433 --> 00:11:28,000
確實如此

313
00:11:28,000 --> 00:11:28,933
準確無誤

314
00:11:28,933 --> 00:11:32,000
那麼我們為什麼不也重命名類別呢

315
00:11:32,000 --> 00:11:34,933
所以它不再是RemoteWithLocalFallback

316
00:11:34,933 --> 00:11:36,233
了

317
00:11:36,233 --> 00:11:39,433
它比那更抽象，我們可以

318
00:11:39,433 --> 00:11:40,233
組合

319
00:11:40,233 --> 00:11:42,300
任何類型的FeedLoader並給它一個

320
00:11:42,300 --> 00:11:43,500
後備選項

321
00:11:43,500 --> 00:11:47,266
所以一個好名字可能是FeedLoader

322
00:11:47,266 --> 00:11:50,366
WithFallback，正如我們所說，這是一個

323
00:11:50,366 --> 00:11:53,900
組成體，所以我很高興能加上

324
00:11:53,900 --> 00:11:57,433
Composite作為後綴，FeedLoader

325
00:11:57,433 --> 00:12:02,300
WithFallbackComposite就是了。

326
00:12:02,300 --> 00:12:05,500
看看現在，我們不再將我們的

327
00:12:05,500 --> 00:12:06,800
實現綁定到

328
00:12:06,800 --> 00:12:09,100
具體類型，我們擁有一個更靈活的

329
00:12:09,100 --> 00:12:10,000
組成體

330
00:12:10,000 --> 00:12:13,100
可以組合任何Feed

331
00:12:13,100 --> 00:12:13,666
Loader

332
00:12:13,666 --> 00:12:16,533
與另一個作為後備的FeedLoader

333
00:12:16,533 --> 00:12:17,600
準確無誤

334
00:12:17,600 --> 00:12:20,533
這實際上非常強大，讓我們也一起


335
00:12:20,533 --> 00:12:22,066
重新命名該測試

336
00:12:22,066 --> 00:12:24,300
好的 FeedLoaderWithFallback

337
00:12:24,300 --> 00:12:26,866
CompositeTests

338
00:12:26,866 --> 00:12:28,933
同時，我們來重新命名 remoteFeed

339
00:12:28,933 --> 00:12:30,000
屬性

340
00:12:30,000 --> 00:12:32,700
因為這現在是一個主要的 feed，並且

341
00:12:32,700 --> 00:12:33,200
讓我們

342
00:12:33,200 --> 00:12:36,366
重新命名測試 deliver

343
00:12:36,366 --> 00:12:39,900
在主要加載器上的主要 feed

344
00:12:39,900 --> 00:12:44,300
成功了，就這樣，現在回到測試

345
00:12:44,300 --> 00:12:46,366
編譯器仍然在投訴我們

346
00:12:46,366 --> 00:12:47,900
沒有一個 load 方法

347
00:12:47,900 --> 00:12:50,233
在被測系統裡，因為我們需要

348
00:12:50,233 --> 00:12:52,633
遵循 FeedLoader

349
00:12:52,633 --> 00:12:57,033
並實施 load 方法，好的

350
00:12:57,033 --> 00:12:58,700
最後我們需要創建

351
00:12:58,700 --> 00:13:00,633
主要 feed

352
00:13:00,633 --> 00:13:03,900
這是一組 FeedImages 的陣列

353
00:13:03,900 --> 00:13:07,900
它可以是任何獨特的 feed

354
00:13:07,900 --> 00:13:10,933
因為我們也將需要一個後備

355
00:13:10,933 --> 00:13:13,666
feed 來確保我們得到的是主要的

356
00:13:13,666 --> 00:13:16,133
feed 而不是後備的 feed

357
00:13:16,133 --> 00:13:18,300
我們需要創建獨特的值，因為

358
00:13:18,300 --> 00:13:20,133
它們都是被替代的

359
00:13:20,133 --> 00:13:23,333
結果，我們將在 LoaderStub 中使用

360
00:13:23,333 --> 00:13:26,466
那就是事先定義的數值，就是這樣

361
00:13:26,466 --> 00:13:28,800
所以讓我們實現該唯一的 feed

362
00:13:28,800 --> 00:13:30,000
其實就是創建

363
00:13:30,000 --> 00:13:33,333
一個唯一的 feed 和 UUID

364
00:13:33,333 --> 00:13:37,100
讓它在我們的 LoaderStub 中變得獨特

365
00:13:37,100 --> 00:13:39,900
需要一個結果，所以每次我們調用

366
00:13:39,900 --> 00:13:41,266
load，我們完成

367
00:13:41,266 --> 00:13:44,233
用預設結果，就是這樣，並且

368
00:13:44,233 --> 00:13:45,266
這就是區別

369
00:13:45,266 --> 00:13:48,133
當我們使用 stubs，你設定的值在

370
00:13:48,133 --> 00:13:49,100
前面

371
00:13:49,100 --> 00:13:51,500
而用 spy，你捕捉的值

372
00:13:51,500 --> 00:13:52,233
你可以使用它

373
00:13:52,233 --> 00:13:55,666
稍後確切地說，stubs簡單得多

374
00:13:55,666 --> 00:13:57,600
但对於發生的事不那麼精確

375
00:13:57,600 --> 00:13:58,800
在測試的過程中

376
00:13:58,800 --> 00:14:02,133
這就是為什麼他們更靈活

377
00:14:02,133 --> 00:14:04,533
現在讓我們運行測試，我們應該

378
00:14:04,533 --> 00:14:06,633
看到一個失敗，因為我們從未完成

379
00:14:06,633 --> 00:14:09,500
所以期望不應該

380
00:14:09,500 --> 00:14:11,100
被滿足

381
00:14:11,100 --> 00:14:13,900
就在這裡，期望未達成，我們

382
00:14:13,900 --> 00:14:14,633
從未

383
00:14:14,633 --> 00:14:18,366
執行過load完成，太棒了

384
00:14:18,366 --> 00:14:20,700
讓我們實行加載方法以使

385
00:14:20,700 --> 00:14:22,366
測試通過

386
00:14:22,366 --> 00:14:24,366
因此我們需從主要

387
00:14:24,366 --> 00:14:26,000
來源載入從主要

388
00:14:26,000 --> 00:14:28,300
加載器，這意味著我們需要捕捉

389
00:14:28,300 --> 00:14:29,100
主要的

390
00:14:29,100 --> 00:14:32,233
FeedLoader現在我們可以加載

391
00:14:32,233 --> 00:14:33,833
現在我們只需要傳遞

392
00:14:33,833 --> 00:14:36,633
完成，只需轉發信息

393
00:14:36,633 --> 00:14:40,133
就是這樣，現在測試應該通過

394
00:14:40,133 --> 00:14:43,433
並且它做到了。所以這就是存根

395
00:14:43,433 --> 00:14:44,300
做的事

396
00:14:44,300 --> 00:14:47,500
我們設置主要加載器以成功

397
00:14:47,500 --> 00:14:48,933
具有主要飼料

398
00:14:48,933 --> 00:14:51,166
並具有陷阱加載器以成功與

399
00:14:51,166 --> 00:14:52,866
陷阱飼料

400
00:14:52,866 --> 00:14:55,500
我們期望我們的合成完成

401
00:14:55,500 --> 00:14:56,866
具有主要飼料

402
00:14:56,866 --> 00:14:59,100
證明它從

403
00:14:59,100 --> 00:15:00,700
主要加載器載入

404
00:15:00,700 --> 00:15:04,800
太棒了，讓我們承諾

405
00:15:04,800 --> 00:15:07,266
FeedLoaderWithFallbackComposite

406
00:15:07,266 --> 00:15:08,066
提供

407
00:15:08,066 --> 00:15:12,000
主要飼料在主要加載器成功

408
00:15:12,000 --> 00:15:14,633
就是這樣，存根非常簡單且

409
00:15:14,633 --> 00:15:15,733
非常有用

410
00:15:15,733 --> 00:15:17,600
但我們必須做很多前期

411
00:15:17,600 --> 00:15:18,866
的決定

412
00:15:18,866 --> 00:15:21,500
當你有一個簡單的使用情境時，stubs

413
00:15:21,500 --> 00:15:23,166
更具彈性

414
00:15:23,166 --> 00:15:25,733
所以我很滿意，對我們可以來做

415
00:15:25,733 --> 00:15:26,866
這個

416
00:15:26,866 --> 00:15:29,900
測試案例。好的，但在我們繼續之前

417
00:15:29,900 --> 00:15:33,100
讓我們創建我們的makeSUT工廠方法

418
00:15:33,100 --> 00:15:35,733
好的，所以我們可以創建我們的主要loader

419
00:15:35,733 --> 00:15:36,866
和後備loader

420
00:15:36,866 --> 00:15:39,833
在這裡並稍微簡化一下

421
00:15:39,833 --> 00:15:40,866
實例化

422
00:15:40,866 --> 00:15:43,733
這裡，所以我們使用主要的

423
00:15:43,733 --> 00:15:44,300
結果來創造sut

424
00:15:44,300 --> 00:15:47,033
和一個後備結果。就是這樣，

425
00:15:47,033 --> 00:15:49,100
提交

426
00:15:49,100 --> 00:15:52,300
將系統開發過程創建分離到

427
00:15:52,300 --> 00:15:53,100
工廠裡

428
00:15:53,100 --> 00:15:56,866
方法，現在下一個測試

429
00:15:56,866 --> 00:15:59,433
所以如果主要的loader成功，我們

430
00:15:59,433 --> 00:16:01,166
只需要完成主要的

431
00:16:01,166 --> 00:16:04,000
減載，但如果主要的

432
00:16:04,000 --> 00:16:04,800
loader

433
00:16:04,800 --> 00:16:07,666
失敗，我們需要提供

434
00:16:07,666 --> 00:16:08,366
後備的

435
00:16:08,366 --> 00:16:12,866
減載。對，這就是這裡的策略

436
00:16:12,866 --> 00:16:15,600
那麼這就是我們接下來的測試，因此我們創建

437
00:16:15,600 --> 00:16:16,300
sut

438
00:16:16,300 --> 00:16:19,100
出現的第一個結果是失敗，然後是

439
00:16:19,100 --> 00:16:20,133
備用結果

440
00:16:20,133 --> 00:16:23,433
作為成功的備用供應源

441
00:16:23,433 --> 00:16:26,700
我們預期接收到成功的結果

442
00:16:26,700 --> 00:16:29,600
帶有備用供應源的成功結果，這點

443
00:16:29,600 --> 00:16:31,266
和我們第一次測試時期望得到的不同

444
00:16:31,266 --> 00:16:34,700
期望得到主供應源

445
00:16:34,700 --> 00:16:37,733
如果再次失敗，我們又有一個很好的

446
00:16:37,733 --> 00:16:38,466
斷言

447
00:16:38,466 --> 00:16:42,533
幫助我們識別問題

448
00:16:42,533 --> 00:16:45,433
讓我們創建anyNSError工廠

449
00:16:45,433 --> 00:16:46,700
助手

450
00:16:46,700 --> 00:16:49,733
只需創建一個簡單的錯誤

451
00:16:49,733 --> 00:16:53,433
然後讓我們運行該測試應該會失敗

452
00:16:53,433 --> 00:16:56,533
瞧，一切如預期，載入成功

453
00:16:56,533 --> 00:16:57,500
訂閱結果

454
00:16:57,500 --> 00:17:00,633
出現故障，那麼，讓我們回到

455
00:17:00,633 --> 00:17:02,300
產品之中

456
00:17:02,300 --> 00:17:05,900
所以現在我們需要備用載入器

457
00:17:05,900 --> 00:17:08,466
是的，現在我們需要解開主要的

458
00:17:08,466 --> 00:17:09,266
裝載

459
00:17:09,266 --> 00:17:12,466
結果，因為我們需要檢查

460
00:17:12,466 --> 00:17:13,666
結果

461
00:17:13,666 --> 00:17:17,433
確切地說，如果它是成功的

462
00:17:17,433 --> 00:17:20,000
我們就直接用結果進行完結

463
00:17:20,000 --> 00:17:21,666
就這樣

464
00:17:21,666 --> 00:17:25,100
現在如果它出了錯誤，我們就從

465
00:17:25,100 --> 00:17:28,233
fallback那裡讀取，但當然

466
00:17:28,233 --> 00:17:32,066
讓我們在這裡將self弱引用

467
00:17:32,066 --> 00:17:35,100
讓我們執行測試

468
00:17:35,100 --> 00:17:40,233
現在它已經通過了，讓我們提交

469
00:17:40,233 --> 00:17:42,633
FeedLoaderWithFallbackComposite

470
00:17:42,633 --> 00:17:43,433
提供了

471
00:17:43,433 --> 00:17:47,433
在主loader失敗時的fallback feed

472
00:17:47,433 --> 00:17:50,933
這就結束了，現在該消除一些

473
00:17:50,933 --> 00:17:52,400
重複的部分了

474
00:17:52,400 --> 00:17:55,266
看看這裡，這就是預期等待

475
00:17:55,266 --> 00:17:56,533
加載，預期

476
00:17:56,533 --> 00:18:00,066
等待加載，你可以走進

477
00:18:00,066 --> 00:18:03,100
一個助手，建立一個可重複使用的

478
00:18:03,100 --> 00:18:05,900
載入和斷言接收值的

479
00:18:05,900 --> 00:18:07,433
方式

480
00:18:07,433 --> 00:18:10,133
現在我們可以簡化這個邏輯，我們

481
00:18:10,133 --> 00:18:10,933
期望

482
00:18:10,933 --> 00:18:14,066
sut完成成功

483
00:18:14,066 --> 00:18:17,500
fallback feed，看看這個，添加了第一個

484
00:18:17,500 --> 00:18:18,133
我們期望sut完成

485
00:18:18,133 --> 00:18:21,266
成功的primary feed，所以這就完成了

486
00:18:21,266 --> 00:18:25,600
如果有一個成功的主要結果

487
00:18:25,600 --> 00:18:28,133
我們期望

488
00:18:28,133 --> 00:18:28,866
得到主要的成功結果，如果

489
00:18:28,866 --> 00:18:31,833
主結果

490
00:18:31,833 --> 00:18:32,933
是這樣。

491
00:18:32,933 --> 00:18:36,633
是失敗，而倒退則是成功

492
00:18:36,633 --> 00:18:39,200
我們希望得到一個成功的倒退

493
00:18:39,200 --> 00:18:40,066
結果

494
00:18:40,066 --> 00:18:44,233
就是這樣，太棒了，我們來運行測試

495
00:18:44,233 --> 00:18:47,733
通過，我們來提交

496
00:18:47,733 --> 00:18:50,400
將重複的載入邏輯提取到一個

497
00:18:50,400 --> 00:18:51,200
輔助工具

498
00:18:51,200 --> 00:18:54,400
方法就是這個

499
00:18:54,400 --> 00:18:57,600
現在如果兩者都失敗了怎麼辦

500
00:18:57,600 --> 00:19:00,233
所以它應該傳遞一個錯誤，它應該

501
00:19:00,233 --> 00:19:01,100
傳遞一個錯誤

502
00:19:01,100 --> 00:19:04,066
確實如此，當兩者都

503
00:19:04,066 --> 00:19:07,200
主要和倒退載入器失敗時傳遞錯誤

504
00:19:07,200 --> 00:19:11,433
那我們為兩個載入器設定失敗

505
00:19:11,433 --> 00:19:14,466
然後我們期望我們的系統測試也

506
00:19:14,466 --> 00:19:15,266
完成

507
00:19:15,266 --> 00:19:19,033
也是以失敗結束，就是這樣

508
00:19:19,033 --> 00:19:22,933
通過，太棒了，讓我們提交

509
00:19:22,933 --> 00:19:26,133
所以在主要和倒退都失敗時傳遞錯誤

510
00:19:26,133 --> 00:19:30,133
並倒退失敗，好的

511
00:19:30,133 --> 00:19:33,033
就是這樣，就是全部，這就是

512
00:19:33,033 --> 00:19:33,600
如此簡單

513
00:19:33,600 --> 00:19:37,433
但這個組合器有多強大

514
00:19:37,433 --> 00:19:40,866
我們可以無限地組合FeedLoaders

515
00:19:40,866 --> 00:19:44,000
有一個倒退，因為我們可以組合

516
00:19:44,000 --> 00:19:46,766
組合器，因為組合器

517
00:19:46,766 --> 00:19:48,133
實現相同的

518
00:19:48,133 --> 00:19:50,300
介面與相同的 protocol 我們可以

519
00:19:50,300 --> 00:19:53,033
組成完全一樣的composite 

520
00:19:53,033 --> 00:19:55,733
如我們所說，這非常強大，我們

521
00:19:55,733 --> 00:19:56,933
保留客戶端

522
00:19:56,933 --> 00:19:59,100
和 FeedLoader 的實現，

523
00:19:59,100 --> 00:20:00,066
不受限制，

524
00:20:00,066 --> 00:20:03,433
不受fallbacks的制約，不受其他具體

525
00:20:03,433 --> 00:20:04,466
類型的影響，

526
00:20:04,466 --> 00:20:06,866
我們有最大的自由性去組成

527
00:20:06,866 --> 00:20:08,000
FeedLoaders，

528
00:20:08,000 --> 00:20:10,533
我們可以按我們想要的方式組成，如果你想從本地loader

529
00:20:10,533 --> 00:20:12,400
首先載入，

530
00:20:12,400 --> 00:20:14,466
然後再從遠程載入，我們可以這樣組合，

531
00:20:14,466 --> 00:20:15,733
就像這樣，

532
00:20:15,733 --> 00:20:17,833
如果你想要從遠程首先載入，我們

533
00:20:17,833 --> 00:20:19,833
也可以這樣組合，

534
00:20:19,833 --> 00:20:22,933
太棒了，我們把帶有FallbackComposite的FeedLoader移動到生產環境，

535
00:20:22,933 --> 00:20:26,533
現在我們需要處理訪問權限，

537
00:20:28,066 --> 00:20:31,100
控制，這是一種公共類型，

538
00:20:31,100 --> 00:20:35,833
以便測試能夠訪問，

539
00:20:35,833 --> 00:20:37,900
測試還無法訪問這個

540
00:20:37,900 --> 00:20:40,533
類型，因為我們需要導入

541
00:20:40,533 --> 00:20:42,700
該類型所在的模塊，也就是

542
00:20:42,700 --> 00:20:43,900
不是 EssentialFeed

543
00:20:43,900 --> 00:20:47,500
而是 EssentialApp

544
00:20:47,500 --> 00:20:50,533
好的，讓我們運行測試

545
00:20:50,533 --> 00:20:53,666
太棒了，它通過了，太棒了

546
00:20:53,666 --> 00:20:57,100
那麼我們提交吧

547
00:20:57,100 --> 00:21:00,000
移動 FeedLoaderWithFallbackComposite

548
00:21:00,000 --> 00:21:01,500
到生產

549
00:21:01,500 --> 00:21:06,133
好的，我們需要做相同的事情

550
00:21:06,133 --> 00:21:09,333
對於 FeedImageDataLoader 協議

551
00:21:09,333 --> 00:21:11,833
我們希望能夠組合圖像數據

552
00:21:11,833 --> 00:21:12,633
加載器

553
00:21:12,633 --> 00:21:15,200
具有回退功能，但由於它非常

554
00:21:15,200 --> 00:21:17,500
相似，我們將在攝像機外進行

555
00:21:17,500 --> 00:21:19,266
我們相信您應該自己實現它

556
00:21:19,266 --> 00:21:21,333
進行實踐如何創建

557
00:21:21,333 --> 00:21:25,266
合成物

558
00:21:25,266 --> 00:21:28,000
這裡就是 FeedImageData

559
00:21:28,000 --> 00:21:28,633
Loader

560
00:21:28,633 --> 00:21:31,600
也使用 WithFallbackComposite

561
00:21:31,600 --> 00:21:33,100
抽象化

562
00:21:33,100 --> 00:21:35,600
FeedImageDataLoader 協議因此

563
00:21:35,600 --> 00:21:37,200
我們可以單獨合成

564
00:21:37,200 --> 00:21:39,500
任何數據加載器與回退以及

565
00:21:39,500 --> 00:21:40,466
綜合組成

566
00:21:40,466 --> 00:21:44,300
亦能完全組成

567
00:21:44,300 --> 00:21:46,633
所以在載入圖像數據時，我們創建一個

568
00:21:46,633 --> 00:21:49,266
任務包裝器

569
00:21:49,266 --> 00:21:51,266
我們開始從主加載器

570
00:21:51,266 --> 00:21:53,100
加載圖像數據

571
00:21:53,100 --> 00:21:55,733
我們保留了對任務的引用所以

572
00:21:55,733 --> 00:21:56,866
如果我們取消

573
00:21:56,866 --> 00:21:59,900
在此階段取消操作我們會取消

574
00:21:59,900 --> 00:22:00,633
主要的

575
00:22:00,633 --> 00:22:03,833
載入圖像數據，然後再次如果我們得到

576
00:22:03,833 --> 00:22:04,466
成功

577
00:22:04,466 --> 00:22:07,900
我們完成結果，如果它失敗

578
00:22:07,900 --> 00:22:10,000
我們嘗試從

579
00:22:10,000 --> 00:22:12,633
備用數據加載器載入圖像數據，現在我們保留一個

580
00:22:12,633 --> 00:22:13,433
引用

581
00:22:13,433 --> 00:22:16,933
至備用任務，所以如果我們在備用加載中取消

582
00:22:16,933 --> 00:22:19,033
我們將取消備用加載

583
00:22:19,033 --> 00:22:20,633
備用加載

584
00:22:20,633 --> 00:22:23,033
就是這麼簡單，我們可以

585
00:22:23,033 --> 00:22:24,300
重用這些

586
00:22:24,300 --> 00:22:27,666
無窮無盡的真棒，就像你說的

587
00:22:27,666 --> 00:22:30,400
由組成這種類型的人來決定

588
00:22:30,400 --> 00:22:32,766
適當地組成主要和備用來源，這可以無限地擴展

589
00:22:32,766 --> 00:22:35,666
並且備用來源，這可以無窮無盡地擴展

590
00:22:35,666 --> 00:22:37,100
就是這樣

591
00:22:37,100 --> 00:22:41,600
所以，我們來看看它在行動中

592
00:22:41,600 --> 00:22:44,533
我們創建我們的RemoteFeedLoader和

593
00:22:44,533 --> 00:22:47,500
ImageLoader與URLSession client

594
00:22:47,500 --> 00:22:49,900
還有讓我們創建一個LocalImage


595
00:22:49,900 --> 00:22:51,900
在LocalFeedLoader中的Loader

596
00:22:51,900 --> 00:22:56,000
與本地的CoreDataStore

597
00:22:56,000 --> 00:22:57,900
現在我們可以使用

598
00:22:57,900 --> 00:23:00,300
綜合

599
00:23:00,300 --> 00:23:03,333
所以FeedLoader就是FeedLoader

600
00:23:03,333 --> 00:23:05,266
配備有FallbackComposite的

601
00:23:05,266 --> 00:23:08,633
其中主要的加載器是遠程的

602
00:23:08,633 --> 00:23:12,233
FeedLoader，而備用的是本地的

603
00:23:12,233 --> 00:23:15,333
FeedLoader，就是這樣，而圖像

604
00:23:15,333 --> 00:23:16,300
加載器

605
00:23:16,300 --> 00:23:18,766
是配備有FallbackComposite的FeedImageDataLoader

606
00:23:18,766 --> 00:23:20,300
FallbackComposite

607
00:23:20,300 --> 00:23:23,333
其中主要的來源是本地的

608
00:23:23,333 --> 00:23:26,066
image loader，而備用的是

609
00:23:26,066 --> 00:23:27,500
遠程的

610
00:23:27,500 --> 00:23:32,133
image loader好的，這裡剛好相反

611
00:23:32,133 --> 00:23:36,300
但我們可以根據需要自由地反轉它

612
00:23:36,300 --> 00:23:39,733
我們甚至可以在那裡放另一個Composite

613
00:23:39,733 --> 00:23:42,700
從記憶體緩存中加載之前

614
00:23:42,700 --> 00:23:43,266
進行

615
00:23:43,266 --> 00:23:46,933
直接到持久儲存，這恰恰是

616
00:23:46,933 --> 00:23:49,033
FeedLoader的備用選項

617
00:23:49,033 --> 00:23:51,333
比如說可以是另一個Composite

618
00:23:51,333 --> 00:23:54,133
其中主要的可以是放在內存中的

619
00:23:54,133 --> 00:23:55,333
儲存

620
00:23:55,333 --> 00:23:59,200
如果失敗，可能會使用本地的作為備用

621
00:23:59,200 --> 00:24:01,666
所以我們可以組成 FeedLoader

622
00:24:01,666 --> 00:24:02,533
複合體

623
00:24:02,533 --> 00:24:05,900
是的，無限地，看看這個

624
00:24:05,900 --> 00:24:09,033
嵌套代碼如何巧妙地表示了

625
00:24:09,033 --> 00:24:10,400
這裡的算法步驟

626
00:24:10,400 --> 00:24:13,100
主要步驟和後備步驟

627
00:24:13,100 --> 00:24:14,233
其中有一個主要的

628
00:24:14,233 --> 00:24:17,033
和一個後備。就是如此，真美

629
00:24:17,033 --> 00:24:19,333
太美了

630
00:24:19,333 --> 00:24:21,900
所以讓我們回去看看，RemoteFeedLoader 有

631
00:24:21,900 --> 00:24:22,533
主要的

632
00:24:22,533 --> 00:24:26,300
和 LocalFeedLoader 做為後備

633
00:24:26,300 --> 00:24:29,833
讓我們運行應用程序

634
00:24:29,833 --> 00:24:33,833
而且它有效果，你看，太棒了

635
00:24:33,833 --> 00:24:36,866
你甚至可以實現一個重試策略

636
00:24:36,866 --> 00:24:38,066
用這個複合體

637
00:24:38,066 --> 00:24:40,400
例如，如果你想要重試兩次

638
00:24:40,400 --> 00:24:41,500
遠程加載器

639
00:24:41,500 --> 00:24:44,466
在轉到後備之前，你可以

640
00:24:44,466 --> 00:24:45,666
創建一個複合體

641
00:24:45,666 --> 00:24:48,133
將 RemoteFeed 設為主要的

642
00:24:48,133 --> 00:24:49,033
Loader

643
00:24:49,033 --> 00:24:51,733
和 LocalFeedLoader 作為後備

644
00:24:51,733 --> 00:24:53,200
所以現在它會嘗試

645
00:24:53,200 --> 00:24:55,833
從遠程加載，後備會去

646
00:24:55,833 --> 00:24:57,900
再次嘗試從遠程加載

647
00:24:57,900 --> 00:24:58,933
然後，它將會去找

648
00:24:58,933 --> 00:25:01,600
fallback，太棒了，不需要計數器

649
00:25:01,600 --> 00:25:02,400
不需要狀態，什麼也不需要，就是這樣，你可以

650
00:25:02,400 --> 00:25:05,033
無限地組合這些東西

651
00:25:05,033 --> 00:25:07,033
你想多少就有多少，當你需要

652
00:25:07,033 --> 00:25:09,200
這種自由時，

653
00:25:09,200 --> 00:25:10,400
要有這種可組合性

654
00:25:10,400 --> 00:25:13,033
這是一種很好的做法

655
00:25:13,033 --> 00:25:14,533
太棒了，那我們來看最後，

656
00:25:14,533 --> 00:25:17,833
我們建立了一個更靈活的

657
00:25:17,833 --> 00:25:19,900
composite

658
00:25:19,900 --> 00:25:21,333
簡單且強大，我們可以使用

659
00:25:21,333 --> 00:25:24,766
concrete types

660
00:25:24,766 --> 00:25:25,733
但再次，我們會將測試代碼

661
00:25:25,733 --> 00:25:28,700
與concrete implementations綁定

662
00:25:28,700 --> 00:25:30,300
所以我們最終會得到的是

663
00:25:30,300 --> 00:25:32,700
易於碎裂的整合測試

664
00:25:32,700 --> 00:25:35,600
進行單元級別的孤立測試會好得多

665
00:25:35,600 --> 00:25:37,033
然後你在較高的層次進行整合測試

666
00:25:37,033 --> 00:25:39,033
我們還展示了如何使用stub進行測試

667
00:25:39,033 --> 00:25:41,100
如你所見，

668
00:25:41,100 --> 00:25:43,266
在一個更高的級別

669
00:25:43,266 --> 00:25:44,933
我們還演示了如何測試東西

670
00:25:44,933 --> 00:25:47,033
使用stub，如你所見

671
00:25:47,033 --> 00:25:50,300
所有這些選擇都有其優點，但是他們

672
00:25:50,300 --> 00:25:51,200
也有

673
00:25:51,200 --> 00:25:55,033
它們的缺點，沒有什麼是完美的

674
00:25:55,033 --> 00:25:56,866
你熟悉的技術越多，解決不同

675
00:25:56,866 --> 00:25:58,633
問題的選項就越多

676
00:25:58,633 --> 00:26:02,066
正確的，全都在於管理

677
00:26:02,066 --> 00:26:03,266
權衡之間的取捨

678
00:26:03,266 --> 00:26:06,633
就是這樣，好，讓我們設定 CI

679
00:26:06,633 --> 00:26:08,466
流水線

680
00:26:08,466 --> 00:26:10,400
確定，現在我們有了一個新項目

681
00:26:10,400 --> 00:26:12,933
我們需要將它添加到 CI 流水線

682
00:26:12,933 --> 00:26:15,833
我們可以在這裡合併我們的

683
00:26:15,833 --> 00:26:16,700
CI_iOS

684
00:26:16,700 --> 00:26:19,500
到工作區，所以讓我們選擇這個

685
00:26:19,500 --> 00:26:21,333
工作區作為容器

686
00:26:21,333 --> 00:26:25,333
用於 CI_iOS 構建

687
00:26:25,333 --> 00:26:28,300
讓我們選擇測試配置

688
00:26:28,300 --> 00:26:29,100
讓我們添加

689
00:26:29,100 --> 00:26:32,066
EssentialAppTests 目標，讓我們

690
00:26:32,066 --> 00:26:32,766
隨機化

691
00:26:32,766 --> 00:26:36,766
執行順序，像往常一樣

692
00:26:36,766 --> 00:26:40,533
讓我們包含 EssentialApp 目標

693
00:26:40,533 --> 00:26:43,833
收集覆蓋率

694
00:26:43,833 --> 00:26:46,633
好的，讓我們更新 CI 配置

695
00:26:46,633 --> 00:26:48,133
檔案

696
00:26:48,133 --> 00:26:50,000
好的，所以現在我們不再使用一個項目


697
00:26:50,000 --> 00:26:53,100
對於CI_iOS配置方案不再需要

698
00:26:53,100 --> 00:26:56,066
它是一個工作區，工作區就是

699
00:26:56,066 --> 00:26:58,766
EssentialApp

700
00:26:58,766 --> 00:27:01,133
xcworkspace

701
00:27:02,866 --> 00:27:04,833
好的，讓我們來看看依赖性

702
00:27:04,833 --> 00:27:07,033
圖表

703
00:27:07,033 --> 00:27:09,733
就是這樣，我們有兩個新類型

704
00:27:09,733 --> 00:27:10,533
composite

705
00:27:10,533 --> 00:27:12,533
實現了FeedLoader並且

706
00:27:12,533 --> 00:27:15,100
與任何類型的FeedLoader組合，有一個

707
00:27:15,100 --> 00:27:16,466
fallback

708
00:27:16,466 --> 00:27:18,000
以及與

709
00:27:18,000 --> 00:27:19,500
FallbackComposite

710
00:27:19,500 --> 00:27:21,200
實現FeedImageData

711
00:27:21,200 --> 00:27:23,333
Loader協議並組合

712
00:27:23,333 --> 00:27:24,866
其他實現Feed

713
00:27:24,866 --> 00:27:26,700
ImageDataLoader的類型，

714
00:27:26,700 --> 00:27:29,833
有一個fallback，就是這樣，沒有更多的

715
00:27:29,833 --> 00:27:33,333
指向具體類型的箭頭，就是這樣

716
00:27:33,333 --> 00:27:34,866
這堂課就到這裡

717
00:27:34,866 --> 00:27:37,333
好的，這篇有點長但極其

718
00:27:37,333 --> 00:27:38,866
重要的一篇

719
00:27:38,866 --> 00:27:42,066
我們下次再見，再見各位

720
00:27:42,066 --> 00:27:53,900
再見