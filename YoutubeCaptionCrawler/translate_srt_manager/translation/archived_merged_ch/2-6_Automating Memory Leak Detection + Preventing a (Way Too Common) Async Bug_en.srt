

1
00:00:01,100 --> 00:00:03,666
哈囉 Mike，嘿 Caio，所以在上一次的

2
00:00:03,666 --> 00:00:05,433
集數我們答應要開始整理一些

3
00:00:05,433 --> 00:00:05,666
碼

4
00:00:05,666 --> 00:00:08,400
在代碼中，所以是時候了，對，我們

5
00:00:08,400 --> 00:00:09,566
來整理一下項目

6
00:00:09,566 --> 00:00:11,100
我們首先提到的是要移動

7
00:00:11,100 --> 00:00:12,766
這些類型到單獨的文件中

8
00:00:12,766 --> 00:00:15,266
對，所以我們有 HTTPClient 和

9
00:00:15,266 --> 00:00:17,433
HTTPClientResult，所以我認為

10
00:00:17,433 --> 00:00:20,133
這兩者都可以移至單一文件中

11
00:00:20,133 --> 00:00:21,833
的確，因為它們相關

12
00:00:21,833 --> 00:00:24,466
它們都是 HTTPClient 類型，我們先

13
00:00:24,466 --> 00:00:25,666
一起保留它們在同一地方

14
00:00:25,666 --> 00:00:28,866
對，讓我們看看是否仍能建構，對

15
00:00:28,866 --> 00:00:31,833
完美，且測試通過了，我們

16
00:00:31,833 --> 00:00:33,033
提交

17
00:00:33,033 --> 00:00:36,933
將 HTTPClient 移至其自己的文件

18
00:00:36,933 --> 00:00:40,233
就是這樣，還有什麼我們可以修復的

19
00:00:40,233 --> 00:00:43,200
我認為 FeedItemsMapper 是個好的

20
00:00:43,200 --> 00:00:44,300
候選項

21
00:00:44,300 --> 00:00:47,266
好的，它是個私有類型，但我們的代碼

22
00:00:47,266 --> 00:00:48,466
可以更整潔


23
00:00:48,466 --> 00:00:51,166
如果我們將其移至一個單獨的檔案，對吧

24
00:00:51,166 --> 00:00:51,833
而

25
00:00:51,833 --> 00:00:54,000
這將變成一種內部型別，因為

26
00:00:54,000 --> 00:00:55,900
我們將其移至新檔案

27
00:00:55,900 --> 00:00:57,433
而我覺得這樣很合理，因為

28
00:00:57,433 --> 00:00:59,166
內部型別，因為這個 Feed

29
00:00:59,166 --> 00:01:02,133
我們有的 API 文件夾就是為了在

30
00:01:02,133 --> 00:01:02,633
其自己

31
00:01:02,633 --> 00:01:05,666
的框架內，其自己的模組以及 Feed

32
00:01:05,666 --> 00:01:06,766
ItemsMapper

33
00:01:06,766 --> 00:01:09,433
會屬於這個模組的內部，它將

34
00:01:09,433 --> 00:01:10,633
無法被

35
00:01:10,633 --> 00:01:12,633
任何其他模組存取，所以我覺得這樣

36
00:01:12,633 --> 00:01:14,633
對現在來說很合理，我們不必新增

37
00:01:14,633 --> 00:01:16,700
內部型別，因為那是預設的

38
00:01:16,700 --> 00:01:19,200
範疇，對吧，但我認為這樣

39
00:01:19,200 --> 00:01:20,533
好極了，我確實喜歡

40
00:01:20,533 --> 00:01:22,700
我們也可以將這個類別設為 final

41
00:01:22,700 --> 00:01:24,766
正確，這並不意味著要

42
00:01:24,766 --> 00:01:27,433
被子類別繼承，所以我喜歡 final

43
00:01:27,433 --> 00:01:28,633
屬性也一樣

44
00:01:28,633 --> 00:01:30,466
並且由於我們正在增加範疇

45
00:01:30,466 --> 00:01:31,900
在各處

46
00:01:31,900 --> 00:01:34,700
這應該設為內部或私有型別，對吧


47
00:01:34,700 --> 00:01:37,033
我認為 static var 可以是私有的

48
00:01:37,033 --> 00:01:38,866
但是 map function 被

49
00:01:38,866 --> 00:01:41,033
Loader 使用，所以它需要是內部的

50
00:01:41,033 --> 00:01:43,100
對，但是沒有其他模組有

51
00:01:43,100 --> 00:01:44,500
訪問它的權限，完美

52
00:01:45,733 --> 00:01:49,200
好的，測試通過了，讓我們進行提交

53
00:01:49,200 --> 00:01:55,200
移動 FeedItemsMapper 到它自己的文件

54
00:01:55,200 --> 00:01:56,533
讓我們看一下 RemoteFeed

55
00:01:56,533 --> 00:01:58,700
Loader 我認為現在好多了

56
00:01:58,700 --> 00:02:01,833
對，縮短很多，只有40行程式碼

57
00:02:01,833 --> 00:02:04,766
在這個文件中，但是這個方法看起來有點

58
00:02:04,766 --> 00:02:05,500
混亂

59
00:02:05,500 --> 00:02:06,933
沒錯，這裡進行了很多事情

60
00:02:06,933 --> 00:02:08,533
或許我們可以提取

61
00:02:08,533 --> 00:02:11,500
一些邏輯到一個助手函數，我

62
00:02:11,500 --> 00:02:12,866
認為這是有道理的

63
00:02:12,866 --> 00:02:15,166
我們可以提取那裡的成功與

64
00:02:15,166 --> 00:02:16,000
映射到

65
00:02:16,000 --> 00:02:21,566
它自己的函數

66
00:02:21,566 --> 00:02:24,300
所以我們可以移動資料和回應

67
00:02:24,300 --> 00:02:26,066
並且應該返回

68
00:02:26,066 --> 00:02:29,200
Result 然後我們可以移動這個邏輯

69
00:02:29,200 --> 00:02:32,000
在這裡，我們並不是要完成，而是只需

70
00:02:32,000 --> 00:02:32,533
返回

71
00:02:32,533 --> 00:02:36,133
結果

72
00:02:36,133 --> 00:02:39,266
然後我們只需完成

73
00:02:39,266 --> 00:02:43,033
通過映射已收到的

74
00:02:43,033 --> 00:02:48,633
response 對吧，讓我們看看它是否通過

75
00:02:48,633 --> 00:02:53,266
它已經通過，但是

76
00:02:53,266 --> 00:02:55,733
現在我們正在這個 block 中捕捉 self 

77
00:02:55,733 --> 00:02:56,633
對

78
00:02:56,633 --> 00:02:59,733
這是我們要的嗎？可能不是我們

79
00:02:59,733 --> 00:03:01,266
在這裡可能有一個保留循環

80
00:03:01,266 --> 00:03:02,233
例如

81
00:03:02,233 --> 00:03:05,200
根據這個 client 如何被創建的

82
00:03:05,200 --> 00:03:05,833
對吧

83
00:03:05,833 --> 00:03:08,000
確實，但所有的測試都通過了

84
00:03:08,000 --> 00:03:09,433
這就有問題

85
00:03:09,433 --> 00:03:12,466
對，因為我們並沒有涵蓋到內存

86
00:03:12,466 --> 00:03:13,666
走漏

87
00:03:13,666 --> 00:03:15,033
所以我認為我們應該添加一些類型的

88
00:03:15,033 --> 00:03:17,100
在我們的測試中檢查這一點的安全措施

89
00:03:17,100 --> 00:03:19,833
對，確實，讓我們這麼做。所以，在每個測試中

90
00:03:19,833 --> 00:03:21,433
在這裡，我們需要檢查

91
00:03:21,433 --> 00:03:23,666
內存走漏，因為不同的

92
00:03:23,666 --> 00:03:25,433
行動可能產生內存走漏

93
00:03:25,433 --> 00:03:28,400
對，所以我們可以在

94
00:03:28,400 --> 00:03:29,266
每個測試中添加斷言

95
00:03:29,266 --> 00:03:31,500
或者我們可以找一個地方進行編輯

96
00:03:31,500 --> 00:03:32,466
然後它將會涵蓋

97
00:03:32,466 --> 00:03:35,500
所有像makeSUT這樣的情況

98
00:03:35,500 --> 00:03:38,300
對，每個測試都使用makeSUT

99
00:03:38,300 --> 00:03:39,200
函數

100
00:03:39,200 --> 00:03:41,333
對，我認為這是一個好的編輯點

101
00:03:41,333 --> 00:03:42,400
編輯

102
00:03:42,400 --> 00:03:45,266
所以我們需要在這之後運行這種斷言

103
00:03:45,266 --> 00:03:46,233
測試

104
00:03:46,233 --> 00:03:48,466
結束，我們需要確保

105
00:03:48,466 --> 00:03:49,566
SUT

106
00:03:49,566 --> 00:03:52,233
從記憶體中釋放，我們可以

107
00:03:52,233 --> 00:03:53,433
運行

108
00:03:53,433 --> 00:03:55,666
那些在測試通過後的斷言

109
00:03:55,666 --> 00:03:56,533
使用

110
00:03:56,533 --> 00:03:58,466
tearDown方法，但還有一個額外

111
00:03:58,466 --> 00:04:00,933
的設施就是退出測試用例

112
00:04:00,933 --> 00:04:03,900
類型為我們提供的是添加tearDown

113
00:04:03,900 --> 00:04:04,466
塊

114
00:04:04,466 --> 00:04:07,833
在每次測試後運行，所以

115
00:04:07,833 --> 00:04:10,633
當每次測試完成後，

116
00:04:10,633 --> 00:04:11,900
tearDown塊

117
00:04:11,900 --> 00:04:14,633
就會被調用，是的，這樣應該就可以了，

118
00:04:14,633 --> 00:04:17,166
我們需要做的就是斷言


119
00:04:17,166 --> 00:04:20,233
nil sut 對，我們需要確保

120
00:04:20,233 --> 00:04:23,100
系統下的實例

121
00:04:23,100 --> 00:04:23,600
測試

122
00:04:23,600 --> 00:04:26,800
在每次測試運行後將會變成 nil

123
00:04:26,800 --> 00:04:29,733
是的，並且在這裡設定一個好消息

124
00:04:29,733 --> 00:04:31,033
實例

125
00:04:31,033 --> 00:04:35,166
應該已經被釋放了可能的

126
00:04:35,166 --> 00:04:37,833
內存洩漏對，我喜歡這點，但現在我們

127
00:04:37,833 --> 00:04:38,533
正在捕獲

128
00:04:38,533 --> 00:04:42,066
在這個區塊中強烈地捕獲 sut，所以這

129
00:04:42,066 --> 00:04:42,933
永遠不會

130
00:04:42,933 --> 00:04:45,166
是 nil，對，確實如此，所以我們可以就

131
00:04:45,166 --> 00:04:46,233
捕獲它

132
00:04:46,233 --> 00:04:48,533
作為弱的，是的，我預期會看到一個

133
00:04:48,533 --> 00:04:50,133
失敗的測試現在，因為我們引入了

134
00:04:50,133 --> 00:04:50,533
那

135
00:04:50,533 --> 00:04:52,066
在區塊內的自我強參照

136
00:04:52,066 --> 00:04:53,833
對，一堆失敗的測試

137
00:04:53,833 --> 00:04:55,100
實際上

138
00:04:55,100 --> 00:04:57,733
是的，看，看來所有的

139
00:04:57,733 --> 00:04:59,500
測試都失敗了，那太棒了

140
00:04:59,500 --> 00:05:01,266
哇，那太棒了，但我想看到

141
00:05:01,266 --> 00:05:02,866
在正確的

142
00:05:02,866 --> 00:05:05,433
行，它失敗了，所以我們可以使用

143
00:05:05,433 --> 00:05:06,300
同樣的技巧

144
00:05:06,300 --> 00:05:08,300
我們在上一集中使用的，然後我們

145
00:05:08,300 --> 00:05:10,700
可以傳遞這個文件

146
00:05:10,700 --> 00:05:13,833
和那行到斷言

147
00:05:13,833 --> 00:05:17,433
好的，現在我們可以看到失敗的地方

148
00:05:17,433 --> 00:05:21,166
確切地在它發生的地方，很好

149
00:05:21,166 --> 00:05:23,900
但我們需要解決它，我想對於

150
00:05:23,900 --> 00:05:25,033
現在我們只是

151
00:05:25,033 --> 00:05:28,800
撤銷我們這裡的更改，讓我們運行測試

152
00:05:28,800 --> 00:05:32,233
是的，它通過了

153
00:05:32,233 --> 00:05:33,600
或我們應該為客戶端做檢查

154
00:05:33,600 --> 00:05:35,833
嗯，我認為是這樣

155
00:05:35,833 --> 00:05:38,233
好的，所以我們可以在這裡新增另一個弱引用

156
00:05:38,233 --> 00:05:40,133
到客戶端

157
00:05:40,133 --> 00:05:42,700
或我們也可以創建一個輔助函數 

158
00:05:42,700 --> 00:05:43,833
就像

159
00:05:43,833 --> 00:05:47,333
追蹤記憶體洩漏

160
00:05:47,333 --> 00:05:49,833
我們可以傳遞instance和它

161
00:05:49,833 --> 00:05:51,033
需要成為

162
00:05:51,033 --> 00:05:53,733
任何對象，讓我們傳遞文件和行

163
00:05:53,733 --> 00:05:54,300
同樣的

164
00:05:54,300 --> 00:05:57,666
所以我們可以將這邏輯移動到這個助手

165
00:05:57,666 --> 00:05:58,233
函數裡

166
00:05:58,233 --> 00:06:02,000
現在我們將實例變為弱引用

167
00:06:02,000 --> 00:06:04,533
現在我們可以運行sut和客戶端

168
00:06:04,533 --> 00:06:05,166
客戶端

169
00:06:05,166 --> 00:06:07,500
也是，看起來不錯，希望能夠通過

170
00:06:07,500 --> 00:06:08,866
很好，讓我們提交，但我不想

171
00:06:08,866 --> 00:06:11,600
馬上提交

172
00:06:11,600 --> 00:06:12,400
這份生產代碼

173
00:06:12,400 --> 00:06:16,066
所以加入記憶體洩漏偵測

174
00:06:16,066 --> 00:06:19,666
很好，現在回到生產代碼

175
00:06:19,666 --> 00:06:24,400
你可以把它放回去，但實際上我們

176
00:06:24,400 --> 00:06:27,100
可以讓這個函數成為靜態的

177
00:06:27,100 --> 00:06:28,633
對，所以我們不需要有一個

178
00:06:28,633 --> 00:06:31,833
實例

179
00:06:31,833 --> 00:06:32,400
來運行這份代碼，這樣就不需要 self

180
00:06:32,400 --> 00:06:35,033
而我們也不需要

181
00:06:35,033 --> 00:06:36,633
weakify self，

182
00:06:36,633 --> 00:06:39,733
很好，這甚至讓我思考，是否

183
00:06:39,733 --> 00:06:42,300
這個函數應該是一個靜態函數

184
00:06:42,300 --> 00:06:43,733
在FeedItemsMapper中，因為

185
00:06:43,733 --> 00:06:44,400
它是一個映射函數，我們已經

186
00:06:44,400 --> 00:06:47,600
在FeedItemsMapper中有一個專用的位置來進行所有Feed項目的映射

187
00:06:47,600 --> 00:06:50,000
也許我們可以把它移到那

188
00:06:50,000 --> 00:06:52,133
讓我們試試

189
00:06:52,133 --> 00:06:52,933
將它設置為內部函數，所以邏輯

190
00:06:52,933 --> 00:06:54,800
依然是一樣的

191
00:06:54,800 --> 00:06:58,066
讓我們試試看

192
00:06:58,066 --> 00:07:00,400
讓它现在為內部的，所以邏輯

193
00:07:00,400 --> 00:07:01,500
還是一樣的

194
00:07:01,500 --> 00:07:05,433
我們需要檢查這個狀態碼

195
00:07:05,433 --> 00:07:07,733
所以這裡我認為我們可以返回無效

196
00:07:07,733 --> 00:07:08,633
數據嗯

197
00:07:08,633 --> 00:07:11,900
一個帶有無效數據的失敗哦

198
00:07:11,900 --> 00:07:13,666
並且它不知道什麼是 Result

199
00:07:13,666 --> 00:07:16,700
因為它需要命名空間嗯

200
00:07:16,700 --> 00:07:19,100
RemoteFeedLoader.Result 很好我

201
00:07:19,100 --> 00:07:21,266
認為我們可以移動這個邏輯

202
00:07:21,266 --> 00:07:25,833
到 do catch 塊中

203
00:07:25,833 --> 00:07:27,566
我們不再需要這個函數了

204
00:07:27,566 --> 00:07:29,566
讓我們看看

205
00:07:29,566 --> 00:07:32,066
對，它通過了但是我們有這個

206
00:07:32,066 --> 00:07:33,566
重複的失敗

207
00:07:33,566 --> 00:07:36,133
我們可以使用 guard let 簡化它

208
00:07:36,133 --> 00:07:38,400
讓我們看看

209
00:07:38,400 --> 00:07:40,866
所以響應需要為200並且我們

210
00:07:40,866 --> 00:07:41,733
需要能夠

211
00:07:41,733 --> 00:07:44,300
對 JSON 進行映射，否則它就是無效的

212
00:07:44,300 --> 00:07:45,333
數據

213
00:07:45,333 --> 00:07:47,333
所以現在我們不需要 catch 塊，我們

214
00:07:47,333 --> 00:07:49,100
不需要做塊，我們也不需要

215
00:07:49,100 --> 00:07:50,800
root

216
00:07:50,800 --> 00:07:53,900
這樣應該就可以了太棒了，我認為

217
00:07:53,900 --> 00:07:55,833
我們甚至可以將這個映射邏輯

218
00:07:55,833 --> 00:07:57,500
移至計算變數，就像我們處理

219
00:07:57,500 --> 00:07:59,900
項目的方式，所以我們可以有某種

220
00:07:59,900 --> 00:08:04,233
feed，它是一個FeedItems的陣列，並且

221
00:08:04,233 --> 00:08:06,066
我們可以只將此映射邏輯放在這裡

222
00:08:06,066 --> 00:08:09,500
因此回傳 items.map

223
00:08:09,500 --> 00:08:13,100
因此這裡只是 root.feed

224
00:08:13,100 --> 00:08:16,400
美麗的，非常好

225
00:08:16,400 --> 00:08:19,433
其他的我看不出來了

226
00:08:19,433 --> 00:08:22,466
所以讓我們把所有的

227
00:08:22,466 --> 00:08:26,700
映射邏輯都移至 FeedItems

228
00:08:26,700 --> 00:08:30,466
<apper 這就是了，這樣看起來舒服多了

229
00:08:30,466 --> 00:08:33,733
你看這樣，整潔多了

230
00:08:33,733 --> 00:08:36,133
我喜歡那裡的靜態函數，我們

231
00:08:36,133 --> 00:08:37,433
不用在區塊中捕獲自身

232
00:08:37,433 --> 00:08:39,566
在區塊裡，另一種方式我們

233
00:08:39,566 --> 00:08:42,133
可以是使用一個 weak

234
00:08:42,133 --> 00:08:46,366
在這裡的 self 和使用 guard let

235
00:08:46,366 --> 00:08:48,700
如果我們有助手方法的話例如

236
00:08:48,700 --> 00:08:50,133
然後在這裡我們可以使用 self

237
00:08:50,133 --> 00:08:52,233
並且不保持對其強引用


238
00:08:52,233 --> 00:08:54,366
對，或者我們也可以使用 unowned

239
00:08:54,366 --> 00:08:56,366
參考，這將會是隱式地

240
00:08:56,366 --> 00:08:57,733
解包裝，對吧

241
00:08:57,733 --> 00:09:01,100
但這個 guard let 與使用 static method 有很大的不同

242
00:09:01,100 --> 00:09:03,600
它看起來一樣，但實際卻不是

243
00:09:03,600 --> 00:09:05,500
這背後還有更多的原理

244
00:09:05,500 --> 00:09:08,066
而不僅僅是將 self 變為弱引用

245
00:09:08,066 --> 00:09:08,800
self

246
00:09:08,800 --> 00:09:09,900
問題在於，當我們將某物做成弱引用並返回

247
00:09:09,900 --> 00:09:12,066
這意味著，如果該實例已被釋放

248
00:09:12,066 --> 00:09:13,833
則這個區塊將不會被執行

249
00:09:13,833 --> 00:09:16,000
但如果我使用

250
00:09:16,000 --> 00:09:19,500
這裡的 static method

251
00:09:19,500 --> 00:09:22,533
即使 RemoteFeed 的實例已被釋放

252
00:09:22,533 --> 00:09:25,100
Loader

253
00:09:25,100 --> 00:09:25,600
這個區塊仍可能被調用

254
00:09:25,600 --> 00:09:28,066
我們可能仍然會調用 completion

255
00:09:28,066 --> 00:09:28,800
對，因為我們不知道客戶端的

256
00:09:28,800 --> 00:09:30,233
實作。也許它是一個

257
00:09:30,233 --> 00:09:31,733
單例（Singleton）

258
00:09:31,733 --> 00:09:33,100
並且它的生命週期比 Remote

259
00:09:33,100 --> 00:09:33,900
FeedLoader 長

260
00:09:33,900 --> 00:09:35,666
對，沒錯

261
00:09:35,666 --> 00:09:38,233
這可能是一個 bug，因為

262
00:09:38,233 --> 00:09:39,733
因為這可能是一個問題點

263
00:09:39,733 --> 00:09:42,000
這個 RemoteFeedLoader 的消費者

264
00:09:42,000 --> 00:09:43,833
可能不會預期完成區塊會在

265
00:09:43,833 --> 00:09:45,600
在實例已經被釋放後

266
00:09:45,600 --> 00:09:47,733
被調用，這種情況

267
00:09:47,733 --> 00:09:48,633
可能會有問題

268
00:09:48,633 --> 00:09:51,033
所以我們需指導這個 RemoteFeed

269
00:09:51,033 --> 00:09:51,666
Loader

270
00:09:51,666 --> 00:09:54,366
避免這種情況發生

271
00:09:54,366 --> 00:09:55,033
是的

272
00:09:55,033 --> 00:09:56,866
我們可以透過測試來改善這種情況，

273
00:09:56,866 --> 00:09:59,200
我認為這是一個好主意

274
00:09:59,200 --> 00:10:02,233
對，絕對的，那我們在這裡創建我們的測試

275
00:10:02,233 --> 00:10:02,866
這裡

276
00:10:02,866 --> 00:10:05,733
載入，那麼行為呢，好吧，它不會

277
00:10:05,733 --> 00:10:07,033
在

278
00:10:07,033 --> 00:10:10,133
此sut實例被釋放後

279
00:10:10,133 --> 00:10:13,733
傳遞結果

280
00:10:13,733 --> 00:10:16,933
因此，我們需要創建一個sut

281
00:10:16,933 --> 00:10:18,533
並且我們必須強制它的

282
00:10:18,533 --> 00:10:20,533
類型為隨選，以便我們可以通過

283
00:10:20,533 --> 00:10:23,600
將它設置為空值來釋放它

284
00:10:23,600 --> 00:10:25,033
那麼，我們需要什麼來創建一個Remote

285
00:10:25,033 --> 00:10:27,033
FeedLoader？我們需要一個URL

286
00:10:27,033 --> 00:10:29,900
我們還需要我們的客戶，讓我們這麼做

287
00:10:29,900 --> 00:10:32,233
所以客戶端是一個HTTPClientSpy

288
00:10:32,233 --> 00:10:33,200
這很簡單

289
00:10:33,200 --> 00:10:36,800
而URL就是任何URL

290
00:10:36,800 --> 00:10:40,066
太好了，這就是我們的設定

291
00:10:40,066 --> 00:10:44,300
這是我們的前提，而我們想要確認

292
00:10:44,300 --> 00:10:47,433
我們捕獲的結果，例如，是

293
00:10:47,433 --> 00:10:48,233
空的

294
00:10:48,233 --> 00:10:50,933
在某些操作後，是的，所以這個動作是

295
00:10:50,933 --> 00:10:52,633
你將sut設置為null

296
00:10:52,633 --> 00:10:54,533
首先，這意味著它將被釋放，它不會再佔用內存

297
00:10:54,533 --> 00:10:56,533
因此不再存在於內存中

298
00:10:56,533 --> 00:10:57,433
完全消失了

299
00:10:57,433 --> 00:10:59,733
我們希望我們的客戶端能夠順利完成

300
00:10:59,733 --> 00:11:00,933
任何合適的操作

301
00:11:00,933 --> 00:11:04,066
在sut消失後，我們希望

302
00:11:04,066 --> 00:11:05,600
客戶端能做些什麼

303
00:11:05,600 --> 00:11:08,066
對，它可能是一個錯誤，也可能是一個

304
00:11:08,066 --> 00:11:08,800
回應

305
00:11:08,800 --> 00:11:10,700
具有有效JSON或無效JSON的回應並不

306
00:11:10,700 --> 00:11:11,833
影響，你不應該完成錯誤，並且

307
00:11:11,833 --> 00:11:13,433
不應該完成成功

308
00:11:13,433 --> 00:11:16,133
它應該完全不完成

309
00:11:16,133 --> 00:11:17,500
的

310
00:11:17,500 --> 00:11:19,733
是的，所以我們需要捕獲結果

311
00:11:19,733 --> 00:11:22,300
而我認為我們可以從我們的

312
00:11:22,300 --> 00:11:24,933
先前的設置中複製這些，就在這裡

313
00:11:24,933 --> 00:11:26,533
很好

314
00:11:26,533 --> 00:11:28,300
那就是我們捕獲所有的

315
00:11:28,300 --> 00:11:29,833
我們預期的結果

316
00:11:29,833 --> 00:11:34,300
並沒有收到結果

317
00:11:34,300 --> 00:11:36,866
砰，失敗的測試，我們只是證明了那

318
00:11:36,866 --> 00:11:38,633
我們總是完成的，無論是否

319
00:11:38,633 --> 00:11:39,266
該實例

320
00:11:39,266 --> 00:11:41,600
已被釋放或尚未，而且我不

321
00:11:41,600 --> 00:11:42,366
喜歡這種行為

322
00:11:42,366 --> 00:11:45,500
所以我們可以修復它，這是一個非常容易的

323
00:11:45,500 --> 00:11:46,300
修復方法

324
00:11:46,300 --> 00:11:47,600
例如，我們可以只獲取self的弱

325
00:11:47,600 --> 00:11:49,900
引用，並檢查那個

326
00:11:49,900 --> 00:11:55,100
self不為nil，否則就返回

327
00:11:55,100 --> 00:11:57,333
好，問題已解決，這是一個非常

328
00:11:57,333 --> 00:11:59,666
常見的我在代碼庫中看到的錯誤

329
00:11:59,666 --> 00:12:01,833
實例被釋放了，對，但是

330
00:12:01,833 --> 00:12:03,100
出現了不預期的行為

331
00:12:03,100 --> 00:12:05,333
開始出現例如一些UIView

332
00:12:05,333 --> 00:12:07,200
Controller已被釋放，但是某些

333
00:12:07,200 --> 00:12:08,633
強引用到一個

334
00:12:08,633 --> 00:12:11,100
標籤或集合視圖是在一個

335
00:12:11,100 --> 00:12:12,366
區塊中待執行的

336
00:12:12,366 --> 00:12:14,700
在事後它變得如此難以調試

337
00:12:14,700 --> 00:12:15,600
這個

338
00:12:15,600 --> 00:12:18,533
是的，因為我認為我們被條件化

339
00:12:18,533 --> 00:12:20,066
去思考我們正在

340
00:12:20,066 --> 00:12:20,633
建立的類別

341
00:12:20,633 --> 00:12:22,133
而我們沒有去想到

342
00:12:22,133 --> 00:12:24,700
協作者可能會如何行為

343
00:12:24,700 --> 00:12:28,133
所以確實容易忽略這點

344
00:12:28,133 --> 00:12:30,800
而現在我們留下了蹤跡，我們進行了測試

345
00:12:30,800 --> 00:12:31,266
那個

346
00:12:31,266 --> 00:12:33,033
就是某種形式的文件，告知

347
00:12:33,033 --> 00:12:34,933
下一個可能會考慮

348
00:12:34,933 --> 00:12:36,866
移除那行代碼的開發者要記得

349
00:12:36,866 --> 00:12:37,333
它

350
00:12:37,333 --> 00:12:39,200
是有理由存在的，是的，我的

351
00:12:39,200 --> 00:12:40,466
最愛就是這部分

352
00:12:40,466 --> 00:12:41,600
如你所說，這就是

353
00:12:41,600 --> 00:12:43,900
自我文件化，就在那裡說明

354
00:12:43,900 --> 00:12:46,066
我們正在檢查，我們正在考慮

355
00:12:46,066 --> 00:12:48,300
這種行為，我真的很喜歡這點

356
00:12:48,300 --> 00:12:51,033
確實，如果我們希望它在實例被釋放後完成，我們

357
00:12:51,033 --> 00:12:52,866
可以添加

358
00:12:52,866 --> 00:12:53,500
反向測試，通過檢查即使

359
00:12:53,500 --> 00:12:56,000
實例已被釋放，

360
00:12:56,000 --> 00:12:57,666
雖然該實例已被撤銷

361
00:12:57,666 --> 00:13:00,133
我們得到了一個結果，所以在這種情況下我們

362
00:13:00,133 --> 00:13:01,333
不希望這種情況發生

363
00:13:01,333 --> 00:13:02,866
但是，如果你想要它發生，你可以

364
00:13:02,866 --> 00:13:04,933
也為此添加一個測試我認為這些也是

365
00:13:04,933 --> 00:13:06,000
當你處理異步代碼時的風險

366
00:13:06,000 --> 00:13:08,000
這就是其精髓

367
00:13:08,000 --> 00:13:09,433
以及時間元素基本上

368
00:13:09,433 --> 00:13:12,133
你不知道會發生什麼

369
00:13:12,133 --> 00:13:13,433
你不能控制它

370
00:13:13,433 --> 00:13:14,633
所以你需要思考所有這些

371
00:13:14,633 --> 00:13:17,500
邊緣案例

372
00:13:17,500 --> 00:13:18,700
並且你需要防止它們發生，我已經處理過

373
00:13:18,700 --> 00:13:20,866
這個Bug很多次了

374
00:13:20,866 --> 00:13:22,533
我已經吸取了教訓，沒錯，所以

375
00:13:22,533 --> 00:13:25,600
讓我們提交吧

376
00:13:25,600 --> 00:13:26,533
沒錯，我們保證絕對會

377
00:13:26,533 --> 00:13:29,900
這樣做

378
00:13:29,900 --> 00:13:33,033
不提供結果

379
00:13:33,033 --> 00:13:36,866
或者在遠程

380
00:13:36,866 --> 00:13:40,300
FeedLoader實例被撤銷後調用完成

381
00:13:40,300 --> 00:13:44,300
非常好,再來我看到的最後一件事情是

382
00:13:44,300 --> 00:13:48,066
美麗的事情，我看到的最後一個事情是

383
00:13:48,066 --> 00:13:48,866
事實上

384
00:13:48,866 --> 00:13:51,733
RemoteFeedLoaderTests在

385
00:13:51,733 --> 00:13:53,333
EssentialFeedTests資料夾中獨自存在

386
00:13:53,333 --> 00:13:56,466
我認為我們可以將它封裝在一個Feed

387
00:13:56,466 --> 00:13:57,100
API

388
00:13:57,100 --> 00:13:59,100
的資料夾內，如此可以與生產環境相對應

389
00:13:59,100 --> 00:14:00,866
部分

390
00:14:00,866 --> 00:14:04,800
好的，Feed API，好眼力

391
00:14:04,800 --> 00:14:07,900
讓我們運行測試好了

392
00:14:07,900 --> 00:14:12,933
讓我們提交並將測試文件移到一個群組

393
00:14:12,933 --> 00:14:16,300
來標示其模塊權限，對吧

394
00:14:16,300 --> 00:14:19,733
並且這是Feed API，這讓我

395
00:14:19,733 --> 00:14:21,266
也思考

396
00:14:21,266 --> 00:14:24,133
如果你看到的文件數量差異

397
00:14:24,133 --> 00:14:25,333
生產部分

398
00:14:25,333 --> 00:14:27,500
在Feed API中我們有三個文件，但是

399
00:14:27,500 --> 00:14:28,466
只有一個文件

400
00:14:28,466 --> 00:14:31,266
在Feed API資料夾的測試部分

401
00:14:31,266 --> 00:14:32,233
對，而這是

402
00:14:32,233 --> 00:14:34,700
很常見的事實上，檔案數量並非一對一

403
00:14:34,700 --> 00:14:35,666
但如果我們檢查覆蓋率，我相當

404
00:14:35,666 --> 00:14:37,266
確定它接近100%

405
00:14:37,266 --> 00:14:39,166
或是100%，對，因為不需要

406
00:14:39,166 --> 00:14:41,833
一對一地進行測試

408
00:14:43,666 --> 00:14:45,033
例如，我們正在測試 Feed

409
00:14:45,033 --> 00:14:47,333
ItemsMapper 在整合中

410
00:14:47,333 --> 00:14:49,433
如我們在上一集提到的

411
00:14:49,433 --> 00:14:50,366
所以我相當滿意

412
00:14:50,366 --> 00:14:53,266
對於目前的結果不僅如此，我們

413
00:14:53,266 --> 00:14:54,366
應該說

414
00:14:54,366 --> 00:14:57,500
我們從一對一的比例開始的，對吧

415
00:14:57,500 --> 00:15:00,533
我們只有 RemoteFeedLoader 檔案

416
00:15:00,533 --> 00:15:03,166
和 RemoteFeedLoaderTests 檔案，但

417
00:15:03,166 --> 00:15:04,533
當我們遵循流程

418
00:15:04,533 --> 00:15:07,733
並開始重構，我們最後

419
00:15:07,733 --> 00:15:10,133
得到了這三個檔案

420
00:15:10,133 --> 00:15:12,133
我認為這是好的實踐

421
00:15:12,133 --> 00:15:14,233
這是我們開始時需要的

422
00:15:14,233 --> 00:15:16,066
這是我們現在需要的

423
00:15:16,066 --> 00:15:18,866
因此，項目總是變化的，而且

424
00:15:18,866 --> 00:15:20,866
它會改變以滿足我們的需求，對吧

425
00:15:20,866 --> 00:15:22,633
我們希望它改變，我們希望它具有

426
00:15:22,633 --> 00:15:24,066
靈活性，是的

427
00:15:24,066 --> 00:15:26,533
美好，好的，讓我們看看

428
00:15:26,533 --> 00:15:28,000
更新後的圖表

429
00:15:28,000 --> 00:15:30,466
我們現在已完成 RemoteFeed

430
00:15:30,466 --> 00:15:31,033
Loader 的部分


431
00:15:31,033 --> 00:15:33,266
我們現在只需要實現

432
00:15:33,266 --> 00:15:34,466
這裡的介面

433
00:15:34,466 --> 00:15:36,233
對，並且由於我們現在在這個組件中有多於

434
00:15:36,233 --> 00:15:38,366
一種類型

435
00:15:38,366 --> 00:15:40,466
我認為我們甚至可以叫它Feed API 從

436
00:15:40,466 --> 00:15:41,600
現在開始，是的

437
00:15:41,600 --> 00:15:43,733
確實，而且FeedLoader 可以是

438
00:15:43,733 --> 00:15:45,133
Feed Feature

439
00:15:45,133 --> 00:15:48,800
模組，對吧，你怎麼看

440
00:15:48,800 --> 00:15:52,000
這是模組化視圖，對

441
00:15:52,000 --> 00:15:54,066
我們稍後可以有一個更細緻的視圖

442
00:15:54,066 --> 00:15:55,733
通過增加所有的類型

443
00:15:55,733 --> 00:15:58,066
絕對的，好吧，所以下一集我們將

444
00:15:58,066 --> 00:15:59,600
實現Feed

445
00:15:59,600 --> 00:16:02,233
Loader 協議，非常好，我們下次見

446
00:16:02,233 --> 00:16:03,100
期待下次見到你

447
00:16:03,100 --> 00:16:14,633
大家再見