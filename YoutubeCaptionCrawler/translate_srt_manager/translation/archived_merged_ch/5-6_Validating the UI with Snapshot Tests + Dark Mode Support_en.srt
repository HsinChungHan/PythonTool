

1
00:00:01,033 --> 00:00:03,833
你好 Mike，嘿 Caio

2
00:00:03,833 --> 00:00:05,900
在上一堂課我們驗證了

3
00:00:05,900 --> 00:00:07,200
接受標準

4
00:00:07,200 --> 00:00:09,666
通過集成測試，而在這

5
00:00:09,666 --> 00:00:10,933
一講我們將向你展示

6
00:00:10,933 --> 00:00:11,900
怎樣能驗證

7
00:00:11,900 --> 00:00:15,033
你的用戶界面與快照

8
00:00:15,033 --> 00:00:18,533
測試好，所以在EssentialFeed

9
00:00:18,533 --> 00:00:21,666
的iOS模塊中，我們創建一個新的

10
00:00:21,666 --> 00:00:27,666
測試檔案 FeedSnapshotTests

11
00:00:27,666 --> 00:00:29,900
快照測試的想法是

12
00:00:29,900 --> 00:00:31,166
我們將去渲染

13
00:00:31,166 --> 00:00:34,066
用戶界面並取一個快照

14
00:00:34,066 --> 00:00:35,200
確實

15
00:00:35,200 --> 00:00:38,300
首先最簡單的視圖是

16
00:00:38,300 --> 00:00:39,033
空的

17
00:00:39,033 --> 00:00:41,733
信息源對吧，所以我們將實例化

18
00:00:41,733 --> 00:00:43,200
一個FeedViewController

19
00:00:43,200 --> 00:00:45,033
這將會是系統的

20
00:00:45,033 --> 00:00:47,200
測試項，我們將對它取一個快照

21
00:00:47,200 --> 00:00:52,133
在渲染一個空的信息源之後

22
00:00:52,133 --> 00:00:54,300
就是這樣，所以我們需要創建我們的

23
00:00:54,300 --> 00:00:55,433
測試系統

24
00:00:55,433 --> 00:00:58,300
像往常一樣運用makeSUT函數

25
00:00:58,300 --> 00:00:59,833
這非常簡單

26
00:00:59,833 --> 00:01:01,333
我們只需要實例化

27
00:01:01,333 --> 00:01:04,766
故事板中的 FeedViewController

28
00:01:04,766 --> 00:01:07,266
並載入視圖使其準備好

29
00:01:07,266 --> 00:01:08,133
進行渲染

30
00:01:08,133 --> 00:01:10,066
並且 FeedViewController 存在於

31
00:01:10,066 --> 00:01:12,300
EssentialFeediOS模塊中

32
00:01:12,300 --> 00:01:15,500
所以我們需要導入它，好的

33
00:01:15,500 --> 00:01:18,766
並且 display 方法需要一個數組

34
00:01:18,766 --> 00:01:23,600
FeedImageCellControllers 的數組

35
00:01:23,600 --> 00:01:27,600
所以一個空的 feed 將會簡單地是

36
00:01:27,600 --> 00:01:29,833
FeedImageCell 的空數組

37
00:01:29,833 --> 00:01:31,100
Controllers

38
00:01:31,100 --> 00:01:34,466
對，就是這樣，測試讀取非常好

39
00:01:34,466 --> 00:01:36,466
好的，現在我們需要拍攝一個快照

40
00:01:36,466 --> 00:01:37,733
視圖控制器的快照

41
00:01:37,733 --> 00:01:39,666
為了這樣做，我們可以引入一個

42
00:01:39,666 --> 00:01:42,133
在 UIViewController 上的擴展

43
00:01:42,133 --> 00:01:45,333
具有一個返回的 snapshot 方法

44
00:01:45,333 --> 00:01:48,700
一個 UIImage。 所以，我們的想法是將

45
00:01:48,700 --> 00:01:50,766
視圖控制器的視圖渲染並拍下

46
00:01:50,766 --> 00:01:52,866
該視圖的快照

47
00:01:52,866 --> 00:01:55,833
就是這樣，我們用一個

48
00:01:55,833 --> 00:01:56,866
renderer 來渲染

49
00:01:56,866 --> 00:02:00,300
那就是 UIGraphicsImageRenderer

50
00:02:00,300 --> 00:02:03,500
所以界限就是視圖範疇

51
00:02:03,500 --> 00:02:05,666
就因為我們想要整個視圖

52
00:02:05,666 --> 00:02:06,866
這裡

53
00:02:06,866 --> 00:02:10,466
然後我們返回渲染器圖像

54
00:02:10,466 --> 00:02:13,733
透過渲染視圖

55
00:02:13,733 --> 00:02:17,100
在操作上下文中

56
00:02:17,100 --> 00:02:18,866
好的，這就是全部，這就是我們如何

57
00:02:18,866 --> 00:02:22,000
拍攝視圖的快照

58
00:02:22,000 --> 00:02:24,933
所以讓我們看看快照是否工作

59
00:02:24,933 --> 00:02:26,800
讓我們捕獲快照

60
00:02:26,800 --> 00:02:29,333
讓我們在這裡添加一個斷點，讓我們運行

61
00:02:29,333 --> 00:02:30,466
測試

62
00:02:30,466 --> 00:02:32,533
然後讓我們調查

63
00:02:32,533 --> 00:02:34,300
快照的價值

64
00:02:34,300 --> 00:02:38,066
看，是個空白螢幕，好的

65
00:02:38,066 --> 00:02:40,400
可能並不重要，但那正是我們需要的

66
00:02:40,400 --> 00:02:41,833
就是這樣

67
00:02:41,833 --> 00:02:44,133
當餵入的資訊是空的，我們看到

68
00:02:44,133 --> 00:02:45,566
一個空白的螢幕

69
00:02:45,566 --> 00:02:48,300
就是這樣，好的，所以快照是

70
00:02:48,300 --> 00:02:49,100
在運作

71
00:02:49,100 --> 00:02:51,266
但是快照測試的理念是

72
00:02:51,266 --> 00:02:52,700
我們拍一個快照

73
00:02:52,700 --> 00:02:56,000
我們將快照存儲到文件系統

74
00:02:56,000 --> 00:02:59,100
然後我們可以比較新的快照

75
00:02:59,100 --> 00:03:02,300
到之前儲存的快照

76
00:03:02,300 --> 00:03:05,200
所以現在我們需要記錄那個快照

77
00:03:05,200 --> 00:03:05,500
或者

78
00:03:05,500 --> 00:03:08,300
將其儲存在File system裡並且我們可以

79
00:03:08,300 --> 00:03:09,433
建立一個新的函式

80
00:03:09,433 --> 00:03:12,933
叫做 recordSnapshot

81
00:03:12,933 --> 00:03:16,133
並且我們可以給它一個獨特的名稱以便

82
00:03:16,133 --> 00:03:20,866
不與其他快照產生衝突

83
00:03:20,866 --> 00:03:23,500
好，這裡是 record 函式

84
00:03:23,500 --> 00:03:24,866
拍攝一個快照

85
00:03:24,866 --> 00:03:28,133
那是一個UIImage和一個名字所以首先

86
00:03:28,133 --> 00:03:30,300
我們需要做的就是轉換

87
00:03:30,300 --> 00:03:33,266
我們的UIImage快照成為我們可以

88
00:03:33,266 --> 00:03:35,266
儲存在硬盤上的數據

89
00:03:35,266 --> 00:03:38,000
並且我們可以使用 PNG 表示法如果

90
00:03:38,000 --> 00:03:39,433
你失敗地創建它

91
00:03:39,433 --> 00:03:41,900
我們充滿斷言失敗和一個

92
00:03:41,900 --> 00:03:43,266
友好的訊息 

93
00:03:43,266 --> 00:03:46,633
啊接下來我們需要一個路徑來存儲它

94
00:03:46,633 --> 00:03:48,700
我們可以使用檔案路徑來建立

95
00:03:48,700 --> 00:03:49,733
URL

96
00:03:49,733 --> 00:03:52,700
因為檔案參數保持指向

97
00:03:52,700 --> 00:03:54,133
當前檔案的路徑

98
00:03:54,133 --> 00:03:56,233
準確來說我們應該存儲

99
00:03:56,233 --> 00:03:57,266
這些快照

100
00:03:57,266 --> 00:03:59,833
接近測試文件，這樣我們就可以使用

101
00:03:59,833 --> 00:04:01,333
當前的文件路徑

102
00:04:01,333 --> 00:04:04,866
該路徑為FeedSnapshotTests 文件

103
00:04:04,866 --> 00:04:08,133
作為我們快照的基礎路徑

104
00:04:08,133 --> 00:04:10,633
確切地說，並將其存儲在相同的

105
00:04:10,633 --> 00:04:12,400
目錄中作為測試文件

106
00:04:12,400 --> 00:04:14,533
這意味著我們也可以將其添加到 git 

107
00:04:14,533 --> 00:04:15,900
中

108
00:04:15,900 --> 00:04:18,866
確實，這些快照應該被儲存

109
00:04:18,866 --> 00:04:19,500
並推送

110
00:04:19,500 --> 00:04:22,133
到 git， 以便其他人可以驗證他們的

111
00:04:22,133 --> 00:04:23,100
更改

112
00:04:23,100 --> 00:04:26,066
根據存儲的快照，所以這就是

113
00:04:26,066 --> 00:04:26,633
它

114
00:04:26,633 --> 00:04:28,800
讓我們為快照創建一個 URL，使用的是

115
00:04:28,800 --> 00:04:31,166
當前的文件路徑

116
00:04:31,166 --> 00:04:33,666
它將看起來像這樣，即

117
00:04:33,666 --> 00:04:35,500
存放測試文件的文件夾

118
00:04:35,500 --> 00:04:38,633
是EssentialFeediOSTests，和

119
00:04:38,633 --> 00:04:42,233
文件名稱

120
00:04:42,233 --> 00:04:45,100
所以我們可以刪除最後的路徑組件

121
00:04:45,100 --> 00:04:46,233
這將給我們

122
00:04:46,233 --> 00:04:49,333
文件所在的文件夾，即

123
00:04:49,333 --> 00:04:53,166
EssentialFeediOSTests 文件夾

124
00:04:53,166 --> 00:04:55,666
我們可以追加一個路徑組件以


125
00:04:55,666 --> 00:04:56,933
創建一個新的資料夾結構

126
00:04:56,933 --> 00:05:00,000
至於快照，就是這樣，最後

127
00:05:00,000 --> 00:05:03,100
我們可以添加檔案的名稱

128
00:05:03,100 --> 00:05:06,133
在這個例子中，檔案是空的feed，所以我們

129
00:05:06,133 --> 00:05:06,866
會得到

130
00:05:06,866 --> 00:05:09,166
如此這般的檔案路徑，基礎的

131
00:05:09,166 --> 00:05:10,066
資料夾，

132
00:05:10,066 --> 00:05:11,900
加上快照資料夾和檔案

133
00:05:11,900 --> 00:05:14,066
名稱，對的

134
00:05:14,066 --> 00:05:17,600
好的，現在我們有了要儲存的資料到

135
00:05:17,600 --> 00:05:18,133
磁碟

136
00:05:18,133 --> 00:05:20,800
以及我們希望儲存的網址，所以

137
00:05:20,800 --> 00:05:21,166
接下來

138
00:05:21,166 --> 00:05:23,100
我們要確保這個資料夾

139
00:05:23,100 --> 00:05:24,866
結構存在

140
00:05:24,866 --> 00:05:26,800
在檔案系統中，所以我們可以使用

141
00:05:26,800 --> 00:05:28,800
FileManager創建資料夾

142
00:05:28,800 --> 00:05:31,433
如果需要的話，如果創建失敗

143
00:05:31,433 --> 00:05:33,100
再次，我們得到一個很棒的

144
00:05:33,100 --> 00:05:36,633
斷言失敗與錯誤

145
00:05:36,633 --> 00:05:41,433
最後，我們可以儲存我們的快照資料

146
00:05:41,433 --> 00:05:44,800
我們來執行測試好了

147
00:05:44,800 --> 00:05:47,166
它通過了，這意味著它應該

148
00:05:47,166 --> 00:05:48,400
已經儲存到磁碟上

149
00:05:48,400 --> 00:05:51,733
那麼，讓我們來看看，好的，它創建了

150
00:05:51,733 --> 00:05:53,100
目錄

151
00:05:53,100 --> 00:05:55,733
並儲存了圖片，看看這個

152
00:05:55,733 --> 00:05:56,866
真棒

153
00:05:56,866 --> 00:06:00,633
EMPTY_FEED.png，太好了

154
00:06:00,633 --> 00:06:03,833
那麼，讓我們提交，好的

155
00:06:03,833 --> 00:06:06,466
如你在git diff中看到的，我們現在

156
00:06:06,466 --> 00:06:07,033
擁有了

157
00:06:07,033 --> 00:06:09,833
空的 feed 圖片，因此我們的同儕也能

158
00:06:09,833 --> 00:06:11,100
用它來比較

159
00:06:11,100 --> 00:06:14,933
對他們響應的變化，所以記錄空的feed

160
00:06:14,933 --> 00:06:18,233
截圖提交

161
00:06:18,233 --> 00:06:21,500
現在進行下一個測試

162
00:06:21,500 --> 00:06:24,933
帶有內容的feed，現在的空feed 

163
00:06:24,933 --> 00:06:29,100
太簡單了，我們需要創建

164
00:06:29,100 --> 00:06:32,000
FeedImageCellControllers並填充

165
00:06:32,000 --> 00:06:32,933
它

166
00:06:32,933 --> 00:06:36,300
用一個圖片，所以將

167
00:06:36,300 --> 00:06:38,866
FeedImageCellController的請求圖片 

168
00:06:38,866 --> 00:06:39,666
圖片

169
00:06:39,666 --> 00:06:42,933
從其委託人處獲得，這個應該會

170
00:06:42,933 --> 00:06:45,266
在完成請求時調用顯示視圖模型 

171
00:06:45,266 --> 00:06:46,400
完成請求

172
00:06:46,400 --> 00:06:49,833
圖片，因此我們需要創建

173
00:06:49,833 --> 00:06:52,466
一些我們可以在測試中使用的圖像存根

174
00:06:52,466 --> 00:06:53,666
測試

175
00:06:53,666 --> 00:06:55,166
我們可以簡單地將東西渲染在

176
00:06:55,166 --> 00:06:57,166
屏幕上而無需任何其他的

177
00:06:57,166 --> 00:07:01,433
依賴性，好，我喜歡。

178
00:07:01,433 --> 00:07:04,633
所以讓我們創建一個名為ImageStub的類別，

179
00:07:04,633 --> 00:07:06,066
實現

180
00:07:06,066 --> 00:07:09,100
ImageCellControllerDelegate

181
00:07:09,100 --> 00:07:11,666
它有兩個方法，did request image

182
00:07:11,666 --> 00:07:14,066
和 did cancel image request

183
00:07:14,066 --> 00:07:16,300
當控制器請求圖像時，

184
00:07:16,300 --> 00:07:18,400
我們需要告訴控制器顯示

185
00:07:18,400 --> 00:07:19,100
一個替代的視圖模型，因此我們需要一個

186
00:07:19,100 --> 00:07:22,133
引用

187
00:07:22,133 --> 00:07:22,800
到控制器，但由於控制器

188
00:07:22,800 --> 00:07:25,666
對代理有強引用，

189
00:07:25,666 --> 00:07:27,666
所以我們需要使ImageStub對控制器的引用

190
00:07:27,666 --> 00:07:29,900
為弱引用，以避免任何循環引用。

191
00:07:29,900 --> 00:07:31,033
到控制器的，

192
00:07:31,033 --> 00:07:35,500
避免任何循環引用。

193
00:07:35,500 --> 00:07:38,700
好，完成了。

194
00:07:38,700 --> 00:07:42,066
我們需要一個視圖模型，是的，

195
00:07:42,066 --> 00:07:48,066
這是一個FeedImageViewModel，

196
00:07:48,066 --> 00:07:49,733
我們需要一個初始化器，

197
00:07:49,733 --> 00:07:51,666
可以為我們簡化工作。

198
00:07:51,666 --> 00:07:55,033
我們傳入description, location 和 UIImage，

199
00:07:55,033 --> 00:07:55,666
這將為我們創建視圖模型，

200
00:07:55,666 --> 00:07:57,500
為我們。

201
00:07:57,500 --> 00:07:58,800
所以我們現在只需要導入

202
00:07:58,800 --> 00:08:01,033
EssentialFeed模組，

203
00:08:01,033 --> 00:08:02,533
就可以了。

204
00:08:02,533 --> 00:08:06,000
那裡是 FeedImageViewModel 的所在地

205
00:08:06,000 --> 00:08:08,933
無論如何 FeedImageViewModel 

206
00:08:08,933 --> 00:08:12,633
沒有公開的初始化器

207
00:08:12,633 --> 00:08:15,566
因此我們要麼增加一個公開的初始化器，要麼

208
00:08:15,566 --> 00:08:16,466
我們進口

209
00:08:16,466 --> 00:08:19,666
模塊作為可測試的，所以我們可以創建

210
00:08:19,666 --> 00:08:22,300
視圖模型結構，並添加它為

211
00:08:22,300 --> 00:08:23,100
@testable

212
00:08:23,100 --> 00:08:26,466
現在這樣就可以了，最後我們需要去

213
00:08:26,466 --> 00:08:28,133
創建具有內容的 feed 

214
00:08:28,133 --> 00:08:31,900
助手，該助手就應

215
00:08:31,900 --> 00:08:35,833
創建一個 ImageStubs 的陣列

216
00:08:35,833 --> 00:08:37,900
所以它有一些長的描述，有一些

217
00:08:37,900 --> 00:08:38,866
多行的

218
00:08:38,866 --> 00:08:42,066
位置串，並有

219
00:08:42,066 --> 00:08:44,466
一個圖像，我們可以用助手來

220
00:08:44,466 --> 00:08:46,633
僅根據顏色製作一個圖像

221
00:08:46,633 --> 00:08:53,433
讓我從其他模塊中加上去

222
00:08:53,433 --> 00:08:57,900
如有需要，確保複製該項目

223
00:08:57,900 --> 00:09:01,266
就這樣

224
00:09:01,266 --> 00:09:03,266
現在我們只需要將 Image 

225
00:09:03,266 --> 00:09:04,766
Stubs 轉換成

226
00:09:04,766 --> 00:09:08,300
ImageCellControllers，所以我們將要

227
00:09:08,300 --> 00:09:08,700
映射

228
00:09:08,700 --> 00:09:12,233
這些 stubs，並為每個 stub 創建一個 cell controller

229
00:09:12,233 --> 00:09:16,233
就針對每一個 stub


230
00:09:16,233 --> 00:09:20,833
並設置 stub controller 為 cell 的

231
00:09:20,833 --> 00:09:23,500
controller

232
00:09:23,500 --> 00:09:26,633
最後，我們呼叫 display cells 即可

233
00:09:26,633 --> 00:09:28,300
就完成了

234
00:09:28,300 --> 00:09:32,133
好，讓我們運行測試吧

235
00:09:32,133 --> 00:09:35,200
看，這就是空的 feed 和

236
00:09:35,200 --> 00:09:37,900
含內容的 feed 不運行這個

237
00:09:37,900 --> 00:09:38,933
應用

238
00:09:38,933 --> 00:09:42,633
太棒了，讓我們提交吧

239
00:09:42,633 --> 00:09:45,733
如你所見，圖片也被

240
00:09:45,733 --> 00:09:49,500
加入到 git 歷史中了

241
00:09:49,500 --> 00:09:54,533
所以記錄含內容的 feed 快照

242
00:09:54,533 --> 00:09:57,900
接下來讓我們渲染

243
00:09:57,900 --> 00:10:02,466
一個帶有錯誤訊息的 feed

244
00:10:02,466 --> 00:10:06,366
讓我們運行測試

245
00:10:06,366 --> 00:10:09,333
好，錯誤訊息出現了，我們

246
00:10:09,333 --> 00:10:11,666
甚至可以測試它是否支援多行

247
00:10:11,666 --> 00:10:15,266
確切的說，測試多行的 label 是個好主意

248
00:10:15,266 --> 00:10:17,900
特別是有些翻譯

249
00:10:17,900 --> 00:10:19,500
可能會比其他的

250
00:10:19,500 --> 00:10:20,133
長

251
00:10:20,133 --> 00:10:23,833
確實如此，所以這就是一個

252
00:10:23,833 --> 00:10:24,533
多行的

253
00:10:24,533 --> 00:10:27,900
錯誤訊息，讓我們再記錄一個快照吧

254
00:10:27,900 --> 00:10:29,033
再次

255
00:10:29,033 --> 00:10:32,233
讓我們看看，啊哈，看那個

256
00:10:32,233 --> 00:10:34,866
它正在剪切錯誤訊息，而我們

257
00:10:34,866 --> 00:10:36,133
並不希望這樣

258
00:10:36,133 --> 00:10:39,433
不，我們不希望，這就是

259
00:10:39,433 --> 00:10:42,000
截圖測試的一個好處，其他測試都沒發現

260
00:10:42,000 --> 00:10:43,500
這個問題

261
00:10:43,500 --> 00:10:46,366
對，這些問題你不可能輕易以

262
00:10:46,366 --> 00:10:46,933
單元

263
00:10:46,933 --> 00:10:49,833
或集成測試來進行，因為他們並不是

264
00:10:49,833 --> 00:10:50,300
被設計來

265
00:10:50,300 --> 00:10:53,833
執行視覺化螢幕上精確測試的

266
00:10:53,833 --> 00:10:57,100
讓我們修正這個問題，Feed

267
00:10:57,100 --> 00:11:00,633
storyboard，讓我們選擇錯誤標籤

268
00:11:00,633 --> 00:11:03,433
確保它支援多行，果然支援

269
00:11:03,433 --> 00:11:04,233
沒錯

270
00:11:04,233 --> 00:11:08,133
它沒有行數限制

271
00:11:08,133 --> 00:11:11,266
但視圖就是表格

272
00:11:11,266 --> 00:11:14,300
標題視圖和表頭

273
00:11:14,300 --> 00:11:17,500
在自動布局中無法良好運作

274
00:11:17,500 --> 00:11:21,100
對，所以我們需要手動調整這個標題視圖的大小

275
00:11:21,100 --> 00:11:23,666
沒關係，我們在這裡建立一個

276
00:11:23,666 --> 00:11:26,066
助手

277
00:11:26,066 --> 00:11:29,833
UITableView+Header

278
00:11:29,833 --> 00:11:33,033
Sizing，所以我們需要檢查

279
00:11:33,033 --> 00:11:35,333
有沒有框架改變，這樣我們就能

280
00:11:35,333 --> 00:11:36,866
更新表頭

281
00:11:36,866 --> 00:11:39,266
讓我們手動更新 FeedView

282
00:11:39,266 --> 00:11:40,633
Controller 現在

283
00:11:40,633 --> 00:11:43,733
所以每次當 viewDidLayoutSubviews 被

284
00:11:43,733 --> 00:11:44,366
調用

285
00:11:44,366 --> 00:11:46,800
我們需要重新調整表頭部分的大小

286
00:11:46,800 --> 00:11:48,066
手動地

287
00:11:48,066 --> 00:11:51,900
再次運行測試，出現了

288
00:11:51,900 --> 00:11:55,500
好的，完美，讓我們來提交這個

289
00:11:55,500 --> 00:12:00,000
分部分地，首先讓我們提交修復

290
00:12:00,000 --> 00:12:02,866
修復多行標籤的表頭重新調整

291
00:12:02,866 --> 00:12:04,466
標籤

292
00:12:04,466 --> 00:12:07,433
然後讓我們來提交快照

293
00:12:07,433 --> 00:12:08,133
記錄

294
00:12:08,133 --> 00:12:11,500
feed 與錯誤訊息的快照

295
00:12:11,500 --> 00:12:16,000
好的，回到測試

296
00:12:16,000 --> 00:12:19,033
下一個測試，讓我們來渲染

297
00:12:19,033 --> 00:12:22,133
一個載入圖像失敗的 feed ，所以它

298
00:12:22,133 --> 00:12:24,700
應該顯示重試按鈕

299
00:12:24,700 --> 00:12:27,666
再次，讓 makeSUT 顯示載入圖像失敗的 feed 

300
00:12:27,666 --> 00:12:29,033
失敗圖像載入的 feed 

301
00:12:29,033 --> 00:12:32,233
並記錄一個快照

302
00:12:32,233 --> 00:12:35,333
讓我們現在創建一個工廠方法 

303
00:12:35,333 --> 00:12:38,233
對於載入失敗的 feed 

304
00:12:38,233 --> 00:12:41,333
任何無圖像的圖像存根都應該可以

305
00:12:41,333 --> 00:12:46,633
好的，運行測試

306
00:12:46,633 --> 00:12:50,300
好的，砰！有了

307
00:12:50,300 --> 00:12:53,833
就是這樣，太棒了


308
00:12:53,833 --> 00:12:57,266
讓我們提交記錄feed

309
00:12:57,266 --> 00:13:00,933
與失敗的圖像加載快照

310
00:13:00,933 --> 00:13:04,633
好的，錄製部分完成了

311
00:13:04,633 --> 00:13:07,200
現在是第二部分，確定那個

312
00:13:07,200 --> 00:13:08,700
錄製的快照

313
00:13:08,700 --> 00:13:12,466
與新的快照相匹配，好的

314
00:13:12,466 --> 00:13:14,300
因為僅僅錄製快照會

315
00:13:14,300 --> 00:13:15,500
直接覆蓋

316
00:13:15,500 --> 00:13:19,200
現有的快照，我們錄製它後

317
00:13:19,200 --> 00:13:21,200
我們對結果感到滿意我們需要

318
00:13:21,200 --> 00:13:22,300
去確定

319
00:13:22,300 --> 00:13:24,700
渲染與存儲的

320
00:13:24,700 --> 00:13:26,366
快照相匹配

321
00:13:26,366 --> 00:13:36,866
所以我們需要一個確定函數

322
00:13:36,866 --> 00:13:39,033
確定函數會開始

323
00:13:39,033 --> 00:13:41,833
同樣，我們需要獲得快照數據

324
00:13:41,833 --> 00:13:44,466
以及快照URL，但現在不是

325
00:13:44,466 --> 00:13:45,033
存儲

326
00:13:45,033 --> 00:13:47,166
並覆蓋當前的快照我們

327
00:13:47,166 --> 00:13:48,633
將要載入

328
00:13:48,633 --> 00:13:52,133
存儲的快照，如果它失敗

329
00:13:52,133 --> 00:13:54,366
我們將用一個斷言和一個

330
00:13:54,366 --> 00:13:55,666
友好的訊息失敗

331
00:13:55,666 --> 00:13:57,266
讓我們知道我們需要錄製

332
00:13:57,266 --> 00:13:59,333
在我們確定之前先

333
00:13:59,333 --> 00:14:00,933
噢，這很有幫助，我真的很喜歡

334
00:14:00,933 --> 00:14:02,466
然後就是這樣

335
00:14:02,466 --> 00:14:05,033
我們需要比較新的 snapshot

336
00:14:05,033 --> 00:14:05,733
數據

337
00:14:05,733 --> 00:14:08,933
是否與存儲的一致

338
00:14:08,933 --> 00:14:12,133
如果它們不一致，我們就有問題了，對吧

339
00:14:12,133 --> 00:14:14,933
為了幫助你debug這個問題，我們

340
00:14:14,933 --> 00:14:15,733
可以建立

341
00:14:15,733 --> 00:14:19,100
一個臨時URL，你可以在那裡寫入

342
00:14:19,100 --> 00:14:21,433
新的snapshot數據，所以我們可以比較

343
00:14:21,433 --> 00:14:23,266
對照另一個來視覺化比較

344
00:14:23,266 --> 00:14:26,000
對吧，最後以一個

345
00:14:26,000 --> 00:14:27,266
斷言失敗結束

346
00:14:27,266 --> 00:14:29,900
說新的snapshot與

347
00:14:29,900 --> 00:14:30,466
已存儲的

348
00:14:30,466 --> 00:14:33,900
snapshot不符，並附帶URL以供驗證二者的差異

349
00:14:33,900 --> 00:14:38,700
讓我們來運行測試

350
00:14:38,700 --> 00:14:42,000
好的，它順利通過，這意味著新的

351
00:14:42,000 --> 00:14:43,033
snapshots

352
00:14:43,033 --> 00:14:46,000
與存儲的完全相同

353
00:14:46,000 --> 00:14:48,233
但讓我們證明如果我們更動數據，它將會失敗

354
00:14:48,233 --> 00:14:51,333
如果我們改變這個

355
00:14:51,333 --> 00:14:54,533
和它做對比，看看結果

356
00:14:54,533 --> 00:14:54,866
您

357
00:14:54,866 --> 00:14:57,500
將得到一個URL，您可以在那裡調查

358
00:14:57,500 --> 00:14:58,633
哪裡出錯了

359
00:14:58,633 --> 00:15:02,000
讓我們來看看，看看那個

360
00:15:02,000 --> 00:15:05,433
錯誤訊息是新的 snapshot


361
00:15:05,433 --> 00:15:07,266
而儲存的當然是

362
00:15:07,266 --> 00:15:08,700
不同的

363
00:15:08,700 --> 00:15:10,366
所以這個測試告訴我們

364
00:15:10,366 --> 00:15:12,233
有些東西出錯了

365
00:15:12,233 --> 00:15:15,100
現在如果你覺得新的一切正常，你可以

366
00:15:15,100 --> 00:15:15,833
只是

367
00:15:15,833 --> 00:15:18,533
把它準確地記錄下來，如果不對，你就需要

368
00:15:18,533 --> 00:15:20,866
修正問題

369
00:15:20,866 --> 00:15:22,466
但在這種情況下我們將保留它

370
00:15:22,466 --> 00:15:24,233
作為一個多行標籤

371
00:15:24,233 --> 00:15:25,500
那麼我們再次運行這個測試，它應該

372
00:15:25,500 --> 00:15:28,000
能夠通過，因為這個assert函數

373
00:15:28,000 --> 00:15:31,733
不會覆蓋儲存的快照

374
00:15:31,733 --> 00:15:35,433
它只是確實地與之比較

375
00:15:35,433 --> 00:15:38,800
我們可以通過提取

376
00:15:38,800 --> 00:15:40,533
重構record和assert方法

377
00:15:40,533 --> 00:15:43,266
其中的一部分重複的，這個重複的

378
00:15:43,266 --> 00:15:43,733
代碼

379
00:15:43,733 --> 00:15:47,166
可以進入助手函數 makeSnapshotURL

380
00:15:47,166 --> 00:15:50,800
和 makeSnapshotData

381
00:15:50,800 --> 00:15:56,933
好，現在看起來好多了

382
00:15:56,933 --> 00:16:00,800
就這樣，再次運行測試

383
00:16:00,800 --> 00:16:03,733
通過了，讓我們再看看我們的圖片

384
00:16:03,733 --> 00:16:04,466
再看一次

385
00:16:04,466 --> 00:16:07,900
空的feed，帶有內容的feed，帶有

386
00:16:07,900 --> 00:16:09,166
錯誤訊息的feed

387
00:16:09,166 --> 00:16:12,233
並且在圖片載入失敗的狀況下，你

388
00:16:12,233 --> 00:16:13,833
可以繼續渲染這個視圖

389
00:16:13,833 --> 00:16:17,100
使用我們想要的任何數據，而無需

390
00:16:17,100 --> 00:16:17,600
模擬

391
00:16:17,600 --> 00:16:20,800
任何網路連接或我們

392
00:16:20,800 --> 00:16:21,266
檢查的數據庫

393
00:16:21,266 --> 00:16:23,266
只是使用者介面的渲染而已

394
00:16:23,266 --> 00:16:25,433
不涉及任何其他參與者

395
00:16:25,433 --> 00:16:27,100
因為快照測試的想法是

396
00:16:27,100 --> 00:16:29,500
只測試渲染的結果

397
00:16:29,500 --> 00:16:33,833
切勿用快照測試來測試邏輯

398
00:16:33,833 --> 00:16:36,933
使用單元和集成測試來測試

399
00:16:36,933 --> 00:16:42,466
邏輯就好，就這麼簡單，我們提交吧

400
00:16:42,466 --> 00:16:45,600
確認快照與存儲

401
00:16:45,600 --> 00:16:48,866
的快照匹配，好的所以

402
00:16:48,866 --> 00:16:51,166
用於記錄和

403
00:16:51,166 --> 00:16:52,633
插入快照的基礎架構

404
00:16:52,633 --> 00:16:55,500
已經完成，而且是可重用的，我們可以

405
00:16:55,500 --> 00:16:56,633
製作

406
00:16:56,633 --> 00:16:59,833
視圖控制器或簡單的視圖的快照

407
00:16:59,833 --> 00:17:03,166
但這是一個非常簡單的實現

408
00:17:03,166 --> 00:17:06,000
我們可以使其更健全，允許

409
00:17:06,000 --> 00:17:07,500
在拍攝快照之前進行一些配置，

410
00:17:07,500 --> 00:17:08,466
例如，

411
00:17:08,466 --> 00:17:12,300 
讓它在一個iPhone 8的框架下渲染，

412
00:17:12,300 --> 00:17:15,833 
以亮色風格

413
00:17:15,833 --> 00:17:19,333 
並且也在一個iPhone 8的情況下渲染。

414
00:17:19,333 --> 00:17:22,700
以暗色風格我們也可以創建

415
00:17:22,700 --> 00:17:23,900
不同的配置

416
00:17:23,900 --> 00:17:27,166
比如像 iPhone 11 或者 iPhone

417
00:17:27,166 --> 00:17:30,466
SE 或任何我們想要的框架

418
00:17:30,466 --> 00:17:32,933
所以讓我們刪除舊的，讓我們

419
00:17:32,933 --> 00:17:34,233
重新錄製它

420
00:17:34,233 --> 00:17:38,766
以特定的配置

421
00:17:38,766 --> 00:17:41,200
所以現在快照擴展需要

422
00:17:41,200 --> 00:17:41,833
拿

423
00:17:41,833 --> 00:17:44,833
一個快照配置，我們可以

424
00:17:44,833 --> 00:17:47,200
定義一個尺寸

425
00:17:47,200 --> 00:17:50,133
安全區插入，佈局邊距

426
00:17:50,133 --> 00:17:51,433
我們想要使用

427
00:17:51,433 --> 00:17:54,766
特性集合等等

428
00:17:54,766 --> 00:17:57,266
並且我們可以定義一些預定義的

429
00:17:57,266 --> 00:17:58,233
配置

430
00:17:58,233 --> 00:18:00,866
正如我們所說的 iPhone 8 有一個給定的

431
00:18:00,866 --> 00:18:01,833
風格

432
00:18:01,833 --> 00:18:04,866
所以我們為 iPhone 8 設定尺寸 

433
00:18:04,866 --> 00:18:07,900
安全區插入，佈局邊距

434
00:18:07,900 --> 00:18:10,066
特性集合，我們設定了

435
00:18:10,066 --> 00:18:11,566
給定的風格，所以亮色

436
00:18:11,566 --> 00:18:13,600
或者暗色，並且你當然可以使用任何

437
00:18:13,600 --> 00:18:14,700
對於你的情況的配置

438
00:18:14,700 --> 00:18:18,133
你肯定可以，要覆蓋

439
00:18:18,133 --> 00:18:20,400
當前的配置我們需要一個

440
00:18:20,400 --> 00:18:21,666
自定義窗口


441
00:18:21,666 --> 00:18:23,600
我們僅在這快照窗口中使用此項

442
00:18:23,600 --> 00:18:25,666
在測試期間進行覆蓋

443
00:18:25,666 --> 00:18:27,833
所以現在視圖配置如此

444
00:18:27,833 --> 00:18:30,300
渲染現在在窗口中發生

445
00:18:30,300 --> 00:18:33,200
確實如此，渲染器不再在

446
00:18:33,200 --> 00:18:35,266
視圖控制器中進行

447
00:18:35,266 --> 00:18:38,000
我們需要將其嵌入快照

448
00:18:38,000 --> 00:18:38,766
窗口

449
00:18:38,766 --> 00:18:42,233
然後對其進行快照對吧

450
00:18:42,233 --> 00:18:46,066
好的，讓我們運行

451
00:18:46,066 --> 00:18:49,733
看看，我們現在有了

452
00:18:49,733 --> 00:18:52,066
空飼料的黑色表示

453
00:18:52,066 --> 00:18:53,833
以及亮色

454
00:18:53,833 --> 00:18:56,533
以及其他測試的同樣內容，無論

455
00:18:56,533 --> 00:18:57,100
黑暗

456
00:18:57,100 --> 00:18:59,600
還是亮色，如你所見，這裡有

457
00:18:59,600 --> 00:19:00,933
一些我們需要改進的地方

458
00:19:00,933 --> 00:19:04,000
以支持這裡的黑暗模式對吧，但是

459
00:19:04,000 --> 00:19:05,266
在我們這樣做之前

460
00:19:05,266 --> 00:19:07,666
我想要刪除滾動

461
00:19:07,666 --> 00:19:08,866
指示器

462
00:19:08,866 --> 00:19:11,266
從這張快照中，是的，我們希望我們的

463
00:19:11,266 --> 00:19:12,533
快照乾淨

464
00:19:12,533 --> 00:19:14,766
滾動條無需出現

465
00:19:14,766 --> 00:19:15,833
在那裡

466
00:19:15,833 --> 00:19:17,733
我們只需將顯示滾動

467
00:19:17,733 --> 00:19:19,500
指示器設定為false

468
00:19:19,500 --> 00:19:23,266
讓我們再次記錄快照

469
00:19:23,266 --> 00:19:26,700
好，現在它消失了

470
00:19:26,700 --> 00:19:30,000
好，現在讓我們修復佈局

471
00:19:30,000 --> 00:19:32,866
為了支援暗模式，讓我們開啟 Feed

472
00:19:32,866 --> 00:19:34,233
storyboard 重來

473
00:19:34,233 --> 00:19:38,000
讓我們選擇界面風格為暗色

474
00:19:38,000 --> 00:19:40,533
首先，讓我們調整顏色

475
00:19:40,533 --> 00:19:41,900
表格視圖

476
00:19:41,900 --> 00:19:44,933
背景不應該是白色，讓我們使用

477
00:19:44,933 --> 00:19:46,000
預設的

478
00:19:46,000 --> 00:19:49,033
系統背景顏色

479
00:19:49,033 --> 00:19:52,533
底部也是如此

480
00:19:52,533 --> 00:19:55,200
現在圖釘容器也需要

481
00:19:55,200 --> 00:19:58,133
系統背景顏色

482
00:19:58,133 --> 00:20:00,700
描述標籤應該是

483
00:20:00,700 --> 00:20:04,233
第二標籤顏色

484
00:20:04,233 --> 00:20:08,233
好多了，位置也一樣

485
00:20:08,233 --> 00:20:11,433
第二標籤顏色

486
00:20:11,433 --> 00:20:14,066
現在圖像容器背景我們

487
00:20:14,066 --> 00:20:15,433
可以使用

488
00:20:15,433 --> 00:20:19,266
次要的系統背景顏色

489
00:20:19,266 --> 00:20:22,000
最後，重試按鈕可以是

490
00:20:22,000 --> 00:20:23,333
系統的

491
00:20:23,333 --> 00:20:27,033
背景顏色，好

492
00:20:27,033 --> 00:20:29,666
讓我們執行測試並記錄新的

493
00:20:29,666 --> 00:20:31,666
快照

494
00:20:31,666 --> 00:20:35,033
太棒了，讓我們看一下亮的一邊

495
00:20:35,033 --> 00:20:38,633
不錯，暗的也看起來很好

496
00:20:38,633 --> 00:20:40,766
對於訊息，帶有

497
00:20:40,766 --> 00:20:42,000
內容的feed

498
00:20:42,000 --> 00:20:46,000
和空的feed也是一樣的

499
00:20:46,000 --> 00:20:50,866
讓我們先把storyboard提交

500
00:20:50,866 --> 00:20:58,000
添加深色模式的支持

501
00:20:58,000 --> 00:21:01,433
現在回到測試

502
00:21:01,433 --> 00:21:03,733
現在我們對錄製的

503
00:21:03,733 --> 00:21:04,633
圖片感到滿意

504
00:21:04,633 --> 00:21:08,066
我們現在可以改變功能以進行斷言

505
00:21:08,066 --> 00:21:09,666
所以我們停止覆蓋它並開始

506
00:21:09,666 --> 00:21:12,133
斷言該快照

507
00:21:12,133 --> 00:21:16,700
再次執行，看看結果

508
00:21:16,700 --> 00:21:20,466
成功了，太棒了，就是這樣

509
00:21:20,466 --> 00:21:22,766
所以這就是

510
00:21:22,766 --> 00:21:24,466
快照測試的一個簡單實現

511
00:21:24,466 --> 00:21:26,533
你可以在那裡找到框架，但是如果

512
00:21:26,533 --> 00:21:28,000
你只需要一個簡單的實現

513
00:21:28,000 --> 00:21:29,033
你可以擁有

514
00:21:29,033 --> 00:21:32,133
自己的，概念是錄製

515
00:21:32,133 --> 00:21:34,933
在檔案系統中的一個快照，將其保留

516
00:21:34,933 --> 00:21:35,433
在

517
00:21:35,433 --> 00:21:38,233
源代碼控制下，並隨著你對代碼的重構進行斷言

518
00:21:38,233 --> 00:21:40,066
以確保

519
00:21:40,066 --> 00:21:43,266
你的視圖按照你的期望進行渲染

520
00:21:43,266 --> 00:21:46,400
再次強調，你不應該用

521
00:21:46,400 --> 00:21:50,000
快照測試來測試邏輯，只應該測試用戶界面

522
00:21:50,000 --> 00:21:53,100
如果您想要檢查視覺，請仔細看

523
00:21:53,100 --> 00:21:54,000
邏輯部分

524
00:21:54,000 --> 00:21:56,766
可以使用單元測試，或者如果你想檢查

525
00:21:56,766 --> 00:21:58,300
在整合中的邏輯

526
00:21:58,300 --> 00:22:02,133
你可以使用整合測試，就這樣

527
00:22:02,133 --> 00:22:05,600
就是這樣，讓我們來提交 assert

528
00:22:05,600 --> 00:22:08,633
為了淺色和深色模式的快照

529
00:22:08,633 --> 00:22:12,766
使用 iPhone 8 的設定

530
00:22:12,766 --> 00:22:15,500
這就是快照測試，非常簡單

531
00:22:15,500 --> 00:22:16,066
簡單

532
00:22:16,066 --> 00:22:18,133
觀念，對於驗證您視圖的渲染非常有助益

533
00:22:18,133 --> 00:22:20,933
它可以捕捉到不易

534
00:22:20,933 --> 00:22:23,500
被單元測試或整合測試看見的細節

535
00:22:23,500 --> 00:22:24,000
容易

536
00:22:24,000 --> 00:22:26,466
和單元測試或整合測試相比

537
00:22:26,466 --> 00:22:27,433
測試

538
00:22:27,433 --> 00:22:30,233
它可以協助與

539
00:22:30,233 --> 00:22:31,333
設計師的合作

540
00:22:31,333 --> 00:22:33,266
因為你實際上可以給他們看

541
00:22:33,266 --> 00:22:35,266
照片而非程式碼

542
00:22:35,266 --> 00:22:37,600
現在，這些影像詳細具體地成為了

543
00:22:37,600 --> 00:22:38,466
git 的歷史部分

544
00:22:38,466 --> 00:22:40,000
這意味著你在做合併請求

545
00:22:40,000 --> 00:22:42,066
時持續驗證他們

546
00:22:42,066 --> 00:22:44,233
並且可以展示給設計師

547
00:22:44,233 --> 00:22:46,400
以驗證你的實現方式之前

548
00:22:46,400 --> 00:22:49,500
將程式碼推送到產品環境中

549
00:22:49,500 --> 00:22:52,066
如果你建立了好的快照，你可以

550
00:22:52,066 --> 00:22:53,100
甚至使用它們

551
00:22:53,100 --> 00:22:55,733
作為提交新的

552
00:22:55,733 --> 00:22:57,833
應用程序版本時的截圖

553
00:22:57,833 --> 00:23:01,266
但確切的說，請謹慎使用，不要用快照測試

554
00:23:01,266 --> 00:23:03,266
進行邏輯測試

555
00:23:03,266 --> 00:23:06,700
只對渲染進行測試，那麼這就是今天的

556
00:23:06,700 --> 00:23:07,600
講座的全部內容

557
00:23:07,600 --> 00:23:10,533
我們下次見，再見

558
00:23:10,533 --> 00:23:22,133
再見