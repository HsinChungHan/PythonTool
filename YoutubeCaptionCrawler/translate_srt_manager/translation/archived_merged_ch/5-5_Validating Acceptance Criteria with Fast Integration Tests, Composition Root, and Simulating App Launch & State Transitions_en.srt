

1
00:00:00,533 --> 00:00:03,500
嗨，Mike，嘿，Caio

2
00:00:03,500 --> 00:00:05,666
在上一堂課我們測試了一下

3
00:00:05,666 --> 00:00:06,866
接受標準

4
00:00:06,866 --> 00:00:09,833
用UI測試，它們運行得很好

5
00:00:09,833 --> 00:00:10,466
但是有

6
00:00:10,466 --> 00:00:13,500
兩個問題，第一

7
00:00:13,500 --> 00:00:15,900
我們的生產

8
00:00:15,900 --> 00:00:16,800
目標中結束了測試程式

9
00:00:16,800 --> 00:00:20,000
對吧？

10
00:00:20,000 --> 00:00:22,400
第二個，最重要的是，

11
00:00:22,400 --> 00:00:23,033
這些測試

12
00:00:23,033 --> 00:00:26,633
速度非常慢，我們只有3個

13
00:00:26,633 --> 00:00:28,866
簡單的測試，它們已經需要

14
00:00:28,866 --> 00:00:30,400
大約30秒的時間

15
00:00:30,400 --> 00:00:33,500
來運行，所以每個測試需要10秒

16
00:00:33,500 --> 00:00:36,866
對，所以添加更多功能會使得

17
00:00:36,866 --> 00:00:38,466
這種測試策略

18
00:00:38,466 --> 00:00:41,333
因為時間的問題而變得不可持續，

19
00:00:41,333 --> 00:00:41,900
這些測試

20
00:00:41,900 --> 00:00:44,933
需要運行的時間，對吧？

21
00:00:44,933 --> 00:00:46,300
如果我們繼續向這個

22
00:00:46,300 --> 00:00:48,533
應用程序添加功能並使用UI進行測試，

23
00:00:48,533 --> 00:00:49,500
這些測試

24
00:00:49,500 --> 00:00:52,366
很快就會需要半個小時甚至

25
00:00:52,366 --> 00:00:53,733
一個小時來運行

26
00:00:53,733 --> 00:00:55,266
這種開發過程是無法持續的，

27
00:00:55,266 --> 00:00:57,333
因為我們希望我們的

28
00:00:57,333 --> 00:01:00,300
迭代要快，我們希望合併

29
00:01:00,300 --> 00:01:01,100
程式碼

30
00:01:01,100 --> 00:01:04,233
一天內好幾次，但如果我們的

31
00:01:04,233 --> 00:01:06,000
持續集成管道需要

32
00:01:06,000 --> 00:01:07,100
數小時才能完成

33
00:01:07,100 --> 00:01:09,266
這將成為一個瓶頸

34
00:01:09,266 --> 00:01:10,933
正是如此

35
00:01:10,933 --> 00:01:14,066
所以我們需要更好的測試策略

36
00:01:14,066 --> 00:01:16,466
針對接受的標準，所以在這

37
00:01:16,466 --> 00:01:18,133
講座中，我將向您展示如何

38
00:01:18,133 --> 00:01:18,633
進行測試

39
00:01:18,633 --> 00:01:20,066
您的應用程式的接受標準

40
00:01:20,066 --> 00:01:22,933
完整組合

41
00:01:22,933 --> 00:01:25,666
使用集成測試，速度更

42
00:01:25,666 --> 00:01:26,466
快

43
00:01:26,466 --> 00:01:29,333
而且不需要您添加測試或

44
00:01:29,333 --> 00:01:30,866
特定的除錯代碼

45
00:01:30,866 --> 00:01:34,300
至生產環境，準確來說，Scene

46
00:01:34,300 --> 00:01:35,100
Delegate

47
00:01:35,100 --> 00:01:38,000
和 AppDelegate 就像其它的

48
00:01:38,000 --> 00:01:39,033
類別

49
00:01:39,033 --> 00:01:41,500
如果這裡面有代碼，你可以進行測試

50
00:01:41,500 --> 00:01:42,300
對

51
00:01:42,300 --> 00:01:45,500
正確來說，我們可以建立

52
00:01:45,500 --> 00:01:49,666
一個 SceneDelegateTests

53
00:01:49,666 --> 00:01:51,666
並像測試任何其它類別那樣測試 SceneDelegate 

54
00:01:51,666 --> 00:01:54,366
在我們系統中的其它類別

55
00:01:54,366 --> 00:01:56,933
例如，我們需要測試當

56
00:01:56,933 --> 00:01:58,533
新的場景連接的時候

57
00:01:58,533 --> 00:02:00,366
需要與場景會話進行連接


58
00:02:00,366 --> 00:02:02,233
配置視窗

59
00:02:02,233 --> 00:02:04,300
應用程式的根視圖控制器

60
00:02:04,300 --> 00:02:05,433
與 feed 一起

61
00:02:05,433 --> 00:02:08,800
使用者介面對，因此我們可以寫

62
00:02:08,800 --> 00:02:12,800
像是場景將連接到

63
00:02:12,800 --> 00:02:15,500
session 配置根視圖

64
00:02:15,500 --> 00:02:17,733
控制器

65
00:02:17,733 --> 00:02:19,566
因此我們需要一項斷言，我們想要

66
00:02:19,566 --> 00:02:21,900
當這個方法被調用時發生什麼

67
00:02:21,900 --> 00:02:22,233
好的，

68
00:02:22,233 --> 00:02:24,700
我們想要設置根視圖控制器

69
00:02:24,700 --> 00:02:25,733
在我們的視窗上

70
00:02:25,733 --> 00:02:28,300
並且在 UI 規格中，feed 視圖應該

71
00:02:28,300 --> 00:02:29,200
被嵌入

72
00:02:29,200 --> 00:02:31,833
在一個導航控制器中，所以

73
00:02:31,833 --> 00:02:32,933
我們需要的斷言

74
00:02:32,933 --> 00:02:35,833
在這裡，我們的根視圖控制器是一個

75
00:02:35,833 --> 00:02:38,000
UINavigationController

76
00:02:38,000 --> 00:02:41,433
當我們調用場景，我們連接到

77
00:02:41,433 --> 00:02:41,900
session

78
00:02:41,900 --> 00:02:44,866
方法，所以讓我們匯入 EssentialApp

79
00:02:44,866 --> 00:02:46,300
模組，這樣我們就可以訪問

80
00:02:46,300 --> 00:02:49,200
到 SceneDelegate，但是 Scene

81
00:02:49,200 --> 00:02:50,800
Delegate 不是公開的

82
00:02:50,800 --> 00:02:54,233
所以我們不能直接存取它，是的

83
00:02:54,233 --> 00:02:57,100
所以我們要么使它公開，要么我們將

84
00:02:57,100 --> 00:02:58,866
這個模組作為可測試的匯入

85
00:02:58,866 --> 00:03:02,133
在測試案例中，對吧，SceneDelegate

86
00:03:02,133 --> 00:03:04,300
APIs 不必要是公開的

87
00:03:04,300 --> 00:03:07,500
因為沒有其他人引用Scene

88
00:03:07,500 --> 00:03:08,933
Delegate

89
00:03:08,933 --> 00:03:11,033
對，所以SceneDelegate是

90
00:03:11,033 --> 00:03:12,633
Composition Root的一部分

91
00:03:12,633 --> 00:03:15,833
它是根模塊，沒有其他模塊

92
00:03:15,833 --> 00:03:16,700
引用

93
00:03:16,700 --> 00:03:19,833
主模塊，正因為如此，而不是

94
00:03:19,833 --> 00:03:21,900
將SceneDelegate公開

95
00:03:21,900 --> 00:03:24,633
我們可以將主模塊導入為

96
00:03:24,633 --> 00:03:25,433
可測試的

97
00:03:25,433 --> 00:03:27,200
因為我們不希望任何其他模塊

98
00:03:27,200 --> 00:03:29,566
使能接觸到這個模塊

99
00:03:29,566 --> 00:03:32,300
所以在測試一個根模塊時，我們不需要

100
00:03:32,300 --> 00:03:33,500
公開暴露

101
00:03:33,500 --> 00:03:37,200
任何根型別，就是這樣

102
00:03:37,200 --> 00:03:40,533
現在我們得到了自動完成功能，所以我們需要一個

103
00:03:40,533 --> 00:03:41,433
場景

104
00:03:41,433 --> 00:03:45,333
一個會話和選項

105
00:03:45,333 --> 00:03:49,666
所以一個場景就是一個UIScene

106
00:03:49,666 --> 00:03:52,000
並且場景需要一個會話和

107
00:03:52,000 --> 00:03:53,833
選項

108
00:03:53,833 --> 00:03:57,200
所以我們需要一個會話，一個會話就是一個

109
00:03:57,200 --> 00:04:00,066
UISceneSession並且初始化為編碼器，並且

110
00:04:00,066 --> 00:04:01,833
是可能出錯的初始化器

111
00:04:01,833 --> 00:04:03,833
因為它可能會失敗，所以這變得越來越困難

112
00:04:03,833 --> 00:04:04,933
現在的情況更棘手了

113
00:04:04,933 --> 00:04:07,033
我們應該傳遞什麼類型的 coder 呢

114
00:04:07,033 --> 00:04:10,000
我們試著傳遞一個空的 coder

115
00:04:10,000 --> 00:04:12,866
然後我們需要一些選項，也就是

116
00:04:12,866 --> 00:04:13,566
UIScene

117
00:04:13,566 --> 00:04:16,233
ConnectionOptions，但是這個類別

118
00:04:16,233 --> 00:04:17,100
並沒有

119
00:04:17,100 --> 00:04:20,133
一個公開的初始化器，如果你

120
00:04:20,133 --> 00:04:21,166
無法實例化

121
00:04:21,166 --> 00:04:23,900
一個方法的參數，我們就無法呼叫

122
00:04:23,900 --> 00:04:25,333
該方法

123
00:04:25,333 --> 00:04:28,533
當使用框架時這很常見

124
00:04:28,533 --> 00:04:30,466
那麼，你如何測試一個無法調用的方法

125
00:04:30,466 --> 00:04:32,000
呢？

126
00:04:32,000 --> 00:04:33,666
理想情況下，框架應該為你提供

127
00:04:33,666 --> 00:04:35,033
測試的工具：

128
00:04:35,033 --> 00:04:38,466
來測試你的程式碼，對吧？

129
00:04:38,466 --> 00:04:40,233
但是當它們沒有時，你還可以做些什麼

130
00:04:40,233 --> 00:04:41,666
你可以做些什麼？

131
00:04:41,666 --> 00:04:43,900
當你無法調用一個方法時，你可以將

132
00:04:43,900 --> 00:04:45,166
所有在該方法內的邏輯

133
00:04:45,166 --> 00:04:46,800
移至你可以調用的方法內

134
00:04:46,800 --> 00:04:48,866
並將無法調用的方法

135
00:04:48,866 --> 00:04:50,133
轉調為你可以調用的方法

136
00:04:50,133 --> 00:04:52,700
好的，你不能調用的方法

137
00:04:52,700 --> 00:04:54,000
應只做一件事情

138
00:04:54,000 --> 00:04:57,033
呼叫你可以調用的方法

139
00:04:57,033 --> 00:05:00,466
它不完美, 但足以應付

140
00:05:00,466 --> 00:05:04,066
是的，理想情況下，你想調用這個方法

141
00:05:04,066 --> 00:05:05,666
但是當你不能的時候，你不應該放棄

142
00:05:05,666 --> 00:05:07,833
在測試上，你把邏輯

143
00:05:07,833 --> 00:05:11,666
轉移到你可以調用的方法裡

144
00:05:11,666 --> 00:05:15,100
所以現在我們只調用 configure window

145
00:05:15,100 --> 00:05:17,666
我們不再需要這裡的所有代碼

146
00:05:17,666 --> 00:05:19,333
在我們運行測試之前，我們也應該

147
00:05:19,333 --> 00:05:20,466
設定

148
00:05:20,466 --> 00:05:24,700
一個窗口，否則窗口將變成

149
00:05:24,700 --> 00:05:30,400
nil，現在讓我們來運行測試

150
00:05:30,400 --> 00:05:33,433
測試失敗了，非常好

151
00:05:33,433 --> 00:05:36,700
讓它過去，讓我們把 feed UI

152
00:05:36,700 --> 00:05:40,000
嵌入到導航控制器中，運行測試

153
00:05:40,000 --> 00:05:42,233
再次

154
00:05:42,233 --> 00:05:46,700
通過測試，太好了，我們也應該檢查

155
00:05:46,700 --> 00:05:48,400
在導航堆疊的頂部視圖控制器中

156
00:05:48,400 --> 00:05:49,900
是一個 FeedViewController，沒錯

157
00:05:49,900 --> 00:05:53,166
僅檢查導航控制器

158
00:05:53,166 --> 00:05:54,866
是不夠的

159
00:05:54,866 --> 00:05:56,800
因為我們要確保我們擁有

160
00:05:56,800 --> 00:05:58,000
正確的構成, 那就是

161
00:05:58,000 --> 00:06:00,533
正确的组合

162
00:06:00,533 --> 00:06:03,900
將導航控制器設定為根，並且

163
00:06:03,900 --> 00:06:05,833
把FeedViewController設定為最頂端的

164
00:06:05,833 --> 00:06:08,633
導航控制器

165
00:06:08,633 --> 00:06:11,833
所以我們需要導入EssentialFeed

166
00:06:11,833 --> 00:06:12,466
iOS

167
00:06:12,466 --> 00:06:14,400
模塊來獲取FeedView

168
00:06:14,400 --> 00:06:16,233
Controller類型

169
00:06:16,233 --> 00:06:18,133
再次運行測試，他們應該會通過

170
00:06:18,133 --> 00:06:19,500
因為組合

171
00:06:19,500 --> 00:06:22,800
是正確的，真棒

172
00:06:22,800 --> 00:06:26,533
但如果我們破壞了組合

173
00:06:26,533 --> 00:06:29,600
我們現在應該有一個無效的測試

174
00:06:29,600 --> 00:06:32,700
在這裡呢，預期的是feed

175
00:06:32,700 --> 00:06:34,400
controller作為最頂端的控制器

176
00:06:34,400 --> 00:06:39,433
但是得到的是一個UIViewController 

177
00:06:39,433 --> 00:06:43,333
太好了，我們再來測試一次

178
00:06:43,333 --> 00:06:47,666
通過了，讓我們提交

179
00:06:47,666 --> 00:06:50,000
因此，配置飼料導航為

180
00:06:50,000 --> 00:06:53,166
window的root view controller

181
00:06:53,166 --> 00:06:55,266
就這麼樣，SceneDelegate或者

182
00:06:55,266 --> 00:06:57,033
AppDelegate他們只是普通的

183
00:06:57,033 --> 00:06:57,733
類別

184
00:06:57,733 --> 00:07:00,300
你可以通過單元或者

185
00:07:00,300 --> 00:07:02,633
集成測試來測試

186
00:07:02,633 --> 00:07:05,900
所以現在的想法是將這些UI

187
00:07:05,900 --> 00:07:07,333
驗收測試

188
00:07:07,333 --> 00:07:10,300
轉變為不必要的集成驗收測試

189
00:07:10,300 --> 00:07:10,866
不需要去

190
00:07:10,866 --> 00:07:13,666
運行應用並調查螢幕上的元素

191
00:07:13,666 --> 00:07:14,533
在螢幕上

192
00:07:14,533 --> 00:07:18,133
使用慢速的 UI 查詢

193
00:07:18,133 --> 00:07:21,166
我們可以像我們過去做的那樣，

194
00:07:21,166 --> 00:07:21,500
調查 UI 狀態

195
00:07:21,500 --> 00:07:23,900
在 EssentialFeediOS 整合中

196
00:07:23,900 --> 00:07:25,100
測試

197
00:07:25,100 --> 00:07:28,066
我們甚至可以重用同樣的助手進行

198
00:07:28,066 --> 00:07:29,033
模擬

199
00:07:29,033 --> 00:07:32,700
模擬 UI 事件，例如模擬 feed image

200
00:07:32,700 --> 00:07:36,466
是否可見或計算螢幕上的 feed

201
00:07:36,466 --> 00:07:39,566
imageViews 的數量，即使

202
00:07:39,566 --> 00:07:42,633
這些助手在 EssentialFeed

203
00:07:42,633 --> 00:07:45,333
iOS 目標中，它們都在測試

204
00:07:45,333 --> 00:07:46,466
組合

205
00:07:46,466 --> 00:07:49,433
UI 和整合的組合，且這些是

206
00:07:49,433 --> 00:07:51,033
組合細節

207
00:07:51,033 --> 00:07:52,933
組合細節應在

208
00:07:52,933 --> 00:07:54,133
Composition

209
00:07:54,133 --> 00:07:57,566
Root 中，所以我們將這組合

210
00:07:57,566 --> 00:07:58,866
細節

211
00:07:58,866 --> 00:08:01,033
移到 EssentialApp 目標的

212
00:08:01,033 --> 00:08:04,233
Composition Root

213
00:08:04,233 --> 00:08:06,800
這也給我們帶來了可能性去

214
00:08:06,800 --> 00:08:07,500
重用

215
00:08:07,500 --> 00:08:12,933
這些助手於接受測試時使用

216
00:08:12,933 --> 00:08:14,700
現在所有整合和組合

217
00:08:14,700 --> 00:08:16,000
細節都在

218
00:08:16,000 --> 00:08:19,166
Composition Root 中，但我們有

219
00:08:19,166 --> 00:08:20,533
一堆編譯錯誤


220
00:08:20,533 --> 00:08:24,633
所以我們需要修正導入語句

221
00:08:24,633 --> 00:08:28,066
以及任何需要的存取控制

222
00:08:28,066 --> 00:08:29,033
現在這些

223
00:08:29,033 --> 00:08:30,800
組成細節已經轉移到另一個

224
00:08:30,800 --> 00:08:32,066
模組，我們需要導入

225
00:08:32,066 --> 00:08:34,700
EssentialFeediOS目標，所以那些

226
00:08:34,700 --> 00:08:36,133
組件能夠存取

227
00:08:36,133 --> 00:08:38,933
如FeedView之類的feed UI類型

228
00:08:38,933 --> 00:08:40,300
控制器

229
00:08:40,300 --> 00:08:42,233
所以FeedViewControllerDelegate現在需要

230
00:08:42,233 --> 00:08:44,366
設為公開

231
00:08:44,366 --> 00:08:46,233
因為它是由外部類型實現的

232
00:08:46,233 --> 00:08:48,766
在此模塊之外

233
00:08:48,766 --> 00:08:51,100
所以委託也需要設為公開

234
00:08:51,100 --> 00:08:53,733
同樣

235
00:08:53,733 --> 00:08:56,766
接下來讓我們導入EssentialFeediOS

236
00:08:56,766 --> 00:08:59,900
在所有引用模組的地方

237
00:08:59,900 --> 00:09:03,433
引用了feed UI元素的地方，所以

238
00:09:03,433 --> 00:09:05,266
ImageCellDelegate也需要

239
00:09:05,266 --> 00:09:06,533
設為公開，因為它可以

240
00:09:06,533 --> 00:09:21,433
由此模块以外的類型實現

241
00:09:21,433 --> 00:09:24,366
最後，表格模型設置器需要

242
00:09:24,366 --> 00:09:27,033
做為公開

243
00:09:27,033 --> 00:09:28,533
但我們可以將設置器和

244
00:09:28,533 --> 00:09:30,933
取值器設為私有

245
00:09:30,933 --> 00:09:34,933
並創建一個公開方法來設置它

246
00:09:34,933 --> 00:09:38,933
好，所以現在adapter可以直接調用

247
00:09:38,933 --> 00:09:42,300
display，而不是直接設置屬性

248
00:09:42,300 --> 00:09:46,933
現在在測試目標中

249
00:09:46,933 --> 00:09:50,366
我們還需要導入EssentialApp

250
00:09:50,366 --> 00:09:55,833
模塊，composer現在就在這裡

251
00:09:55,833 --> 00:09:58,866
好，所有測試都通過了

252
00:09:58,866 --> 00:10:02,366
來提交一下，所以移動

253
00:10:02,366 --> 00:10:04,933
Feed UI組成細節到

254
00:10:04,933 --> 00:10:05,833
EssentialApp

255
00:10:05,833 --> 00:10:08,533
模塊在組成路由，就是這樣

256
00:10:08,533 --> 00:10:09,900
好

257
00:10:09,900 --> 00:10:12,300
所以，所有的組成細節都在

258
00:10:12,300 --> 00:10:12,933
現在

259
00:10:12,933 --> 00:10:16,300
在主模塊中，EssentialApp

260
00:10:16,300 --> 00:10:19,500
目標，好，所以現在我們可以創建

261
00:10:19,500 --> 00:10:22,066
feed接受測試，但是

262
00:10:22,066 --> 00:10:23,833
而不是UI測試

263
00:10:23,833 --> 00:10:28,366
這只是一個簡單的XCTestCase

264
00:10:28,366 --> 00:10:30,366
我們已經有了接受UI

265
00:10:30,366 --> 00:10:32,300
測試，所以我們可以只是

266
00:10:32,300 --> 00:10:35,900
在這裡貼上測試，對，我們想要

267
00:10:35,900 --> 00:10:36,366
測試

268
00:10:36,366 --> 00:10:39,733
完全相同的條件，但我們不

269
00:10:39,733 --> 00:10:40,800
需要運行應用程序

270
00:10:40,800 --> 00:10:44,300
來做到這一點，對，所以讓我們刪除

271
00:10:44,300 --> 00:10:46,700
這個實現方式，我們來重新實現

272
00:10:46,700 --> 00:10:47,433
這個

273
00:10:47,433 --> 00:10:50,466
對，一個一個來，首先進行的測試

274
00:10:50,466 --> 00:10:53,433
在啟動時，它應該會顯示遠端的

275
00:10:53,433 --> 00:10:54,000
訂閱內容

276
00:10:54,000 --> 00:10:57,266
當客戶有網路連接時，正確的是

277
00:10:57,266 --> 00:11:00,700
直接創建SceneDelegate 

278
00:11:00,700 --> 00:11:02,700
我們給它一個窗口，我們配置

279
00:11:02,700 --> 00:11:04,633
這個窗口，然後我們獲取FeedView

280
00:11:04,633 --> 00:11:05,333
Controller

281
00:11:05,333 --> 00:11:06,933
它是的根視圖控制器的頂級視圖控制器

282
00:11:06,933 --> 00:11:09,100
我們可以使用幫助程式

283
00:11:09,100 --> 00:11:11,333
從整合測試來驗證

284
00:11:11,333 --> 00:11:12,700
我們已經渲染出來

285
00:11:12,700 --> 00:11:16,000
兩個訂閱內容的圖像視圖，並且兩個

286
00:11:16,000 --> 00:11:19,500
圖像都被渲染在螢幕上

287
00:11:19,500 --> 00:11:23,200
對，但要做到這點，就像我們在用戶界面

288
00:11:23,200 --> 00:11:23,900
測試中那樣

289
00:11:23,900 --> 00:11:26,233
我們需要控制這個基礎建設，我們

290
00:11:26,233 --> 00:11:28,133
需要控制HTTP

291
00:11:28,133 --> 00:11:31,500
請求，因此理想情況下，我們將在這裡注入

292
00:11:31,500 --> 00:11:35,033
一個HTTPClient和

293
00:11:35,033 --> 00:11:37,433
一個商店，這個在測試時不需要是

294
00:11:37,433 --> 00:11:40,833
一個真正的客戶端和一個真正的商店

295
00:11:40,833 --> 00:11:44,466
對，他們可能會是一個InMemory

296
00:11:44,466 --> 00:11:48,633
FeedStore和一個HTTPClientStub

297
00:11:48,633 --> 00:11:51,333
所以我們可以控制不可靠的

298
00:11:51,333 --> 00:11:52,533
基礎設施

299
00:11:52,533 --> 00:11:55,266
組件我們想要這些測試去成為

300
00:11:55,266 --> 00:11:56,633
快速和可靠的

301
00:11:56,633 --> 00:11:58,533
因此我們不希望進行實際的HTTP

302
00:11:58,533 --> 00:12:00,800
請求或從

303
00:12:00,800 --> 00:12:02,233
數據庫中獲取東西

304
00:12:02,233 --> 00:12:04,933
確切地說我們想要確定的結果

305
00:12:04,933 --> 00:12:07,033
這正確的是在內存中的

306
00:12:07,033 --> 00:12:09,900
FeedStore和HTTPClientStub

307
00:12:09,900 --> 00:12:11,333
提供的

308
00:12:11,333 --> 00:12:13,900
所以我們需要導入EssentialFeed

309
00:12:13,900 --> 00:12:14,866
模塊

310
00:12:14,866 --> 00:12:18,000
這樣我們可以將HTTPClient和

311
00:12:18,000 --> 00:12:19,833
FeedStore變為stub

312
00:12:19,833 --> 00:12:21,833
而且客戶端stub是一個非常簡單的

313
00:12:21,833 --> 00:12:22,933
實現

314
00:12:22,933 --> 00:12:25,600
我們給它一個stub閉包，使其

315
00:12:25,600 --> 00:12:26,366
會返回

316
00:12:26,366 --> 00:12:30,300
為任何給定網址的結果

317
00:12:30,300 --> 00:12:32,533
我們可以給予預設的離線

318
00:12:32,533 --> 00:12:34,066
實現，總是

319
00:12:34,066 --> 00:12:37,333
失敗和一個總是成功的在線實現，

320
00:12:37,333 --> 00:12:38,800
如同為網址給定的stub

321
00:12:38,800 --> 00:12:42,066
在內存中的存儲實際上只是

322
00:12:42,066 --> 00:12:44,300
存儲值

323
00:12:44,300 --> 00:12:45,900
在內存的一個屬性中

324
00:12:45,900 --> 00:12:49,600
在記憶體內的一個屬性中

325
00:12:49,600 --> 00:12:53,200
所以在這個測試中，我們需要一個空的

326
00:12:53,200 --> 00:12:56,300
記憶體存儲，我們需要

327
00:12:56,300 --> 00:12:59,433
線上的 HTTPClient

328
00:12:59,433 --> 00:13:01,500
我們需要給一個功能來映射

329
00:13:01,500 --> 00:13:03,266
網址到成功的

330
00:13:03,266 --> 00:13:07,266
回應，我們已經有這樣的功能了

331
00:13:07,266 --> 00:13:09,200
它在 DebuggingScene 中使用過

332
00:13:09,200 --> 00:13:11,200
委託，所以在 DebuggingScene 中的

333
00:13:11,200 --> 00:13:12,000
委託中

334
00:13:12,000 --> 00:13:13,833
我們有一個完全相同的功能

335
00:13:13,833 --> 00:13:16,633
簽名，它接收一個網址作為參數

336
00:13:16,633 --> 00:13:19,733
並返回一個成功的回應，所以我們

337
00:13:19,733 --> 00:13:20,000
可以

338
00:13:20,000 --> 00:13:22,466
在整合中完全相同的使用它

339
00:13:22,466 --> 00:13:25,833
接受測試

340
00:13:25,833 --> 00:13:27,333
我們甚至可以使這更短並稱之為

341
00:13:27,333 --> 00:13:29,266
它為回應的 URL

342
00:13:29,266 --> 00:13:32,300
因為我們在測試目標中，

343
00:13:32,300 --> 00:13:35,666
我們可以使用我們的輔助 UIImage

344
00:13:35,666 --> 00:13:42,133
製作一種顏色為紅色的，這會簡單很多

345
00:13:42,133 --> 00:13:45,600
好的，所以這是一個擁有這個

346
00:13:45,600 --> 00:13:46,466
回應的 HTTPClient

347
00:13:46,466 --> 00:13:48,366
我們剛剛創建的功能，它會

348
00:13:48,366 --> 00:13:49,600
映射這個網址

349
00:13:49,600 --> 00:13:52,633
到一個成功的回應，就這樣了

350
00:13:52,633 --> 00:13:53,500
我們只需要添加

351
00:13:53,500 --> 00:13:55,266
一個便捷的初始器在 Scene 中

352
00:13:55,266 --> 00:13:58,233
Delegate，這樣我們就可以傳遞依賴

353
00:13:58,233 --> 00:14:02,066
對，所以這是便捷初始化器

354
00:14:02,066 --> 00:14:04,366
其中我們接收到的

355
00:14:04,366 --> 00:14:07,033
依賴項

356
00:14:07,033 --> 00:14:10,466
所以 HTTPClient 就是一個 HTTPClient

357
00:14:10,466 --> 00:14:12,800
並且 store 是符合

358
00:14:12,800 --> 00:14:15,033
FeedStore 和 FeedImage 兩者的商店

359
00:14:15,033 --> 00:14:18,000
DataStore 協議，就這樣，但是我們

360
00:14:18,000 --> 00:14:19,666
想要有預設的值

361
00:14:19,666 --> 00:14:22,066
對於那些依賴關係，所以不需

362
00:14:22,066 --> 00:14:22,866
製作他們

363
00:14:22,866 --> 00:14:26,300
我們可以把他們設置為懶加載變量

364
00:14:26,300 --> 00:14:29,033
如果他們未被設定，我們有機會

365
00:14:29,033 --> 00:14:30,366
實例化他們

366
00:14:30,366 --> 00:14:34,000
懶加載，所以 HTTPClient 就是

367
00:14:34,000 --> 00:14:35,266
如此創建的

368
00:14:35,266 --> 00:14:37,733
所以我們將創建過程移到

369
00:14:37,733 --> 00:14:38,533
懶加載中

370
00:14:38,533 --> 00:14:41,733
同樣的屬性，並且同樣的

371
00:14:41,733 --> 00:14:49,266
對於商店

372
00:14:49,266 --> 00:14:51,033
所以如果我們提供一個，我們將會使用

373
00:14:51,033 --> 00:14:52,700
提供的那一個

374
00:14:52,700 --> 00:14:56,000
否則，他將根據需要進行懶加載

375
00:14:56,000 --> 00:15:00,000
那就是它，讓我們現在進行測試

376
00:15:00,000 --> 00:15:03,433
好的，正在建構和檢測

377
00:15:03,433 --> 00:15:05,833
因為這項行為已經過了測試

378
00:15:05,833 --> 00:15:07,033
已經過測試

379
00:15:07,033 --> 00:15:09,600
並且已經在 UI 測試中實施

380
00:15:09,600 --> 00:15:10,933
確切地說

381
00:15:10,933 --> 00:15:13,166
如你所見，我們對於整合測試有更多的控制

382
00:15:13,166 --> 00:15:14,366
比起 UI 測試

383
00:15:14,366 --> 00:15:17,100
我們不需要添加

384
00:15:17,100 --> 00:15:18,066
這段代碼

385
00:15:18,066 --> 00:15:21,833
在生產環境中確切地說，我們甚至可以

386
00:15:21,833 --> 00:15:23,733
對這些測試做更加徹底的檢驗

387
00:15:23,733 --> 00:15:25,666
而不只是檢查圖像

388
00:15:25,666 --> 00:15:27,166
是否為非空

389
00:15:27,166 --> 00:15:30,300
甚至可以主張準確的價值是什麼

390
00:15:30,300 --> 00:15:31,100
被呈現

391
00:15:31,100 --> 00:15:34,133
在每個單元格中確切地說

392
00:15:34,133 --> 00:15:36,300
我們不只是檢查

393
00:15:36,300 --> 00:15:38,700
像我們在 UI 測試中所做的那樣圖像的存在

394
00:15:38,700 --> 00:15:42,066
但在這裡我們可以測試圖像的一致性

395
00:15:42,066 --> 00:15:43,600
同樣如此

396
00:15:43,600 --> 00:15:46,000
這給了我們更高的信心

397
00:15:46,000 --> 00:15:47,500
這個功能運作正常

398
00:15:47,500 --> 00:15:50,466
符合預期，因為我們正在比較

399
00:15:50,466 --> 00:15:51,733
被渲染出的值

400
00:15:51,733 --> 00:15:54,233
伴隨著被回傳的數據

401
00:15:54,233 --> 00:15:55,266
成功的 

402
00:15:55,266 --> 00:15:58,866
HTTP 回應

403
00:15:58,866 --> 00:16:01,333
我們甚至可以創建一個幫助器來簡化

404
00:16:01,333 --> 00:16:02,933
這段程式碼

405
00:16:02,933 --> 00:16:11,166
像是在索引處渲染FeedImageData

406
00:16:11,166 --> 00:16:14,233
看，這樣看起來更好

407
00:16:14,233 --> 00:16:16,866
還有一個我們可以做的重構

408
00:16:16,866 --> 00:16:17,833
我們能夠

409
00:16:17,833 --> 00:16:21,266
把所有的設定程式碼挪出來

410
00:16:21,266 --> 00:16:23,033
並放入函數中

411
00:16:23,033 --> 00:16:26,466
就像是 

412
00:16:26,466 --> 00:16:29,733
用 HTTPClient 和儲存庫來啟動

413
00:16:29,733 --> 00:16:33,033
並把所有設置邏輯放在這裡

414
00:16:33,033 --> 00:16:36,866
就這樣，就這樣完成了

415
00:16:36,866 --> 00:16:39,600
在啟動時，連接網絡時顯示遠程訂閱內容

416
00:16:39,600 --> 00:16:41,600
當客戶端連接成功時

417
00:16:41,600 --> 00:16:44,633
因此我們用一個連線環境的 HTTPClient

418
00:16:44,633 --> 00:16:48,633
來啟動應用程式

419
00:16:48,633 --> 00:16:51,900
然後我們測試我們的資訊是否讀取成功

420
00:16:51,900 --> 00:16:55,666
讓我們進行測試

421
00:16:55,666 --> 00:16:58,366
通過測試，對這點我非常滿意

422
00:16:58,366 --> 00:16:59,500
重構的力量在於

423
00:16:59,500 --> 00:17:02,000
我們的測試現在完全脫離了

424
00:17:02,000 --> 00:17:03,666
實現細節的約束

425
00:17:03,666 --> 00:17:06,766
對，與SceneDelegate的實現完全無關

426
00:17:06,766 --> 00:17:10,400
現在就提交"顯示遠程訂閱內容"

427
00:17:10,400 --> 00:17:15,266
當客戶連接到網路時啟動

428
00:17:15,266 --> 00:17:18,233
所以下一個在啟動時的測試顯示的是

429
00:17:18,233 --> 00:17:18,766
已緩存的數據

430
00:17:18,766 --> 00:17:21,566
遠程的feed，所以有一個已緩存的feed

431
00:17:21,566 --> 00:17:23,333
且沒有連線

432
00:17:23,333 --> 00:17:25,500
所以就像在UI測試中一樣，我們首先

433
00:17:25,500 --> 00:17:27,433
需要填充緩存

434
00:17:27,433 --> 00:17:29,433
在這種情況下，我們與網絡連接並啟動了應用程序

435
00:17:29,433 --> 00:17:30,533
有連線

436
00:17:30,533 --> 00:17:33,333
和一個共享的存儲，然後我們確保

437
00:17:33,333 --> 00:17:34,700
圖像

438
00:17:34,700 --> 00:17:37,266
變得可見，這加載了圖像 

439
00:17:37,266 --> 00:17:38,766
然後我們啟動了應用程序 

440
00:17:38,766 --> 00:17:41,900
但以離線模式，並且是相同的

441
00:17:41,900 --> 00:17:42,766
共享存儲 

442
00:17:42,766 --> 00:17:46,133
以確保我們從緩存中載入了項目 

443
00:17:46,133 --> 00:17:49,266
從緩存中，所以我們應該仍然顯示 

444
00:17:49,266 --> 00:17:53,266
兩個圖像並渲染圖像數據 

445
00:17:53,266 --> 00:17:56,700
讓我們運行我的測試通過

446
00:17:56,700 --> 00:18:00,066
好的，讓我們提交顯示

447
00:18:00,066 --> 00:18:02,533
當客戶沒有連線時在啟動時顯示緩存的feed 

448
00:18:02,533 --> 00:18:05,266
無連線 

449
00:18:05,266 --> 00:18:08,466
最後，在啟動時會顯示空

450
00:18:08,466 --> 00:18:08,866
feed

451
00:18:08,866 --> 00:18:11,666
當客戶沒有連線且沒有

452
00:18:11,666 --> 00:18:12,700
緩存的時候

453
00:18:12,700 --> 00:18:15,833
所以若我們以離線模式啟動應用程序並且

454
00:18:15,833 --> 00:18:16,633
帶著一個空的

455
00:18:16,633 --> 00:18:19,500
儲存庫，它應該顯示一個空的

456
00:18:19,500 --> 00:18:20,300
螢幕

457
00:18:20,300 --> 00:18:23,333
就是這樣，讓我們運行試驗

458
00:18:23,333 --> 00:18:27,033
通過，好的，讓我們提交

459
00:18:27,033 --> 00:18:29,666
在啟動時顯示空的feed當

460
00:18:29,666 --> 00:18:31,266
客戶沒有連線

461
00:18:31,266 --> 00:18:34,533
和沒有緩存

462
00:18:34,533 --> 00:18:37,333
好的，所以我們把UI测试

463
00:18:37,333 --> 00:18:38,466
轉移成為集成測試

464
00:18:38,466 --> 00:18:41,266
驗證完全相同的情境

465
00:18:41,266 --> 00:18:42,133
但我們還沒有看到

466
00:18:42,133 --> 00:18:43,900
任何失敗的測試，因為該情境

467
00:18:43,900 --> 00:18:45,600
已經實現了

468
00:18:45,600 --> 00:18:47,733
好的，那我們為什麼不改變

469
00:18:47,733 --> 00:18:49,666
組合以確保

470
00:18:49,666 --> 00:18:51,600
錯誤的組合會導致測試失敗

471
00:18:51,600 --> 00:18:52,933
組合

472
00:18:52,933 --> 00:18:55,833
例如，如果我們只組合UI

473
00:18:55,833 --> 00:18:57,666
和RemoteFeedLoader而不使用

474
00:18:57,666 --> 00:18:58,933
回落

475
00:18:58,933 --> 00:19:03,033
圖像也是一樣的

476
00:19:03,033 --> 00:19:06,466
讓我們運行試驗

477
00:19:06,466 --> 00:19:10,000
好的，它失敗了但它失敗了

478
00:19:10,000 --> 00:19:12,466
是由於一個異常，因為我們的測試

479
00:19:12,466 --> 00:19:14,400
試圖調查一個單元格

480
00:19:14,400 --> 00:19:17,433
不存就所以我們得到一個


481
00:19:17,433 --> 00:19:21,600
index out of range exception

482
00:19:21,600 --> 00:19:23,333
而不是一個致命錯誤，更好的是

483
00:19:23,333 --> 00:19:25,200
如果我們得到的是一個斷言

484
00:19:25,200 --> 00:19:28,700
錯誤，那我們來看看堆棧追蹤

485
00:19:28,700 --> 00:19:32,133
找出哪個方法調用了單元格

486
00:19:32,133 --> 00:19:33,600
查找

487
00:19:33,600 --> 00:19:35,666
而這就是這個測試助手中的feed

488
00:19:35,666 --> 00:19:36,633
image view

489
00:19:36,633 --> 00:19:40,066
在此處，我們需要檢查

490
00:19:40,066 --> 00:19:42,466
我們是否正在請求單元格集內的單元格

491
00:19:42,466 --> 00:19:44,233
如果不是，我們直接返回 nil

492
00:19:44,233 --> 00:19:47,733
這就意味著該行沒有單元格

493
00:19:47,733 --> 00:19:51,266
對，讓我們再次運行測試

494
00:19:51,266 --> 00:19:55,600
現在我們得到的是失敗的斷言，

495
00:19:55,600 --> 00:19:58,066
而不是致命錯誤

496
00:19:58,066 --> 00:20:00,866
如你看到的，由於我們已經移除了

497
00:20:00,866 --> 00:20:02,866
與緩存的合成，

498
00:20:02,866 --> 00:20:05,200
檢查離線

499
00:20:05,200 --> 00:20:07,266
行為的測試開始失敗

500
00:20:07,266 --> 00:20:09,666
太好了，是的，現在的測試失敗了，

501
00:20:09,666 --> 00:20:13,200
而不是崩潰，而且它們沒有

502
00:20:13,200 --> 00:20:15,433
打斷流程

503
00:20:15,433 --> 00:20:16,933
這是一種更好的反饋

504
00:20:16,933 --> 00:20:18,833


505
00:20:18,833 --> 00:20:21,333
機制，就是這樣

506
00:20:21,333 --> 00:20:24,633
讓我們恢復正確的組成

507
00:20:24,633 --> 00:20:28,233
再次執行測試

508
00:20:28,233 --> 00:20:31,266
現在它通過了

509
00:20:31,266 --> 00:20:34,633
並可在此處有任何不同的組成

510
00:20:34,633 --> 00:20:39,033
這將導致測試失敗

511
00:20:39,033 --> 00:20:42,533
就是這樣，所以接受測試

512
00:20:42,533 --> 00:20:45,333
給予我們這種高層次的信心

513
00:20:45,333 --> 00:20:46,300
系統做

514
00:20:46,300 --> 00:20:48,633
是預期要做的，我們不需要

515
00:20:48,633 --> 00:20:49,333
透過 UI 測試做到

516
00:20:49,333 --> 00:20:51,900
如果你寫好

517
00:20:51,900 --> 00:20:53,266
集成測試

518
00:20:53,266 --> 00:20:55,333
你可以有相同的信心

519
00:20:55,333 --> 00:20:56,400
而不必添加

520
00:20:56,400 --> 00:20:59,433
測試代碼至生產或執行超

521
00:20:59,433 --> 00:21:01,433
慢速測試

522
00:21:01,433 --> 00:21:05,333
使我們提交最後的更動，所以檢查

523
00:21:05,333 --> 00:21:07,266
在獲取單元格之前的單元格數量

524
00:21:07,266 --> 00:21:08,933
以避免

525
00:21:08,933 --> 00:21:12,633
出界異常

526
00:21:12,633 --> 00:21:15,900
現在，我們將刪除 UI 接受

527
00:21:15,900 --> 00:21:17,433
測試目標

528
00:21:17,433 --> 00:21:23,100
因為現在它是多餘的

529
00:21:23,100 --> 00:21:26,400
所以讓我們確定刪除計劃

530
00:21:26,400 --> 00:21:30,233
接受測試的計劃

531
00:21:30,233 --> 00:21:34,133
並將其從 CI 計劃中移除

532
00:21:34,133 --> 00:21:40,866
好，讓我們再次建立並運行測試

533
00:21:40,866 --> 00:21:44,133
測試通過，我們來提交改動 

534
00:21:44,133 --> 00:21:48,066
刪除 EssentialAppUIAcceptanceTests

535
00:21:48,066 --> 00:21:51,033
改用更快更精準的 

536
00:21:51,033 --> 00:21:54,533
整合行測試

537
00:21:54,533 --> 00:21:57,200
現在我們可以刪除 Debugging

538
00:21:57,200 --> 00:21:58,866
SceneDelegate

539
00:21:58,866 --> 00:22:01,733
從生產環境中移除，我們不需要

540
00:22:01,733 --> 00:22:02,533
切換 

541
00:22:02,533 --> 00:22:05,433
在除錯時別的代理類別

542
00:22:05,433 --> 00:22:07,433
了

543
00:22:07,433 --> 00:22:08,866
也就是我們不需要 make

544
00:22:08,866 --> 00:22:10,933
RemoteClient 這個函數了

545
00:22:10,933 --> 00:22:13,833
在之前被除錯時的

546
00:22:13,833 --> 00:22:15,333
delegate所覆蓋的

547
00:22:15,333 --> 00:22:18,300
單純使用 HTTPClient

548
00:22:18,300 --> 00:22:20,933
即可

549
00:22:20,933 --> 00:22:24,133
對 localStoreURL也是如此

550
00:22:24,133 --> 00:22:28,700
現在可以設為私人細節了

551
00:22:28,700 --> 00:22:32,633
結束了，封裝得更好

552
00:22:32,633 --> 00:22:37,100
來運行測試，還是通過

553
00:22:37,100 --> 00:22:41,200
提交，移除未使用的除錯

554
00:22:41,200 --> 00:22:41,900
程式碼

555
00:22:41,900 --> 00:22:46,866
以前用於UI測試時用的，

556
00:22:46,866 --> 00:22:49,733
全部刪除，測試程式碼不再放在生產環境了

557
00:22:49,733 --> 00:22:52,000
太好了

558
00:22:52,000 --> 00:22:54,633
所以在一個

559
00:22:54,633 --> 00:22:56,000
整合環境風格的 FeedAcceptanceTests 中

560
00:22:56,000 --> 00:22:59,033
可以是一種較好的UI選擇

561
00:22:59,033 --> 00:23:02,066
是的，並且我們甚至可以做得更多

562
00:23:02,066 --> 00:23:03,033
徹底一些

563
00:23:03,033 --> 00:23:06,400
並且測試一個我們不能夠

564
00:23:06,400 --> 00:23:07,433
實際測試的用例

565
00:23:07,433 --> 00:23:10,233
在UI測試中，當app處於

566
00:23:10,233 --> 00:23:10,866
進入

567
00:23:10,866 --> 00:23:15,200
背景，我們希望驗證緩存

568
00:23:15,200 --> 00:23:18,133
確實，我們實現了驗證緩存的功能

569
00:23:18,133 --> 00:23:19,333
緩存

570
00:23:19,333 --> 00:23:22,133
用例，但是到目前為止，我們從未使用過

571
00:23:22,133 --> 00:23:23,733
它

572
00:23:23,733 --> 00:23:25,600
這個用例每次都必須被呼叫

573
00:23:25,600 --> 00:23:27,100
每次app將要

574
00:23:27,100 --> 00:23:30,400
進入背景，現在我們可以測試這種行為

575
00:23:30,400 --> 00:23:33,033
透過整合測試，因此如果我們

576
00:23:33,033 --> 00:23:34,000
進入背景

577
00:23:34,000 --> 00:23:37,500
緩存已過期，則應該

578
00:23:37,500 --> 00:23:38,066
會

579
00:23:38,066 --> 00:23:41,500
刪除緩存，所以它應為空（nil）

580
00:23:41,500 --> 00:23:43,333
但是如果它帶有未過期的緩存進入背景

581
00:23:43,333 --> 00:23:44,766
未過期的緩存

582
00:23:44,766 --> 00:23:46,866
系統應該保留該緩存，因此它 

583
00:23:46,866 --> 00:23:48,833
應該是存在的（非nil）

584
00:23:48,833 --> 00:23:51,733
確實，讓我們添加輔助程序

585
00:23:51,733 --> 00:23:54,766
進入背景模式，簡單地創建 

586
00:23:54,766 --> 00:23:57,666
SceneDelegate 與指定的存儲庫

587
00:23:57,666 --> 00:23:59,200
和呼叫委託方法

588
00:23:59,200 --> 00:24:00,933
這是在應用程式

589
00:24:00,933 --> 00:24:04,066
轉到背景時調用的

590
00:24:04,066 --> 00:24:06,133
我們還需要添加靜態的

591
00:24:06,133 --> 00:24:07,200
helpers

592
00:24:07,200 --> 00:24:09,900
創建過期的 feed cache，所以

593
00:24:09,900 --> 00:24:10,766
它是一個 cache

594
00:24:10,766 --> 00:24:15,033
與一個老的時間戳，很遙遠的過去

595
00:24:15,033 --> 00:24:16,933
和一個新的非過期的

596
00:24:16,933 --> 00:24:21,666
時間戳

597
00:24:21,666 --> 00:24:23,333
現在我們需要實現 scene

598
00:24:23,333 --> 00:24:25,833
我們放棄活動

599
00:24:25,833 --> 00:24:30,833
在 SceneDelegate 中，讓我們運行

600
00:24:30,833 --> 00:24:32,300
測試

601
00:24:32,300 --> 00:24:35,266
失敗了，它沒有刪除過期的

602
00:24:35,266 --> 00:24:37,833
cache

603
00:24:37,833 --> 00:24:40,233
所以我們需要調用驗證 cache

604
00:24:40,233 --> 00:24:41,100
方法

605
00:24:41,100 --> 00:24:43,200
由 LocalFeedLoader 實現

606
00:24:43,200 --> 00:24:44,133
確實

607
00:24:44,133 --> 00:24:45,433
但我們在這個

608
00:24:45,433 --> 00:24:47,200
範圍內無法訪問 LocalFeedLoader

609
00:24:47,200 --> 00:24:51,100
所以我們可以讓它

610
00:24:51,100 --> 00:24:54,466
變成一個 lazy var，所以每個實例

611
00:24:54,466 --> 00:24:55,733
方法都有訪問權限

612
00:24:55,733 --> 00:24:58,400
對此屬性就是了，應該

613
00:24:58,400 --> 00:25:00,066
可以了

614
00:25:00,066 --> 00:25:03,266
讓我們再次運行測試，現在它

615
00:25:03,266 --> 00:25:05,500
通過了

616
00:25:05,500 --> 00:25:08,300
所以它在進入背景時刪除過期的緩存

617
00:25:08,300 --> 00:25:10,633
進入背景

618
00:25:10,633 --> 00:25:13,266
但它在進入背景時保留未過期的緩存

619
00:25:13,266 --> 00:25:15,333
進入背景

620
00:25:15,333 --> 00:25:19,266
讓我們提交驗證feed cache

621
00:25:19,266 --> 00:25:23,100
在進入背景時所以就是這樣

622
00:25:23,100 --> 00:25:26,133
一種替代UI測試的方法是撰寫

623
00:25:26,133 --> 00:25:28,766
可以更加詳盡的整合測試

624
00:25:28,766 --> 00:25:29,600
詳盡的

625
00:25:29,600 --> 00:25:32,233
且不需要您添加測試代碼

626
00:25:32,233 --> 00:25:33,600
在生產中

627
00:25:33,600 --> 00:25:36,766
確實，他們讓你提高

628
00:25:36,766 --> 00:25:39,433
代碼覆蓋率，當然他們

629
00:25:39,433 --> 00:25:40,133
來了

630
00:25:40,133 --> 00:25:43,033
比UI測試要便宜得多

631
00:25:43,033 --> 00:25:44,300
測試

632
00:25:44,300 --> 00:25:46,466
他們更容易撰寫，並且他們

633
00:25:46,466 --> 00:25:48,233
速度更快

634
00:25:48,233 --> 00:25:51,266
如您所見，5個整合測試

635
00:25:51,266 --> 00:25:54,766
只需要0.2秒

636
00:25:54,766 --> 00:25:57,733
相比於UI測試來說

637
00:25:57,733 --> 00:25:58,233
哪裡

638
00:25:58,233 --> 00:26:02,633
3個測試需要近30秒

639
00:26:02,633 --> 00:26:05,600
所以至少快100倍

640
00:26:05,600 --> 00:26:06,700
更快

641
00:26:06,700 --> 00:26:08,400
確實，整合測試和UI測試之間

642
00:26:08,400 --> 00:26:10,400
在整合測試和UI測試之間沒有比較的必要，當

643
00:26:10,400 --> 00:26:13,200
當提到速度，這些數字就可以說明一切

644
00:26:13,200 --> 00:26:14,533
自不待言

645
00:26:14,533 --> 00:26:16,233
並且重要的是要思考

646
00:26:16,233 --> 00:26:18,700
專案的未來

647
00:26:18,700 --> 00:26:21,600
接下來增加的功能會增加多少

648
00:26:21,600 --> 00:26:22,133
那會

649
00:26:22,133 --> 00:26:25,833
增加這些時間，所以儘可能地

650
00:26:25,833 --> 00:26:28,633
使用 integration tests 而非 UI tests

651
00:26:28,633 --> 00:26:29,500
來提升你的覆蓋率並加快你的

652
00:26:29,500 --> 00:26:31,733
開發流程

653
00:26:31,733 --> 00:26:33,100
更快，好的，這樣我們就可以結束

654
00:26:33,100 --> 00:26:36,400
這堂講座了

655
00:26:36,400 --> 00:26:37,333
這堂課程的講解

656
00:26:37,333 --> 00:26:40,300
下次見，再見，

657
00:26:40,300 --> 00:26:53,833
拜拜