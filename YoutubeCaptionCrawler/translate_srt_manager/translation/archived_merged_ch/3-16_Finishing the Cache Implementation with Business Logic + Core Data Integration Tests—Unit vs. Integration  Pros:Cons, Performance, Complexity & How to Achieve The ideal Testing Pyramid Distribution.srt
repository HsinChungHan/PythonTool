

1
00:00:01,033 --> 00:00:04,066
你好，Mike，嘿，Caio，在這次的講座裡

2
00:00:04,066 --> 00:00:06,000
你將學會如何創建和區分

3
00:00:06,000 --> 00:00:07,200
集成測試

4
00:00:07,200 --> 00:00:09,666
從單元或也被稱為獨立的

5
00:00:09,666 --> 00:00:10,466
測試

6
00:00:10,466 --> 00:00:12,866
目標是讓獨立測試保持

7
00:00:12,866 --> 00:00:13,733
快速的

8
00:00:13,733 --> 00:00:15,733
儘可能快，它們是主要的

9
00:00:15,733 --> 00:00:17,100
反饋機制

10
00:00:17,100 --> 00:00:19,166
用於開發我們的應用程式 

11
00:00:19,166 --> 00:00:20,633
你應該能夠執行那些獨立的

12
00:00:20,633 --> 00:00:21,166
測試

13
00:00:21,166 --> 00:00:23,266
一天數次而不影響

14
00:00:23,266 --> 00:00:24,633
你的生產力

15
00:00:24,633 --> 00:00:27,266
我們建議你在每個

16
00:00:27,266 --> 00:00:28,700
微小的代碼變動上執行它們

17
00:00:28,700 --> 00:00:30,133
如同我們在這堂

18
00:00:30,133 --> 00:00:32,533
課程中所示，獨立測試

19
00:00:32,533 --> 00:00:35,500
給了我們快速且連續的反饋，

20
00:00:35,500 --> 00:00:36,933
並且給了我們自信

21
00:00:36,933 --> 00:00:39,500
確保我們的組件按照我們的意圖運作

22
00:00:39,500 --> 00:00:40,233
無論何時

23
00:00:40,233 --> 00:00:43,200
在開發周期中，另一方面，

24
00:00:43,200 --> 00:00:44,533
集成測試

25
00:00:44,533 --> 00:00:46,800
給我們自信讓我們的獨立

26
00:00:46,800 --> 00:00:47,833
組件

27
00:00:47,833 --> 00:00:50,533
在共同協作時運作良好

28
00:00:50,533 --> 00:00:52,000
沒有模擬

29
00:00:52,000 --> 00:00:54,700
或任何其他類型的測試替代品。

30
00:00:54,700 --> 00:00:55,333
然而，

31
00:00:55,333 --> 00:00:57,900
當進行API請求時，

32
00:00:57,900 --> 00:00:59,500
集成測試可能會很慢。

33
00:00:59,500 --> 00:01:01,600
或是互動與資料庫或是

34
00:01:01,600 --> 00:01:03,433
檔案系統例如說

35
00:01:03,433 --> 00:01:05,566
所以我們不經常運行整合測試像是

36
00:01:05,566 --> 00:01:06,933
單元測試那麼頻繁

37
00:01:06,933 --> 00:01:10,000
或是隔離測試，但我們確實會運行它們

38
00:01:10,000 --> 00:01:10,700
頻繁地

39
00:01:10,700 --> 00:01:13,333
當然作為我們持續

40
00:01:13,333 --> 00:01:14,933
整合管道的一部分

41
00:01:14,933 --> 00:01:18,000
確實地，只有代碼應該被合併到

42
00:01:18,000 --> 00:01:19,033
主要的分支

43
00:01:19,033 --> 00:01:22,066
如果所有的整合和隔離測試

44
00:01:22,066 --> 00:01:24,466
都通過並且所有這些檢查應該是

45
00:01:24,466 --> 00:01:25,266
自動化的

46
00:01:25,266 --> 00:01:27,600
以加快團隊協作並且

47
00:01:27,600 --> 00:01:29,500
避免瓶頸

48
00:01:29,500 --> 00:01:31,433
所以讓我們首先創建一個新的測試

49
00:01:31,433 --> 00:01:33,266
對我們的緩存的目標

50
00:01:33,266 --> 00:01:35,900
整合測試，我們命名它為

51
00:01:35,900 --> 00:01:37,100
EssentialFeed

52
00:01:37,100 --> 00:01:42,300
CacheIntegrationTests

53
00:01:42,300 --> 00:01:44,633
然後讓我們配置緩存的

54
00:01:44,633 --> 00:01:46,000
整合測試

55
00:01:46,000 --> 00:01:50,000
方案

56
00:01:50,000 --> 00:01:52,300
一如既往，我們將執行隨機化

57
00:01:52,300 --> 00:01:53,100
順序

58
00:01:53,100 --> 00:01:54,633
來保證測試之間沒有依賴性

59
00:01:54,633 --> 00:01:57,900
或執行順序

60
00:01:57,900 --> 00:02:02,133
確實，讓我們也收集覆蓋率

61
00:02:02,133 --> 00:02:04,233
對於我們感興趣的目標

62
00:02:04,233 --> 00:02:07,266
EssentialFeed

63
00:02:07,266 --> 00:02:09,566
如您所見，我們現在有一個新的文件夾

64
00:02:09,566 --> 00:02:11,666
用於集成測試

65
00:02:11,666 --> 00:02:13,900
裏面有一個XCTestCase子類，我們

66
00:02:13,900 --> 00:02:16,400
可以開始添加我們的集成測試

67
00:02:16,400 --> 00:02:18,400
我們的想法是將所有的緩存

68
00:02:18,400 --> 00:02:19,666
模型對象整合

69
00:02:19,666 --> 00:02:22,133
並看看他們的協同行為

70
00:02:22,133 --> 00:02:22,700
或者

71
00:02:22,700 --> 00:02:25,566
具體來說，我們以前一直在

72
00:02:25,566 --> 00:02:27,033
進行隔離測試

73
00:02:27,033 --> 00:02:29,266
通過使用假雙，但現在是時候

74
00:02:29,266 --> 00:02:30,633
看看它們的行為

75
00:02:30,633 --> 00:02:33,500
在與實際實例協同作業時

76
00:02:33,500 --> 00:02:34,866
的生產類型

77
00:02:34,866 --> 00:02:37,666
好極了，還有EssentialFeedAPI的

78
00:02:37,666 --> 00:02:38,700
EndToEndTests

79
00:02:38,700 --> 00:02:41,500
我們在上一講中創建的是

80
00:02:41,500 --> 00:02:42,000
也是

81
00:02:42,000 --> 00:02:43,900
一個集成測試目標，因為它

82
00:02:43,900 --> 00:02:46,533
與多個模塊進行通信

83
00:02:46,533 --> 00:02:49,666
甚至與Feed API後端

84
00:02:49,666 --> 00:02:52,866
外部服務，我們可以添加這

85
00:02:52,866 --> 00:02:54,300
緩存集成測試

86
00:02:54,300 --> 00:02:57,566
在API端對端測試中，或者甚至

87
00:02:57,566 --> 00:02:58,533
將它們合併

88
00:02:58,533 --> 00:03:01,566
在一個新的集成測試目標，我們

89
00:03:01,566 --> 00:03:02,466
可以這樣做

90
00:03:02,466 --> 00:03:05,266
然而我們更喜歡將API和

91
00:03:05,266 --> 00:03:07,033
Cache模塊的集成測試

92
00:03:07,033 --> 00:03:09,333
單獨保留，因為他們旨在解決

93
00:03:09,333 --> 00:03:10,633
不同的問題

94
00:03:10,633 --> 00:03:13,433
並集成不同的組件和

95
00:03:13,433 --> 00:03:14,533
服務

96
00:03:14,533 --> 00:03:18,133
確實，所以讓我們運行測試，確保

97
00:03:18,133 --> 00:03:19,433
一切都好

98
00:03:19,433 --> 00:03:21,733
然後讓我們提交，好的，它建立

99
00:03:21,733 --> 00:03:23,566
成功，測試通過，即使

100
00:03:23,566 --> 00:03:24,700
我們的

101
00:03:24,700 --> 00:03:27,033
沒有進行測試，但這意味著我們有一個乾淨的

102
00:03:27,033 --> 00:03:27,900
目標

103
00:03:27,900 --> 00:03:31,733
我們可以開始工作準確地

104
00:03:31,733 --> 00:03:34,000
添加EssentialFeedCacheIntegration

105
00:03:34,000 --> 00:03:34,766
測試

106
00:03:34,766 --> 00:03:36,933
目標以分隔可能的

107
00:03:36,933 --> 00:03:39,266
效率較慢的緩存集成測試

108
00:03:39,266 --> 00:03:42,533
與快速單元或隔離測試

109
00:03:42,533 --> 00:03:45,433
是的，就是這樣，好的，讓我們從最

110
00:03:45,433 --> 00:03:46,633
簡單的任務開始

111
00:03:46,633 --> 00:03:48,933
我們可以想到的，對我來說，只是試圖

112
00:03:48,933 --> 00:03:51,100
從一個空的緩存中加載

113
00:03:51,100 --> 00:03:53,833
聽起來不錯，所以我們需要創建我們的

114
00:03:53,833 --> 00:03:55,833
LocalFeedLoader，這是系統

115
00:03:55,833 --> 00:03:57,266
正在測試的下層系統。

116
00:03:57,266 --> 00:04:00,066
並執行一個載入操作並期望

117
00:04:00,066 --> 00:04:01,333
收到成功

118
00:04:01,333 --> 00:04:04,766
結果是一個空的圖像陣列

119
00:04:04,766 --> 00:04:06,700
如果我們收到失敗，我們將會失敗

120
00:04:06,700 --> 00:04:09,333
測試將以一個好的錯誤訊息失敗

121
00:04:09,333 --> 00:04:11,900
對，當然現在我們需要導入

122
00:04:11,900 --> 00:04:12,866
EssentialFeed

123
00:04:12,866 --> 00:04:18,133
模組，並且我們需要makeSUT幫助工具

124
00:04:18,133 --> 00:04:19,733
好的，所以測試的系統是

125
00:04:19,733 --> 00:04:22,000
與LocalFeedLoader共同合作還有

126
00:04:22,000 --> 00:04:22,866
CoreData

127
00:04:22,866 --> 00:04:25,666
FeedStore，與緩存集成測試相比的大不同是

128
00:04:25,666 --> 00:04:27,100
和CoreData隔離測試的區別是

129
00:04:27,100 --> 00:04:30,000
現在我們使用的是

130
00:04:30,000 --> 00:04:31,033
真正的File系統URL來保存

131
00:04:31,033 --> 00:04:34,633
我們的CoreData模組，這即是說

132
00:04:34,633 --> 00:04:38,000
我們使用的不是在CoreDataFeedStore中使用的手段，也即我們

133
00:04:38,000 --> 00:04:40,300
在內存中操作的/dev/null

134
00:04:40,300 --> 00:04:42,300
這會是在記憶體中運作的這

135
00:04:42,300 --> 00:04:43,666
是的，因為在這種情況下，我們希望打擊

136
00:04:43,666 --> 00:04:45,733
磁碟

137
00:04:45,733 --> 00:04:46,800
我們希望證實我們實際上

138
00:04:46,800 --> 00:04:49,500
創建的就是我們需要的

139
00:04:49,500 --> 00:04:50,300
正在創建

140
00:04:50,300 --> 00:04:53,600
人工製品，狀態，確實

141
00:04:53,600 --> 00:04:55,500
我們會從高

142
00:04:55,500 --> 00:04:56,933
層次的抽象化

143
00:04:56,933 --> 00:04:59,833
一直到最具體的基礎設施

144
00:04:59,833 --> 00:05:00,700
細節

145
00:05:00,700 --> 00:05:02,800
並驗證整條鏈路都能正常運作

146
00:05:02,800 --> 00:05:04,800
一起做出來真的太棒了

147
00:05:04,800 --> 00:05:06,700
但我們在建構過程中出現了一些錯誤，這條

148
00:05:06,700 --> 00:05:08,700
追蹤記憶體洩漏的

149
00:05:08,700 --> 00:05:11,333
目標在此不可見，因為

150
00:05:11,333 --> 00:05:13,900
它處在一個獨立的目標中

151
00:05:13,900 --> 00:05:16,133
我們可以把這個檔案加入到整合

152
00:05:16,133 --> 00:05:17,433
測試的目標中

153
00:05:17,433 --> 00:05:19,600
就像我們對API端到端

154
00:05:19,600 --> 00:05:22,300
測試一樣

155
00:05:22,300 --> 00:05:26,066
這樣應該就可以了，讓我們來執行測試

156
00:05:26,066 --> 00:05:27,733
通過了，但我想看到一個

157
00:05:27,733 --> 00:05:29,100
失敗的測試

158
00:05:29,100 --> 00:05:30,700
所以我們可以改變CoreDataFeedStore的

159
00:05:30,700 --> 00:05:32,533
實現方式

160
00:05:32,533 --> 00:05:35,333
例如讓它回傳一個錯誤

161
00:05:35,333 --> 00:05:37,166
只是為了製造出一個異常行為

162
00:05:37,166 --> 00:05:39,433
那應該會產生一個失敗的測試

163
00:05:39,433 --> 00:05:40,866
做出來了

164
00:05:40,866 --> 00:05:43,433
它成功地證明了我們的測試

165
00:05:43,433 --> 00:05:44,300
正在測試一些事情

166
00:05:44,300 --> 00:05:47,500
棒極了，讓我們撤銷這個更改，再次運行

167
00:05:47,500 --> 00:05:49,500
測試

168
00:05:49,500 --> 00:05:53,433
運行成功，真棒，讓我們提交

169
00:05:53,433 --> 00:05:55,500
但我們這裡做了兩件事，一是我們

170
00:05:55,500 --> 00:05:56,633
新增了這個測試

171
00:05:56,633 --> 00:05:58,633
二是我們在整合測試目標中加入了內存洩漏

172
00:05:58,633 --> 00:06:00,866
輔助器

173
00:06:00,866 --> 00:06:02,233
所以我希望能將這兩項分開

174
00:06:02,233 --> 00:06:04,066
提交，對，我喜歡那樣

175
00:06:04,066 --> 00:06:06,000
首先，我們只提交內存洩漏

176
00:06:06,000 --> 00:06:07,500
目標會員變更

177
00:06:07,500 --> 00:06:09,666
所以包含內存洩漏追蹤輔助器

178
00:06:09,666 --> 00:06:12,000
在緩存整合測試目標中

179
00:06:12,000 --> 00:06:15,033
然後我們可以提交測試，所以 Local

180
00:06:15,033 --> 00:06:15,733
FeedLoader

181
00:06:15,733 --> 00:06:17,500
與 CoreDataFeed 的整合

182
00:06:17,500 --> 00:06:19,666
Store 不會提供任何項目

183
00:06:19,666 --> 00:06:22,866
空的緩存，好極了，我喜歡我們怎麼

184
00:06:22,866 --> 00:06:24,300
在消息中加入

185
00:06:24,300 --> 00:06:26,933
兩個協作的組件

186
00:06:26,933 --> 00:06:28,066
LocalFeedLoader

187
00:06:28,066 --> 00:06:29,733
與 CoreData 的協作

188
00:06:29,733 --> 00:06:31,900
FeedStore，所以我們不僅僅是在測試

189
00:06:31,900 --> 00:06:32,700
行為

190
00:06:32,700 --> 00:06:34,400
我們要確保我們的

191
00:06:34,400 --> 00:06:36,400
談論特定的組件

192
00:06:36,400 --> 00:06:39,433
與其他組件精確結合

193
00:06:39,433 --> 00:06:42,633
好的，第二個測試，如果我們有

194
00:06:42,633 --> 00:06:43,900
已緩存的東西

195
00:06:43,900 --> 00:06:46,466
所以我們在硬碟裡有物件，對，我們

196
00:06:46,466 --> 00:06:49,266
應該可以讀取這些項目

197
00:06:49,266 --> 00:06:52,633
so the load method should deliver items
因此，load 方法應該能交付項目

198
00:06:52,633 --> 00:06:55,333
saved on separate instances proving that
保存在分開的實例上，證明了

199
00:06:55,333 --> 00:06:57,266
we are storing things to disk
我們正在把東西儲存到磁盤中

200
00:06:57,266 --> 00:06:59,166
and another instance can fetch that data
並且另一個實例可以獲取該數據

207
00:07:12,066 --> 00:07:14,166
specifically for each operation storing and
特定於每個操作，儲存與

208
00:07:14,166 --> 00:07:16,233
loading from the document directory and
從文件目錄加載和存儲，

209
00:07:16,233 --> 00:07:18,233
the fact that this is working indicates
這個事實表明是有效的

210
00:07:18,233 --> 00:07:20,233
that there is some persistent storage
表示存在某種持久存儲

211
00:07:20,233 --> 00:07:22,966
going on across application runs which is
正在跨應用程式執行，這是

212
00:07:22,966 --> 00:07:24,866
what we want
我們想要的

207
00:07:12,066 --> 00:07:14,800
特定於每次儲存和
特異於每個操作的保存和

208
00:07:14,800 --> 00:07:15,500
加載
加載

209
00:07:15,500 --> 00:07:18,233
單元測試中我們沒有這個
我們在單元測試中沒有這個

210
00:07:18,233 --> 00:07:18,700
那是核心
那個Core

211
00:07:18,700 --> 00:07:21,733
數據單元測試使用內存中的
數據單元測試使用內存中的

212
00:07:21,733 --> 00:07:23,566
數據的表示形式
數據表示法

213
00:07:23,566 --> 00:07:26,533
所以有兩個實例將會產生
因此，有兩個實例將生成

214
00:07:26,533 --> 00:07:27,733
兩個獨立的
兩個分開的

215
00:07:27,733 --> 00:07:31,033
memory spaces completely isolated now in
記憶體空間現在完全隔離在

216
00:07:31,033 --> 00:07:33,100
integration we can actually save data to
整合中，我們實際上能儲存數據到

217
00:07:33,100 --> 00:07:33,733
disk
磁碟上

218
00:07:33,733 --> 00:07:35,566
and use another instance to fetch it
並用另一個實例來取得它

219
00:07:35,566 --> 00:07:37,900
proving that the whole caching dance
證明整個快取流程

220
00:07:37,900 --> 00:07:40,933
works accordingly, exactly, so to run this
完全能按照設定來運作，所以要執行這個

221
00:07:40,933 --> 00:07:41,566
test
測試

222
00:07:41,566 --> 00:07:44,400
我們有一個sut實例來執行
我們有一個sut實例來執行

223
00:07:44,400 --> 00:07:46,700
儲存並希望進行加載
儲存並希望進行加載

224
00:07:46,700 --> 00:07:48,633
首先我們儲存並等待儲存
首先我們儲存並等待儲存

225
00:07:48,633 --> 00:07:50,700
完成然後我們加載
完成然後我們加載

226
00:07:50,700 --> 00:07:52,633
然後我們檢查我們是否得到了確切的
然後我們檢查我們是否得到了確切的

227
00:07:52,633 --> 00:07:53,733
我們儲存的相同feed
我們儲存的相同feed


228
00:07:53,733 --> 00:07:56,000
與另一個實例，但我們正在使用

229
00:07:56,000 --> 00:07:56,800
助手

230
00:07:56,800 --> 00:08:00,000
也在一個單獨的目標中，所以我們

231
00:08:00,000 --> 00:08:01,733
也需要添加這個Feed Cache的測試

232
00:08:01,733 --> 00:08:02,466
助手

233
00:08:02,466 --> 00:08:04,300
至Feed Cache的集成測試

234
00:08:04,300 --> 00:08:06,233
目標中

235
00:08:06,233 --> 00:08:09,166
但這個文件使用了一個存在於

244
00:08:26,933 --> 00:08:29,900
shared test helpers in integration test
將共享測試輔助者包含在集成測試中

245
00:08:29,900 --> 00:08:32,300
so now remember
所以現在要記住

246
00:08:32,300 --> 00:08:35,066
we have to strategies here
我們在這裡有兩種策略

247
00:08:35,066 --> 00:08:38,333
we can either duplicate our test helpers
我們可以複製我們的測試輔助者

248
00:08:38,333 --> 00:08:40,400
or we can share them
或者我們可以分享它們

249
00:08:40,400 --> 00:08:44,233
if we share them we have to be careful
如果我們分享它們，我們必須謹慎

250
00:08:44,233 --> 00:08:46,300
with iOS symbols
對於iOS符號

251
00:08:46,300 --> 00:08:49,900
because sometimes iOS symbols can cause
因為有時候iOS符號可能會引起

252
00:08:49,900 --> 00:08:52,933
tests to fail
測試會失敗

244
00:08:26,933 --> 00:08:28,400
快取測試輔助器

245
00:08:28,400 --> 00:08:30,800
在快取整合測試目標中

246
00:08:30,800 --> 00:08:32,466
就是這樣

247
00:08:32,466 --> 00:08:36,000
讓我們再跑一次測試，哦

248
00:08:36,000 --> 00:08:39,333
測試失敗，好的，第一個測試失敗了

249
00:08:39,333 --> 00:08:42,066
這是為什麼呢，藝術品，我們正在離開

250
00:08:42,066 --> 00:08:43,333
Core Data藝術品

測試之前清理狀態

257
00:08:56,533 --> 00:08:59,333
each test?
對每個測試進行狀態清理？

257
00:08:56,533 --> 00:08:57,600
each test run
每次測試運行

258
00:08:57,600 --> 00:08:59,266
and we can do that with the setUp and
我們可以透過setUp和

259
00:08:59,266 --> 00:09:00,633
tearDown methods
tearDown方法來完成

260
00:09:00,633 --> 00:09:02,700
as we've done before in the setUp we set
如同我們在setUp中先前做過的，我們設定

261
00:09:02,700 --> 00:09:03,733
up an empty store
一個空的儲存區域

262
00:09:03,733 --> 00:09:06,133
in the tearDown we undo the store side
在tearDown，我們撤銷儲存區域側邊

263
00:09:06,133 --> 00:09:07,266
effects
的影響

264
00:09:07,266 --> 00:09:10,700
so let's add the test helpers simply
所以讓我們簡單地增加測試助手

265
00:09:10,700 --> 00:09:13,333
removing the file from disk let's run
從硬碟移除檔案後，讓我們執行

266
00:09:13,333 --> 00:09:14,933
again
再執行一次

267
00:09:14,933 --> 00:09:17,200
it's passing let's run again just to
它通過了，讓我們再執行一次以便

268
00:09:17,200 --> 00:09:18,800
make sure it's still passing
確認它還是通過

269
00:09:18,800 --> 00:09:22,633
okay run a couple of times it is passing
好的，執行幾次後，它通過了

270
00:09:22,633 --> 00:09:24,300
但再一次，我們在這裡做了兩件事

271
00:09:24,300 --> 00:09:26,233
我們添加了副作用清理

272
00:09:26,233 --> 00:09:28,000
同時也加入了測試，所以我們可以將此

273
00:09:28,000 --> 00:09:29,833
分成兩個提交

274
00:09:29,833 --> 00:09:31,666
我想指出，我們正在

275
00:09:31,666 --> 00:09:33,833
見證一種新興模式的出現

276
00:09:33,833 --> 00:09:36,066
我們被迫做兩件或更多事情

277
00:09:36,066 --> 00:09:37,733
這是因為所有的合作

278
00:09:37,733 --> 00:09:39,833
與我們使用的所有組件的交互進行

279
00:09:39,833 --> 00:09:40,866
是的

280
00:09:40,866 --> 00:09:43,666
確切地說，當我們隔離組件時，我們

281
00:09:43,666 --> 00:09:45,733
也需要付出整合它們的成本

282
00:09:45,733 --> 00:09:47,600
如果我們管理得不好，我們可能會

283
00:09:47,600 --> 00:09:49,033
create a mess in the codebase
在代碼庫中製造混亂

284
00:09:49,033 --> 00:09:52,000
yes so let's first commit the store side
是的，所以我們先提交存儲端

285
00:09:52,000 --> 00:09:52,633
effects
的影響

286
00:09:52,633 --> 00:09:54,800
cleanup and then we complete the test
清理，然後我們完成測試

287
00:09:54,800 --> 00:09:55,833
sounds good
聽起來不錯

288
00:09:55,833 --> 00:09:58,633
so clean up and undo all cache side
所以清理並撤銷所有快取端

289
00:09:58,633 --> 00:09:59,333
effects
的影響

290
00:09:59,333 --> 00:10:01,900
on setUp and tearDown to avoid sharing
在設置和拆卸時避免共享

291
00:10:01,900 --> 00:10:02,700
state
狀態

292
00:10:02,700 --> 00:10:05,833
between tests
在測試之間

293
00:10:05,833 --> 00:10:08,533
now we can commit the tests so LocalFeed
現在我們可以提交測試以便 LocalFeed

294
00:10:08,533 --> 00:10:10,700
Loader in integration with the Core Data
Loader 與 Core Data 的整合

295
00:10:10,700 --> 00:10:11,433
FeedStore
FeedStore

296
00:10:11,433 --> 00:10:13,733
delivers items saved on separate 
可以提供儲存在不同

297
00:10:13,733 --> 00:10:14,700
instances
實例的項目

298
00:10:14,700 --> 00:10:16,933
proving we correctly persist the data
證明我們將數據正確持久化

299
00:10:16,933 --> 00:10:18,300
models to disk
模型保存至磁盤

300
00:10:18,300 --> 00:10:21,200
that's it and again I really like how we
就是這樣，再次感叹，我真的很喜歡我們的做法

301
00:10:21,200 --> 00:10:22,800
提到了 LocalFeedLoader

302
00:10:22,800 --> 00:10:24,366
並且與 CoreDataFeed

303
00:10:24,366 --> 00:10:26,866
Store 進行整合，我們已經產生了一些重複性的內容

304
00:10:26,866 --> 00:10:30,466
把 load 方法作為例子，理想狀況而言，

305
00:10:30,466 --> 00:10:31,666
我們應該設有一個 expect

306
00:10:31,666 --> 00:10:34,066
的方法，可以如同我們在其他

307
00:10:34,066 --> 00:10:35,600
課程中進行的方式重複使用

308
00:10:35,600 --> 00:10:38,533
like expect the sut to load an empty
像是預期sut載入一個空的

309
00:10:38,533 --> 00:10:40,233
array of images
影像的陣列

310
00:10:40,233 --> 00:10:42,300
exactly despite these being integration
儘管這些是整合測試

311
00:10:42,300 --> 00:10:43,900
tests the refactoring rules
重構規則依然適用於此

312
00:10:43,900 --> 00:10:46,700
of course apply here as well, exactly we
當然，我們也應該在這裡

313
00:10:46,700 --> 00:10:48,533
should have the same level of care
投入同級別的關懷和照護

314
00:10:48,533 --> 00:10:51,033
不論是否為整合測試，
無論是集成測試

315
00:10:51,033 --> 00:10:51,833
單元測試，

316
00:10:51,833 --> 00:10:54,133
隔離測試或生產代碼，

317
00:10:54,133 --> 00:10:55,833
都是我們必須維護的代碼，

318
00:10:55,833 --> 00:10:58,133
我們應該對整個代碼庫持有高標準，

319
00:10:58,133 --> 00:10:59,266
就整個代碼庫來說。

320
00:10:59,266 --> 00:11:02,066
絕對如此，所以這另一個載入操作。

地方看到失敗

328
00:11:16,933 --> 00:11:20,500
context cutoff should be the file and line
切斷應為檔案以及行數

329
00:11:20,500 --> 00:11:23,100
at the call site not just in the helper
在調用位置，而非僅在助手中

330
00:11:23,100 --> 00:11:26,433
this way we can click on the failure
這樣我們可以點擊失敗

331
00:11:26,433 --> 00:11:29,733
and it will navigate to the proper test
並會導航到正確的測試

332
00:11:29,733 --> 00:11:33,033
location and it's so easy to fix
位置，這樣修復簡單多了。

328
00:11:16,933 --> 00:11:20,300
位置，讓我們運行測試

329
00:11:20,300 --> 00:11:23,433
成功，讓我們提交並提取

330
00:11:23,433 --> 00:11:26,633
將重複的加載預期轉移到

331
00:11:26,633 --> 00:11:29,266
共享的輔助方法之中

332
00:11:29,266 --> 00:11:31,266
因此，我們已經證明我們可以從空白的

333
00:11:31,266 --> 00:11:33,200
緩存中加載，我們已證明我們可以載入

334
00:11:33,200 --> 00:11:35,200
從一個非空的快取中加載，即使是
從非空的高速緩存中加載，即使是

335
00:11:35,200 --> 00:11:37,200
created by a separate instance
由單獨的實例創建的

336
00:11:37,200 --> 00:11:39,433
the last test we need is to prove that
我們需要進行的最後一個測試是為了證明

337
00:11:39,433 --> 00:11:40,700
we can override
我們可以覆蓋

338
00:11:40,700 --> 00:11:43,733
the items and disk that were saved by a
由一個單獨的實例保存到磁盤的項目

339
00:11:43,733 --> 00:11:45,333
separate instance
單獨的實例

340
00:11:45,333 --> 00:11:48,366
and again we have multiple system under
再次，我們在這裡有多個系統正在

341
00:11:48,366 --> 00:11:49,833
test instances here
這裡進行多個實章測試

342
00:11:49,833 --> 00:11:53,033
each one for each specific operation so
每一個操作都有一個特定的實例，

343
00:11:53,033 --> 00:11:55,833
an sut to perform the first save another

344
00:11:55,833 --> 00:11:57,200
one to perform the last save
一個來執行最後的儲存，

345
00:11:57,200 --> 00:11:58,800
and another one to perform the load so
還有一個來執行載入，

346
00:11:58,800 --> 00:12:00,233
we have three objects
所以我們有三個對象

347
00:12:00,233 --> 00:12:02,233
在這裡與File system進行互動

348
00:12:02,233 --> 00:12:03,600
並且有兩種模式來儲存

349
00:12:03,600 --> 00:12:05,433
分別是第一個和最新的，它們是

350
00:12:05,433 --> 00:12:07,500
如果你比較它們，它們確實是獨一無二的

351
00:12:07,500 --> 00:12:10,133
所以它們是不同的，因此我們再次想要

352
00:12:10,133 --> 00:12:11,033
保證

353
00:12:11,033 --> 00:12:12,933
元件之間的協作

354
00:12:12,933 --> 00:12:14,233
within the whole stack
在整個堆疊中

355
00:12:14,233 --> 00:12:17,333
exactly so first we save with the
確實如此，我們首先用

356
00:12:17,333 --> 00:12:20,133
sut to perform the first save then we
sut 來進行第一次保存，然後我們

357
00:12:20,133 --> 00:12:20,866
save
保存

358
00:12:20,866 --> 00:12:23,333
another feed with the sut to perform the
用sut保存另一個feed以執行

359
00:12:23,333 --> 00:12:24,233
last save
最後一次保存

360
00:12:24,233 --> 00:12:27,200
and then we expect to load the latest
然後我們預期載入最新的

361
00:12:27,200 --> 00:12:27,500
one
一個

362
00:12:27,500 --> 00:12:29,200
不是第一個或不是空的
不是第一個或不是空的

363
00:12:29,200 --> 00:12:31,200
最新一個
最新一個

364
00:12:31,200 --> 00:12:34,466
讓我們進行測試
讓我們進行測試

365
00:12:34,466 --> 00:12:37,600
很棒，讓我們提交
很棒，讓我們提交

366
00:12:37,600 --> 00:12:39,666
所以在 LocalFeedLoader 與 CoreDataFeedStore 的整合
所以在 LocalFeedLoader 與 CoreDataFeedStore 的整合下

367
00:12:39,666 --> 00:12:41,433
讓 CoreDataFeedStore
讓 CoreDataFeedStore

368
00:12:41,433 --> 00:12:44,233
覆蓋了由各個例項儲存的項目
覆蓋了由各個例項儲存的項目

369
00:12:44,233 --> 00:12:45,033
證明我們正確的管理了數據
證明我們正確的管理了數據

370
00:12:45,033 --> 00:12:47,200
讓我們確認可以正確管理數據
讓我們確認可以正確管理數據

371
00:12:47,200 --> 00:12:48,700
models on disk
在磁碟上的模型

372
00:12:48,700 --> 00:12:50,933
that's it now that we have all this
就是這樣，現在我們有了所有這些

373
00:12:50,933 --> 00:12:52,300
duplicate save
重複儲存

374
00:12:52,300 --> 00:12:55,266
methods yeah we could also extract them
的方法，對，我們也可以提取它們

375
00:12:55,266 --> 00:12:57,100
into helpers
變成輔助工具

376
00:12:57,100 --> 00:13:00,700
save feed with the sut to perform save
用sut儲存飼料，來執行儲存

377
00:13:00,700 --> 00:13:02,466
that sounds wonderful and in this other
這聽起來很棒，在這個其他方面

的helper，

386
00:13:18,800 --> 00:13:20,666
believes that instead of defining a new
我們相信，與其定義一個新的

387
00:13:20,666 --> 00:13:24,933
sut every time we can have this helper that
每次都要定義sut，我們可以有這個helper，

388
00:13:24,933 --> 00:13:27,066
takes as a parameter the item to be saved
作為參數去保存項目，

389
00:13:27,066 --> 00:13:30,866
and the sut itself this would save a lot
還有sut本身，這會節省很多

390
00:13:30,866 --> 00:13:34,533
of time and ensure consistency across all
的時間，並確保整體的一致性，

391
00:13:34,533 --> 00:13:36,200
different parts of the code
程式碼的不同部分。

386
00:13:18,800 --> 00:13:20,366
created the expectation
創建了期望

387
00:13:20,366 --> 00:13:23,266
we save the feed with the given loader
我們用給定的加載器儲存feed

388
00:13:23,266 --> 00:13:24,133
and we wait
然後我們等待

389
00:13:24,133 --> 00:13:27,333
until the save operation has finished
直到儲存操作完成

390
00:13:27,333 --> 00:13:30,533
let's run the tests it's passing ok
我們來運行測試，好的，它通過了

391
00:13:30,533 --> 00:13:33,600
let's commit so extract
我們進行提交，然後提取

392
00:13:33,600 --> 00:13:36,466
duplicate save operation into a shared
重複的儲存操作變為共享

393
00:13:36,466 --> 00:13:38,633
helper method
輔助方法

394
00:13:38,633 --> 00:13:41,600
好的，我們完成了整合測試

395
00:13:41,600 --> 00:13:42,933
看起來我們只接觸了

396
00:13:42,933 --> 00:13:43,666
順利的路徑

397
00:13:43,666 --> 00:13:46,300
那麼錯誤的情況呢，好的，我們正在

398
00:13:46,300 --> 00:13:46,866
進行測試

399
00:13:46,866 --> 00:13:49,100
在元件層面上處理所有可能的情況，

400
00:13:49,100 --> 00:13:50,633
在單元階段或者

401
00:13:50,633 --> 00:13:53,900
獨立測試。否則，

402
00:13:53,900 --> 00:13:56,233
如果我們要在
如果我們在

403
00:13:56,233 --> 00:13:57,333
整合測試中
整合測試中

404
00:13:57,333 --> 00:13:59,266
測試所有邊緣案例
測試所有的邊緣案例

405
00:13:59,266 --> 00:14:00,466
案例的數量會以
案例數量將會以

406
00:14:00,466 --> 00:14:02,066
指數方式增加
指數的方式增加

407
00:14:02,066 --> 00:14:03,833
這取決於參與整合的
這取決於參與整合的

408
00:14:03,833 --> 00:14:04,233
元件數量，對吧？
元件數量，對吧？

409
00:14:04,233 --> 00:14:06,533
組件數量越多，測試與邊際情況就越多

410
00:14:06,533 --> 00:14:07,733
更多的邊際情況

411
00:14:07,733 --> 00:14:10,700
但如果你在單元中測試邊際情況
當你將它們組合在一起時

412
00:14:10,700 --> 00:14:12,300
你只需要測試快樂路徑，對吧？
例如，我不能在整體結構級別強制產生錯誤，但是我

413
00:14:12,300 --> 00:14:15,166
你只能測試快樂路徑對吧
可以在單元層級模擬錯誤，我們已經

414
00:14:15,166 --> 00:14:17,033
例如我不能強制
這樣做過了。例如，在整合階段中我無法強制

415
00:14:17,033 --> 00:14:19,333
在整合級別產生一個錯誤，但是我
產生錯誤，但我可以在單元層級模擬

416
00:14:19,333 --> 00:14:20,300
可以模擬
錯誤，而我們已經

417
00:14:20,300 --> 00:14:23,500
an error in the unit level and we have
在單元層級出錯，我們已經

418
00:14:23,500 --> 00:14:24,466
done it
完成了它

419
00:14:24,466 --> 00:14:27,100
exactly here on the integration level we
確切地說，在這裡的整合層級，我們

420
00:14:27,100 --> 00:14:28,000
are not using
並不使用

421
00:14:28,000 --> 00:14:30,633
any mocks or test doubles we're using
任何模擬或測試替身，我們使用的是

422
00:14:30,633 --> 00:14:31,033
real
真正的

423
00:14:31,033 --> 00:14:34,533
components yes and if you move all your
組件，確實。如果你將所有的

424
00:14:34,533 --> 00:14:35,433
tests
測試

425
00:14:35,433 --> 00:14:37,333
至於那種會導致
測試範圍過於龐大

426
00:14:37,333 --> 00:14:39,900
結果可能是無法維護數量的
導致無法維護的測試數量

427
00:14:39,900 --> 00:14:43,266
測試以及非常緩慢的測試時間，確實
和非常慢的測試時間 是的

428
00:14:43,266 --> 00:14:46,066
我們不建議，絕對不建議
我們絕對不建議這種情況

429
00:14:46,066 --> 00:14:47,500
而且還存在其他問題
並且還有其他的問題

430
00:14:47,500 --> 00:14:49,900
只在整合級別進行測試時
在僅在整合級別進行測試時

438
00:15:02,366 --> 00:15:04,166
also do system level tests
也進行系統級測試

439
00:15:04,166 --> 00:15:07,766
It's not either or situation it's always
這不是二擇一的情況，總是

440
00:15:07,766 --> 00:15:10,733
about finding the balance and being aware
關於找到平衡並且要清楚

441
00:15:10,733 --> 00:15:12,766
of the risk that you have
你所承受的風險

442
00:15:12,766 --> 00:15:14,900
so that was the tip for the day
所以這就是今天的建議

443
00:15:14,900 --> 00:15:17,566
I hope you enjoyed it and I'll see you
希望你喜歡它，我們下次見

444
00:15:17,566 --> 00:15:18,866
next time
再見

438
00:15:02,366 --> 00:15:04,233
只做整合測試

439
00:15:04,233 --> 00:15:06,000
你可能兩者都需要，但絕大多數應該是單元測試

440
00:15:06,000 --> 00:15:07,900
絕大多數應該是單元測試

441
00:15:07,900 --> 00:15:09,666
那里有所有的邊緣案例

442
00:15:09,666 --> 00:15:11,033
整合所有的元件

443
00:15:11,033 --> 00:15:12,633
並看看它們合在一起時的行為

444
00:15:12,633 --> 00:15:14,700
將給予你足夠的信心去行動
將給予你足夠的信心去行動

445
00:15:14,700 --> 00:15:18,366
快速並且我們希望能夠快速無疑地移動
快速並且我們希望能夠快速無疑地移動

446
00:15:18,366 --> 00:15:21,600
因此再說一次，我們並未在
因此再說一次，我們並未在

447
00:15:21,600 --> 00:15:22,633
這些測試中模擬任何東西
這些測試中模擬任何東西

448
00:15:22,633 --> 00:15:24,533
我們已經證明了元件獨立運作是可行的
我們已經證明了元件獨立運作是可行的

449
00:15:24,533 --> 00:15:27,100
因此在此使用mocks
因此在此使用mocks

450
00:15:27,100 --> 00:15:29,833
並沒有太大的價值，我們還有
沒有多大價值，我們還有

451
00:15:29,833 --> 00:15:30,933
其他的作法
可做的事

452
00:15:30,933 --> 00:15:33,666
就是直接將CoreDataFeed
就是將CoreDataFeed

453
00:15:33,666 --> 00:15:35,266
Store替換成Codable
Store換成Codable

454
00:15:35,266 --> 00:15:39,433
FeedStore，這樣也應該可以運作
FeedStore，應該也可以運作。

455
00:15:39,433 --> 00:15:43,333
讓我們運行測試，成功了
讓我們進行測試，成功了。

456
00:15:43,333 --> 00:15:45,600
這真的太神奇了，而這是可行的
這實在太驚人了，這是可能的。

457
00:15:45,600 --> 00:15:47,433
因為我們應用了強大的

458
00:15:47,433 --> 00:15:48,366
原則，

459
00:15:48,366 --> 00:15:51,433
如依賴反轉、Liskov

460
00:15:51,433 --> 00:15:52,700
替換原則，

461
00:15:52,700 --> 00:15:54,800
接口分離原則，

462
00:15:54,800 --> 00:15:56,300
依賴注入，

463
00:15:56,300 --> 00:15:58,300
以及我們所學過的所有原則。

464
00:15:58,300 --> 00:16:00,066
基本上就是這樣。

465
00:16:00,066 --> 00:16:02,366
因此，我們有兩種實作方式。

466
00:16:02,366 --> 00:16:03,100
that behave
那種行為

467
00:16:03,100 --> 00:16:05,833
exactly the same even though they use
即使他們使用的是，這種行為完全相同

468
00:16:05,833 --> 00:16:07,266
completely different
完全不同

469
00:16:07,266 --> 00:16:10,466
frameworks behind the scenes but
幕後的框架，但是

470
00:16:10,466 --> 00:16:12,300
since we have those two FeedStore
既然我們有兩個FeedStore

471
00:16:12,300 --> 00:16:13,600
implementations
實現，

472
00:16:13,600 --> 00:16:15,333
and we just need one for this
而我們只需要這其中一個

473
00:16:15,333 --> 00:16:17,600
application I think we can get rid of
應用程式，我想我們可以去掉

474
00:16:17,600 --> 00:16:18,466
one of them
其中一個

475
00:16:18,466 --> 00:16:20,000
and I believe we should keep the Core
我相信我們應該保持 Core

476
00:16:20,000 --> 00:16:22,300
Data one since it's a more

477
00:16:22,300 --> 00:16:25,733
robust solution yeah I agree exploring
強壯的解決方法，對，我同意探討

478
00:16:25,733 --> 00:16:26,466
Core Data
Core Data

479
00:16:26,466 --> 00:16:28,466
in future lectures will be much more
在未來的課程中將會更有

480
00:16:28,466 --> 00:16:29,900
valuable so
價值，所以

481
00:16:29,900 --> 00:16:31,433
we can discard the CodableFeedStore
我們可以捨棄 CodableFeedStore

482
00:16:31,433 --> 00:16:33,033
for now
對於現在來說

483
00:16:33,033 --> 00:16:34,700
okay I'm removing the production and
好的，我正在移除生產並且

484
00:16:34,700 --> 00:16:36,066
test code
測試代碼

485
00:16:36,066 --> 00:16:37,733
for the CodableFeedStore
關於CodableFeedStore的

486
00:16:37,733 --> 00:16:39,833
implementation and of course if we want
實施，當然，如果我們想要

487
00:16:39,833 --> 00:16:41,666
to bring back the CodableFeedStore we
帶回CodableFeedStore，我們

488
00:16:41,666 --> 00:16:43,833
can do so easily as it will always be in
可以輕易地做到，因為它會永遠存在於

489
00:16:43,833 --> 00:16:45,733
the git history of our repository
我們的倉庫的git歷史中

490
00:16:45,733 --> 00:16:49,333
讓我們運行測試，看看是否通過，我們也可以試
讓我們運行測試，通過，讓我們也

491
00:16:49,333 --> 00:16:50,066
運行一下
運行

492
00:16:50,066 --> 00:16:53,666
EssentialFeedTests，真是太棒了
EssentialFeedTests，太好了

493
00:16:53,666 --> 00:16:57,266
一切皆好，我們先進行提交，然後刪除 Codable
一切順利，讓我們提交刪除 Codable

494
00:16:57,266 --> 00:16:58,233
FeedStore
FeedStore

495
00:16:58,233 --> 00:17:00,800
為了更偏好使用 CoreDataFeedStore，我們
選擇 CoreDataFeedStore，我們

496
00:17:00,800 --> 00:17:02,700
在這個項目中只需要一個版本
只需要一個在這個項目中

497
00:17:02,700 --> 00:17:05,033
如果需要的話，我們可以撤銷這個

498
00:17:05,033 --> 00:17:06,533
commit 和恢復

499
00:17:06,533 --> 00:17:10,133
Codable 的實現，好的

500
00:17:10,133 --> 00:17:11,733
作為最後的更改，我想要

501
00:17:11,733 --> 00:17:15,500
配置 CI scheme

502
00:17:15,500 --> 00:17:18,400
要包含新的 cache integration

503
00:17:18,400 --> 00:17:21,333
測試

504
00:17:21,333 --> 00:17:24,300
並且當然要在

505
00:17:24,300 --> 00:17:26,700
隨機順序中執行測試

506
00:17:26,700 --> 00:17:29,833
好的，讓我們在 CI 中執行這些測試

507
00:17:29,833 --> 00:17:30,400
方案

508
00:17:30,400 --> 00:17:33,666
那應該對所有的目標執行

509
00:17:33,666 --> 00:17:37,500
驗證良好，讓我們提交

510
00:17:37,500 --> 00:17:39,666
所以包含cache integration tests

511
00:17:39,666 --> 00:17:40,533
目標

512
00:17:40,533 --> 00:17:43,100
在 CI 方案中以確保我們建立

513
00:17:43,100 --> 00:17:43,833
並執行

514
00:17:43,833 --> 00:17:46,400
所有的cache integration tests 作為
所有的cache integration tests 作為

515
00:17:46,400 --> 00:17:49,333
the continuous integration pipeline
持續整合管道的一部分

516
00:17:49,333 --> 00:17:52,133
and we are all set okay let's have a
一切都準備就緒，好的，讓我們來看

517
00:17:52,133 --> 00:17:53,100
look at the logs
看看日誌

518
00:17:53,100 --> 00:17:55,900
for test times as you can see the unit
對於測試時間，如你可以看到的單元

519
00:17:55,900 --> 00:17:57,200
tests
測試

520
00:17:57,200 --> 00:18:00,533
55 tests took 0.5 seconds to run
55個測試只花了0.5秒來運行

521
00:18:00,533 --> 00:18:04,233
API 端到端測試用了 2.6
API 端到端測試用了2.6

522
00:18:04,233 --> 00:18:07,266
秒鐘來執行 1 個測試，對並且
秒鐘來執行1個測試，對並且

523
00:18:07,266 --> 00:18:08,633
cache integration tests
cache integration tests

524
00:18:08,633 --> 00:18:10,466
從頭到尾儲存 Core
從頭到尾儲存 Core

525
00:18:10,466 --> 00:18:12,400
Data 的文件到硬碟
Data 的文件到硬碟

526
00:18:12,400 --> 00:18:16,233
3 個測試用了 0.3 秒
3個測試用了0.3秒

527
00:18:16,233 --> 00:18:18,066
所以你可以看到這種方式是無法擴大的
所以你可以看到這種方式是無法擴大的

528
00:18:18,066 --> 00:18:20,400
yeah the more integration tests we add
對，我們增加的整合測試越多

529
00:18:20,400 --> 00:18:22,866
the slower your development process will
你的開發過程會越慢

530
00:18:22,866 --> 00:18:23,733
be
變得越慢

531
00:18:23,733 --> 00:18:26,766
exactly when you see these numbers you
確實，當你看到這些數字時

532
00:18:26,766 --> 00:18:28,766
need to think about the future
你需要對未來有所思考

533
00:18:28,766 --> 00:18:31,900
clearly 0.5 seconds or 0.3 seconds
顯然，0.5秒或者0.3秒

534
00:18:31,900 --> 00:18:34,066
現在看起來不算多，但如你所
 

535
00:18:34,066 --> 00:18:35,266
說的，這個能
 

536
00:18:35,266 --> 00:18:38,133
進行擴展嗎？答案顯然是不可以
 

537
00:18:38,133 --> 00:18:38,700
它無法
 

538
00:18:38,700 --> 00:18:41,433
在大型項目中，不，它會變成
 

539
00:18:41,433 --> 00:18:42,466
一個瓶頸
 

540
00:18:42,466 --> 00:18:45,100
對，然後開發者極可能
 

541
00:18:45,100 --> 00:18:45,600
會停下來


542
00:18:45,600 --> 00:18:48,000
運行測試，我們不希望那樣，不

543
00:18:48,000 --> 00:18:49,500
我們想要單元測試成為
我們希望單元測試成為工作流程的一部分

544
00:18:49,500 --> 00:18:50,133
工作流程的一部分

545
00:18:50,133 --> 00:18:52,233
我們想要每分鐘運行它們好幾次

546
00:18:52,233 --> 00:18:53,900
我們希望不管有多少測試

547
00:18:53,900 --> 00:18:56,233
無論你有多少測試
我們希望它只需要

548
00:18:56,233 --> 00:18:57,666
就是幾秒鐘
確實

549
00:18:57,666 --> 00:18:59,900
當測試開始變成一個瓶頸時
當測試開始成為瓶頸時

550
00:18:59,900 --> 00:19:02,000
我們需要找出加速它的方法
我們需要找到加快的方法

551
00:19:02,000 --> 00:19:04,133
我們在這裡尋找的字就是主動性
我們在尋找的詞匯是積極性

552
00:19:04,133 --> 00:19:05,200
在這裡
在這裡

553
00:19:05,200 --> 00:19:06,766
因此把整合測試與其他分開
所以分離整合測試與

561
00:19:20,766 --> 00:19:23,100
your productivity
你的生產力

562
00:19:23,100 --> 00:19:25,433
see you in the next lecture
下堂課再見

563
00:19:25,433 --> 00:19:26,633
happy coding
編程愉快

561
00:19:20,766 --> 00:19:22,066
your productivity
你的生產力

562
00:19:22,066 --> 00:19:24,766
also continuously measure build and test
也要持續度量建造和測試

563
00:19:24,766 --> 00:19:26,400
times to avoid bottlenecks
時間以避免瓶頸

564
00:19:26,400 --> 00:19:28,533
in the development process and we are
在開發流程中，我們已經完成

565
00:19:28,533 --> 00:19:30,066
done with the Persistence
Persistence模塊，很棒

566
00:19:30,066 --> 00:19:32,700
module awesome we'll see you all in the
我們將在下一堂講座見到大家

567
00:19:32,700 --> 00:19:33,666
next lecture
下次講座見

568
00:19:33,666 --> 00:19:45,833
bye y'all, see ya
再見，我們下次見