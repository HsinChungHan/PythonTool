

1
00:00:01,033 --> 00:00:03,600
嗨 Mike，嘿 Caio，所以在之前的

2
00:00:03,600 --> 00:00:04,133
集

3
00:00:04,133 --> 00:00:06,866
我們已經開始對我們的RemoteFeed

4
00:00:06,866 --> 00:00:07,500
Loader

5
00:00:07,500 --> 00:00:10,000
進行測試驅動，我們已經測試到

6
00:00:10,000 --> 00:00:10,700
溝通

7
00:00:10,700 --> 00:00:13,266
與HTTPClient的部分，對，並且在我們

8
00:00:13,266 --> 00:00:14,000
繼續前

9
00:00:14,000 --> 00:00:15,433
我希望將這些生產性的

10
00:00:15,433 --> 00:00:17,433
代碼移動到生產套件裡頭

11
00:00:17,433 --> 00:00:19,266
取出測試檔案，因為我不

12
00:00:19,266 --> 00:00:21,166
希望一直上下捲動螢幕

13
00:00:21,166 --> 00:00:24,866
來來回回的，對，我們來做它

14
00:00:24,866 --> 00:00:26,933
所以讓我們在生產裡頭

15
00:00:26,933 --> 00:00:28,866
創建一個新的資料夾

16
00:00:28,866 --> 00:00:31,500
我們稱之為 Feed API，這就是

17
00:00:31,500 --> 00:00:32,933
API

18
00:00:32,933 --> 00:00:35,833
讓我們建立一個新檔案RemoteFeed

19
00:00:35,833 --> 00:00:37,433
Loader

20
00:00:37,433 --> 00:00:38,866
現在我們有了一個單獨的檔案，我們

21
00:00:38,866 --> 00:00:40,933
可以在右側窗格打開它

22
00:00:40,933 --> 00:00:43,100
並保持我們的測試在左側窗格，那聽起來

23
00:00:43,100 --> 00:00:44,066
非常好

24
00:00:44,066 --> 00:00:47,333
讓我們現在製造一些額外的空間，讓我們

25
00:00:47,333 --> 00:00:48,866
移動RemoteFeedLoader

26
00:00:48,866 --> 00:00:52,066
將其添加到文件，並讓我們移動客戶端

27
00:00:52,066 --> 00:00:54,766
通訊協議，也就是產品代碼

28
00:00:57,033 --> 00:00:58,466
但是既然這些類型位於一個

29
00:00:58,466 --> 00:01:01,666
獨立的目標中，我們需要導入

30
00:01:01,666 --> 00:01:04,000
我們的EssentialFeed模塊，但這還不夠

31
00:01:04,000 --> 00:01:06,133
因為這些類型是內部的

32
00:01:06,133 --> 00:01:08,233
對，所以我們需要在這裡做出決定

33
00:01:08,233 --> 00:01:09,733
我們是否將公開內部的

34
00:01:09,733 --> 00:01:10,533
類型

35
00:01:10,533 --> 00:01:13,333
在測試中通過使用@testable或者我們

36
00:01:13,333 --> 00:01:15,100
將這些類型公開

37
00:01:15,100 --> 00:01:17,333
並在測試中使用它們，所以如果我們使

38
00:01:17,333 --> 00:01:19,100
這個@testable導入

39
00:01:19,100 --> 00:01:21,100
測試將可以訪問這些文件

40
00:01:21,100 --> 00:01:23,733
對吧

41
00:01:23,733 --> 00:01:25,600
如你所見，它可以成功建立，但是當

42
00:01:25,600 --> 00:01:27,500
可能的話，我喜歡通過公開接口測試我的組件

43
00:01:27,500 --> 00:01:30,000
僅通過公開的介面，所以

44
00:01:30,000 --> 00:01:30,933
我們為何不試著

45
00:01:30,933 --> 00:01:32,533
宣告出所有有意義的公開的話會不會

46
00:01:32,533 --> 00:01:34,466
足夠呢

47
00:01:34,466 --> 00:01:36,700
讓我們首先絕對測試代碼 

48
00:01:36,700 --> 00:01:37,833
首先所有的 protocol

49
00:01:37,833 --> 00:01:40,400
HTTPClient 它可以是 public 因為它

50
00:01:40,400 --> 00:01:41,500
可以被 

51
00:01:41,500 --> 00:01:44,300
外部模塊實現，現在 class

52
00:01:44,300 --> 00:01:45,333
RemoteFeedLoader

53
00:01:45,333 --> 00:01:47,433
也可以被外部模塊使用，所以

54
00:01:47,433 --> 00:01:49,433
將它公開是可以的，而且它可以

55
00:01:49,433 --> 00:01:51,500
甚至被其他模塊創建，所以我們

56
00:01:51,500 --> 00:01:54,000
也可以將 initializer 公開

57
00:01:54,000 --> 00:01:56,366
然後我們有 load 行為，這是

58
00:01:56,366 --> 00:01:57,900
主要行為這

59
00:01:57,900 --> 00:02:00,466
class，所以這也應該是公開的

60
00:02:00,466 --> 00:02:01,266
那麼關於

61
00:02:01,266 --> 00:02:04,000
屬性呢？是的，我喜歡那些私有的

62
00:02:04,000 --> 00:02:04,866
沒人在使用

63
00:02:04,866 --> 00:02:07,433
這些屬性在 class 之外，好的

64
00:02:07,433 --> 00:02:09,666
我們現在可以建立嗎？

65
00:02:09,666 --> 00:02:12,233
是的，這就足夠我們將我們的類型暴露給

66
00:02:12,233 --> 00:02:13,166
外部模塊

67
00:02:13,166 --> 00:02:14,933
並且通過公開的

68
00:02:14,933 --> 00:02:16,400
接口對其進行測試，太棒了

69
00:02:16,400 --> 00:02:20,000
完美，我們想允許這種類型的子類嗎？

70
00:02:20,000 --> 00:02:20,700
這個類型


71
00:02:20,700 --> 00:02:23,033
我們現時並沒有那種使用情境

72
00:02:23,033 --> 00:02:24,066
所以

73
00:02:24,066 --> 00:02:27,033
我很樂意將其定為終結並不允許

74
00:02:27,033 --> 00:02:28,400
subclassing

75
00:02:28,400 --> 00:02:30,700
好，所以通過將其定為終結，我們防止

76
00:02:30,700 --> 00:02:31,566
子類別

77
00:02:31,566 --> 00:02:34,000
這種類型，而我最後一個可以

78
00:02:34,000 --> 00:02:36,300
看到的改變是客戶和

79
00:02:36,300 --> 00:02:38,800
url 的屬性順序，我認為我們可以倒過來

80
00:02:38,800 --> 00:02:39,833
以反映

81
00:02:39,833 --> 00:02:42,400
初始化順序，好，我喜歡

82
00:02:42,400 --> 00:02:42,933
這種方式

83
00:02:42,933 --> 00:02:45,733
對，完美，讓我們運行測試並

84
00:02:45,733 --> 00:02:47,566
提交

85
00:02:47,566 --> 00:02:50,633
好的，它通過了，所以讓我們提交

86
00:02:50,633 --> 00:02:53,666
移動 RemoteFeedLoader 組件到

87
00:02:53,666 --> 00:02:54,400
生產環境

88
00:02:54,400 --> 00:02:57,433
對，現在我們可以同時看到

89
00:02:57,433 --> 00:02:58,933
測試和生產代碼

90
00:02:58,933 --> 00:03:00,700
我喜歡這樣，非常好

91
00:03:00,700 --> 00:03:03,266
還有沒有更多重構的地方，讓我們檢查

92
00:03:03,266 --> 00:03:04,300
我們的測試名稱

93
00:03:04,300 --> 00:03:07,333
命名慣例是 test underscore

94
00:03:07,333 --> 00:03:09,033
我們正在測試的方法和

95
00:03:09,033 --> 00:03:10,933
我們預期的行為


96
00:03:10,933 --> 00:03:13,433
所以 test init 並不會向

97
00:03:13,433 --> 00:03:14,700
URL 

98
00:03:14,700 --> 00:03:17,566
請求資料，所以第二個測試是對 load 

99
00:03:17,566 --> 00:03:18,866
方法和我們期望的行為

100
00:03:18,866 --> 00:03:22,400
從 URL 請求資料，哦，讓我修正

101
00:03:22,400 --> 00:03:22,800
這個

102
00:03:22,800 --> 00:03:27,033
從 URL 請求資料，非常好

103
00:03:27,033 --> 00:03:31,500
所以提高測試名稱，讓我們提交這個

104
00:03:31,500 --> 00:03:34,000
好的，我們現在可以繼續，有一件事

105
00:03:34,000 --> 00:03:35,033
困擾著我

106
00:03:35,033 --> 00:03:36,633
當我在測試兩個對象

107
00:03:36,633 --> 00:03:38,300
像我們使用的一樣協同作業

108
00:03:38,300 --> 00:03:39,333
RemoteFeedLoader

109
00:03:39,333 --> 00:03:41,833
和 HTTPClient，我們並不需要只

110
00:03:41,833 --> 00:03:43,666
測試出現的信息

111
00:03:43,666 --> 00:03:44,300
而是需要測試

112
00:03:44,300 --> 00:03:46,133
信息被調用的次數，

113
00:03:46,133 --> 00:03:48,133
比方說，

114
00:03:48,133 --> 00:03:50,400
如果我無意間調用了這個方法

115
00:03:50,400 --> 00:03:51,200
兩次，

116
00:03:51,200 --> 00:03:53,500
測試將不會失敗，這就是問題所在，

117
00:03:53,500 --> 00:03:54,933
因為這將是

118
00:03:54,933 --> 00:03:56,533
我們意想不到的行為

119
00:03:56,533 --> 00:03:59,733
對的，所以雖然我們在我們的測試中呼叫 load

120
00:03:59,733 --> 00:04:02,700
一次，但在這種情況下，客戶端

121
00:04:02,700 --> 00:04:04,000
被調用了兩次


122
00:04:04,000 --> 00:04:07,266
正是因為我們的間諜在捕獲

123
00:04:07,266 --> 00:04:10,133
被傳遞的值，所以我可以調用

124
00:04:10,133 --> 00:04:11,500
這個方法10次

125
00:04:11,500 --> 00:04:14,066
並且它總是會捕獲最後

126
00:04:14,066 --> 00:04:15,733
傳遞給它的值

127
00:04:15,733 --> 00:04:17,900
所以雖然我們正在斷言我們

128
00:04:17,900 --> 00:04:19,433
傳遞了正確的值，但我們並未

129
00:04:19,433 --> 00:04:21,033
斷言調用的次數

130
00:04:21,033 --> 00:04:22,700
方法被調用了多少次，以及在這個

131
00:04:22,700 --> 00:04:24,800
語境中調用了多少次

132
00:04:24,800 --> 00:04:26,366
這是很重要的，因為我不想

133
00:04:26,366 --> 00:04:28,533
發送大量的API請求

134
00:04:28,533 --> 00:04:30,466
所以我們需要某種機制來

135
00:04:30,466 --> 00:04:32,366
計數被調用的次數

136
00:04:32,366 --> 00:04:35,033
客戶端行為被調用的次數

137
00:04:35,033 --> 00:04:35,900
就是這樣

138
00:04:35,900 --> 00:04:38,300
所以我想從添加一個新的

139
00:04:38,300 --> 00:04:39,833
測試開始

140
00:04:39,833 --> 00:04:42,300
如果我兩次調用加載，我希望加載

141
00:04:42,300 --> 00:04:42,866
請求

142
00:04:42,866 --> 00:04:45,266
兩次，但如果我只調用一次，我希望

143
00:04:45,266 --> 00:04:46,066
只加載

144
00:04:46,066 --> 00:04:49,100
一次，對吧，那麼讓我們添加一個兩次加載，並


145
00:04:49,100 --> 00:04:50,000
它應該發出請求

146
00:04:50,000 --> 00:04:53,266
從URL獲取數據兩次，因此如果我調用

147
00:04:53,266 --> 00:04:56,066
兩次加載，我們需要更好的測試方法

148
00:04:56,066 --> 00:04:56,700
測試

149
00:04:56,700 --> 00:04:58,533
這是被調用了幾次，我們可以

150
00:04:58,533 --> 00:05:00,800
通過添加一個斷言來實現

151
00:05:00,800 --> 00:05:03,433
類似於請求的url的

152
00:05:03,433 --> 00:05:04,533
數量應該為兩個，然後我們在我們的間諜裡添加一個新屬性

153
00:05:04,533 --> 00:05:07,666
對，然後當然了

154
00:05:07,666 --> 00:05:10,866
請求的URL將只反映最後的

155
00:05:10,866 --> 00:05:13,600
被捕獲的url

156
00:05:13,600 --> 00:05:16,633
因為我們關心的是該值，我們也關心次數

157
00:05:16,633 --> 00:05:18,300
因為我們關心的是這個值以及這個值的次數

158
00:05:18,300 --> 00:05:20,233
也對我們關心的次數

159
00:05:20,233 --> 00:05:22,700
調用了多少次

160
00:05:22,700 --> 00:05:26,066
但是有更好的方法

161
00:05:26,066 --> 00:05:27,900
如果我們將所有的

162
00:05:27,900 --> 00:05:29,600
requestedURLs

163
00:05:29,600 --> 00:05:32,466
累積在一個陣列中，那麼我們可以同時測試值

164
00:05:32,466 --> 00:05:33,900
和計數，因為

165
00:05:33,900 --> 00:05:35,600
當我們比較兩個陣列

166
00:05:35,600 --> 00:05:39,100
相等時，我們會同時斷言順序相等

167
00:05:39,100 --> 00:05:42,133
並同時計數，這是一個大優勢

168
00:05:42,133 --> 00:05:43,666
在我看來是一種提升

169
00:05:43,666 --> 00:05:45,100
而且因為這是個新測試我們不需要

170
00:05:45,100 --> 00:05:47,100
打破之前的測試對吧，我們可以

171
00:05:47,100 --> 00:05:48,466
創建一個新屬性

172
00:05:48,466 --> 00:05:51,600
requestedURLs是一個URL的陣列，我們

173
00:05:51,600 --> 00:05:52,533
保留舊的

174
00:05:52,533 --> 00:05:54,300
我們保留舊的，當我們完成時，

175
00:05:54,300 --> 00:05:56,133
我們可以

176
00:05:56,133 --> 00:05:58,700
將舊的測試遷移到這個新的

177
00:05:58,700 --> 00:05:59,500
API

178
00:05:59,500 --> 00:06:01,333
所以我想看到這些失敗的測試

179
00:06:01,333 --> 00:06:03,100
因為我們調用的次數

180
00:06:03,100 --> 00:06:07,033
比必須的要多，而它確實失敗了

181
00:06:07,033 --> 00:06:09,733
完美。如果您刪除多餘的調用，

182
00:06:09,733 --> 00:06:12,300
現在應該通過

183
00:06:12,300 --> 00:06:15,833
它確實如此，所以我們可以在這裡提交

184
00:06:15,833 --> 00:06:19,266
確保我們可以加載超過

185
00:06:19,266 --> 00:06:20,133
一次

186
00:06:20,133 --> 00:06:23,333
完美。很好。現在我們可以遷移

187
00:06:23,333 --> 00:06:24,300
舊的測試

188
00:06:24,300 --> 00:06:26,933
對，所以我們現在可以使用requestedURLs，並且

189
00:06:26,933 --> 00:06:28,233
這裡應該是

190
00:06:28,233 --> 00:06:31,166
只包含一個URL的陣列，以及該URL

191
00:06:31,166 --> 00:06:34,066
應該是同樣被傳遞的

192
00:06:34,066 --> 00:06:36,000
和第一個相反，不是 assert

193
00:06:36,000 --> 00:06:37,433
nil 現在我們可以 assert

194
00:06:37,433 --> 00:06:40,933
真的是 requestedURLs 是空的

195
00:06:40,933 --> 00:06:43,266
這表示沒有訊息被捕捉

196
00:06:43,266 --> 00:06:44,300
很棒

197
00:06:44,300 --> 00:06:48,000
讓我們看看是否能通過，結果它通過了

198
00:06:48,000 --> 00:06:51,166
很好，現在我們可以移除

199
00:06:51,166 --> 00:06:54,866
舊的屬性重新執行測試

200
00:06:54,866 --> 00:06:58,800
哦，好的，讓我們提交簡化

201
00:06:58,800 --> 00:07:02,133
spy 讓我們快速回顧一下

202
00:07:02,133 --> 00:07:04,300
我們將我們的生產代碼移出

203
00:07:04,300 --> 00:07:05,666
測試目標

204
00:07:05,666 --> 00:07:08,000
然後我們改進了我們的斷言，不僅

205
00:07:08,000 --> 00:07:09,333
檢查被捕獲的價值

206
00:07:09,333 --> 00:07:09,900
捕獲

207
00:07:09,900 --> 00:07:12,066
還有多少次它們被

208
00:07:12,066 --> 00:07:14,466
使用陣列捕獲

209
00:07:14,466 --> 00:07:17,100
接下來我們應該開始思考

210
00:07:17,100 --> 00:07:19,033
關於客戶端響應

211
00:07:19,033 --> 00:07:21,266
好極了，感謝你觀看並

212
00:07:21,266 --> 00:07:22,866
我們下次見面

213
00:07:22,866 --> 00:07:34,533
再見大家