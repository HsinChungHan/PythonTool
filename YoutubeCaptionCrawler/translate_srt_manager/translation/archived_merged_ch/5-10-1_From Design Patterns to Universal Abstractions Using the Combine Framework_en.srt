

1
00:00:00,633 --> 00:00:03,100
嗨，Mike，大家好

2
00:00:03,100 --> 00:00:06,466
在這個講座中，Caio將教你如何

3
00:00:06,466 --> 00:00:07,266
重構

4
00:00:07,266 --> 00:00:10,400
這種來自設計模式的組合

5
00:00:10,400 --> 00:00:13,433
以使用到的

6
00:00:13,433 --> 00:00:14,233
Combine

7
00:00:14,233 --> 00:00:18,466
框架來實現通用抽象，為何我們要這麼做呢？

8
00:00:18,466 --> 00:00:19,733
並不是設計模式有何不對

9
00:00:19,733 --> 00:00:22,066
而是有些設計模式

10
00:00:22,066 --> 00:00:24,933
等同於來自類別理論的通用抽象

11
00:00:24,933 --> 00:00:26,633
來自範疇理論

12
00:00:26,633 --> 00:00:29,900
這意味著我們可以無縫地替換

13
00:00:29,900 --> 00:00:31,100
一些設計模式

14
00:00:31,100 --> 00:00:34,300
以内建的Combine運算符

15
00:00:34,300 --> 00:00:36,300
來幫助我們組成我們的應用程式

16
00:00:36,300 --> 00:00:38,233
在組合根部

17
00:00:38,233 --> 00:00:40,233
所以你不需要去開發、維護

18
00:00:40,233 --> 00:00:42,000
並測試你自己的

19
00:00:42,000 --> 00:00:45,433
實現，你可以使用內建的

20
00:00:45,433 --> 00:00:49,433
運算符作為構建塊，太棒了

21
00:00:49,433 --> 00:00:51,600
讓我們開始吧。好，所以目標是要

22
00:00:51,600 --> 00:00:52,633
替換

23
00:00:52,633 --> 00:00:55,033
那些設計模式的實現

24
00:00:55,033 --> 00:00:56,866
成為Combine

25
00:00:56,866 --> 00:01:01,900
讓我們導入Combine

26
00:01:01,900 --> 00:01:03,733
而由於我們不想破壞我們的

27
00:01:03,733 --> 00:01:05,033
現有的程式碼

28
00:01:05,033 --> 00:01:08,133
讓我們一步步來進行

29
00:01:08,133 --> 00:01:10,700
創建一個工廠方法來創建

30
00:01:10,700 --> 00:01:14,066
遠程 feed loader 配合

31
00:01:14,066 --> 00:01:17,500
本地的備用選項

32
00:01:17,500 --> 00:01:21,033
但我們不是要返回一個 FeedLoader

33
00:01:21,033 --> 00:01:24,000
我們希望返回的是一個 Combine Publisher

34
00:01:24,000 --> 00:01:25,100
這個 Combine Publisher會產生

35
00:01:25,100 --> 00:01:28,300
確切的與 FeedLoader 相同的產出，所以在

36
00:01:28,300 --> 00:01:28,933
這種情況下

37
00:01:28,933 --> 00:01:32,133
FeedLoader 產生的結果類型

38
00:01:32,133 --> 00:01:35,266
是 FeedImage 或 Error，對吧？

39
00:01:35,266 --> 00:01:38,000
所以我們要得到這種類型簽名並且

40
00:01:38,000 --> 00:01:41,833
在這裡返回一個 Combine Publisher

41
00:01:41,833 --> 00:01:44,066
這個可以是一個任何能夠

42
00:01:44,066 --> 00:01:45,333
產生 FeedImages 陣列或 Error 的

43
00:01:45,333 --> 00:01:48,466
AnyPublisher

44
00:01:48,466 --> 00:01:53,333
所以讓我們複製已經存在的代碼進來

45
00:01:53,333 --> 00:01:55,266
所以我們需要創建一個 RemoteFeedLoader

46
00:01:55,266 --> 00:01:56,700
配合一個 URL

47
00:01:56,700 --> 00:02:00,066
以及一個 HTTPClient，但我們的 RemoteFeed

48
00:02:00,066 --> 00:02:02,366
Loader不知道 Combine

49
00:02:02,366 --> 00:02:05,333
所以我們需要將這個 FeedLoader 提升到

50
00:02:05,333 --> 00:02:06,466
Combine

51
00:02:06,466 --> 00:02:09,900
世界，因此我們可以將我們的 FeedLoader 包裹在一個

52
00:02:09,900 --> 00:02:10,466
Combine

53
00:02:10,466 --> 00:02:12,633
Publisher 中，他有許多不同的 Publishers

54
00:02:12,633 --> 00:02:13,833
你可以創建

55
00:02:13,833 --> 00:02:16,800
其中一個Publishers是一個Future

56
00:02:16,800 --> 00:02:19,200
以完成塊開始

57
00:02:19,200 --> 00:02:20,800
並且一旦你完成工作，你就會呼叫

58
00:02:20,800 --> 00:02:23,266
用一些結果完成

59
00:02:23,266 --> 00:02:24,933
我們可以在這個Future中做的是

60
00:02:24,933 --> 00:02:27,200
實際調用我們的RemoteFeedLoader

61
00:02:27,200 --> 00:02:30,533
加載操作並完成

62
00:02:30,533 --> 00:02:32,700
因為他們具有

63
00:02:32,700 --> 00:02:34,933
相匹配的類型

64
00:02:34,933 --> 00:02:38,000
請記住，我們正在完成一個

65
00:02:38,000 --> 00:02:40,133
FeedImages的數組或錯誤，

66
00:02:40,133 --> 00:02:41,900
這與我們的RemoteFeedLoader產生的完全一致

67
00:02:41,900 --> 00:02:44,800
但是現在編譯器正在抱怨說

68
00:02:44,800 --> 00:02:47,100
Future是我們

69
00:02:47,100 --> 00:02:50,133
預期的不同類型

70
00:02:50,133 --> 00:02:50,800
期待

71
00:02:50,800 --> 00:02:52,633
在返回方法中，所以我們可以

72
00:02:52,633 --> 00:02:54,233
返回

73
00:02:54,233 --> 00:02:57,433
一個Future，編譯器會很高興

74
00:02:57,433 --> 00:02:59,566
但使用Future是一個執行

75
00:02:59,566 --> 00:03:00,633
細節

76
00:03:00,633 --> 00:03:03,033
如果你不想暴露該細節，你

77
00:03:03,033 --> 00:03:04,133
可以消除

78
00:03:04,133 --> 00:03:06,866
ToAnyPublisher以護航客戶

79
00:03:06,866 --> 00:03:07,433
哪個

80
00:03:07,433 --> 00:03:09,666
Publisher您正在使用，所以當您

81
00:03:09,666 --> 00:03:10,700
不暴露

82
00:03:10,700 --> 00:03:12,866
您所使用的特定Publisher，

83
00:03:12,866 --> 00:03:14,800
可以使用類型擦除

84
00:03:14,800 --> 00:03:18,400
通過eraseToAnyPublisher操作符

85
00:03:18,400 --> 00:03:21,266
對，而不是洩露

86
00:03:21,266 --> 00:03:22,800
實現細節

87
00:03:22,800 --> 00:03:26,233
一個Future Publisher就是這樣，但還有

88
00:03:26,233 --> 00:03:26,933
一個問題

89
00:03:26,933 --> 00:03:30,000
與Futures有關， Futures是

90
00:03:30,000 --> 00:03:33,500
饥餓型Publishers，這意味著這個區塊

91
00:03:33,500 --> 00:03:35,733
一旦您創建了它,

92
00:03:35,733 --> 00:03:37,433
Future就會立即執行，所以每次你調用這個

93
00:03:37,433 --> 00:03:38,400
功能

94
00:03:38,400 --> 00:03:41,566
它將立即觸發這個區塊

95
00:03:41,566 --> 00:03:43,200
這可能是可以的，也許那就是

96
00:03:43,200 --> 00:03:45,100
你想要的，但是我們在這裡需要的

97
00:03:45,100 --> 00:03:48,000
只有當有人

98
00:03:48,000 --> 00:03:49,566
訂閱它時，

99
00:03:49,566 --> 00:03:52,766
才觸發請求，而不是在創建Publisher時。所以一個

100
00:03:52,766 --> 00:03:53,100
方法

101
00:03:53,100 --> 00:03:56,766
我們可以推遲執行Future的

102
00:03:56,766 --> 00:04:00,533
方法是將其包裹在Deferred

103
00:04:00,533 --> 00:04:04,133
Publisher裡。看看這個，

104
00:04:04,133 --> 00:04:06,866
我們正在將Publishers包裹到

105
00:04:06,866 --> 00:04:08,066
Publishers裡面，

106
00:04:08,066 --> 00:04:11,200
就像我們將我們的抽象概念包裹在一起一樣。

107
00:04:11,200 --> 00:04:14,700
與裝飾器，合成物，適配器

108
00:04:14,700 --> 00:04:17,666
等等，其原理是相同的

109
00:04:17,666 --> 00:04:18,233
包裹

110
00:04:18,233 --> 00:04:21,100
將一種類型轉換為另一種類型以改變其

111
00:04:21,100 --> 00:04:22,933
行為

112
00:04:22,933 --> 00:04:24,633
但是我們不創建自己的

113
00:04:24,633 --> 00:04:26,300
實現，我們可以使用

114
00:04:26,300 --> 00:04:29,266
那些通用概念，它們是

115
00:04:29,266 --> 00:04:30,066
內置的

116
00:04:30,066 --> 00:04:32,700
在框架中，而且既然類型

117
00:04:32,700 --> 00:04:33,166
匹配

118
00:04:33,166 --> 00:04:35,900
在RemoteFeedLoader完成塊

119
00:04:35,900 --> 00:04:36,466
塊

120
00:04:36,466 --> 00:04:38,700
和Future完成塊之間，我們可以

121
00:04:38,700 --> 00:04:39,600
只傳遞

122
00:04:39,600 --> 00:04:41,333
load函數作為完成

123
00:04:41,333 --> 00:04:42,800
參數

124
00:04:42,800 --> 00:04:46,066
好，所以我們提升了

125
00:04:46,066 --> 00:04:48,466
我們的RemoteFeedLoader進入了Combine

126
00:04:48,466 --> 00:04:50,000
世界，我們現在可以加載

127
00:04:50,000 --> 00:04:53,166
使用Combine Publishers的資訊

128
00:04:53,166 --> 00:04:55,033
我們甚至可以將此代碼提取為一個

129
00:04:55,033 --> 00:04:57,433
擴展，所以我們可以讓它更容易閱讀

130
00:04:57,433 --> 00:04:58,700
讀

131
00:04:58,700 --> 00:05:00,800
好的，所以我們可以擴展RemoteFeed

132
00:05:00,800 --> 00:05:02,066
Loader

133
00:05:02,066 --> 00:05:05,166
用一個函數轉換這個load

134
00:05:05,166 --> 00:05:06,633
函數到Combine

135
00:05:06,633 --> 00:05:10,866
世界，所以load函數現在是一個load

136
00:05:10,866 --> 00:05:14,233
Publisher，它返回AnyPublisher

137
00:05:14,233 --> 00:05:18,466
的 FeedImage 或錯誤

138
00:05:18,466 --> 00:05:22,233
好的但是

139
00:05:22,233 --> 00:05:25,166
既然 RemoteFeedLoader 定義了它的

140
00:05:25,166 --> 00:05:26,600
自己的錯誤

141
00:05:28,066 --> 00:05:29,733
這裡的類型不符合，因為這裡

142
00:05:29,733 --> 00:05:31,433
我們期待的是 Swift

143
00:05:31,433 --> 00:05:34,533
的 Error，但這裡是 RemoteFeedLoader

144
00:05:34,533 --> 00:05:35,733
的錯誤

145
00:05:35,733 --> 00:05:38,633
但我們可以使用模塊名稱來解決

146
00:05:38,633 --> 00:05:40,133
這個問題

147
00:05:40,133 --> 00:05:42,700
這樣應該可以。好，所以當

148
00:05:42,700 --> 00:05:44,533
使用 RemoteFeedLoader，我們就可以

149
00:05:44,533 --> 00:05:46,300
得到

150
00:05:46,300 --> 00:05:50,466
一個 loadPublisher，現在將包裹

151
00:05:50,466 --> 00:05:53,666
load 函數轉入到 Combine 

152
00:05:53,666 --> 00:05:56,633
Publishers，所以我們甚至可以創建一種類型別名

153
00:05:56,633 --> 00:05:58,000
在此定義別名

154
00:05:58,000 --> 00:06:01,600
別名定義為 FeedImage

155
00:06:01,600 --> 00:06:05,333
或錯誤

156
00:06:05,333 --> 00:06:08,633
好，看起來很乾淨

157
00:06:08,633 --> 00:06:11,600
但這只是剛開始，對，我們

158
00:06:11,600 --> 00:06:12,133
只是

159
00:06:12,133 --> 00:06:14,800
將 load 函數包裹到 Combine 

160
00:06:14,800 --> 00:06:15,833
Publishers

161
00:06:15,833 --> 00:06:20,533
我們還需要進行組合

162
00:06:20,533 --> 00:06:23,666
用快取及備用方法

163
00:06:23,666 --> 00:06:27,833
所以讓我們從快取裝飾器開始

164
00:06:27,833 --> 00:06:29,733
所以這個 FeedLoaderCacheDecorator 我們

165
00:06:29,733 --> 00:06:31,833
在之前的影片中創建

166
00:06:31,833 --> 00:06:35,033
存在的僅僅是為了注入一個副作用到

167
00:06:35,033 --> 00:06:37,333
FeedLoader裡面

168
00:06:37,333 --> 00:06:39,033
所以每次我們從

169
00:06:39,033 --> 00:06:41,500
這個FeedLoader裡加載某物時，我們都會注入

170
00:06:41,500 --> 00:06:44,633
一個用map產生的cache副作用

171
00:06:44,633 --> 00:06:47,733
因此我們會用map來注入副作用

172
00:06:47,733 --> 00:06:50,000
我們也可以做到完全相同的事情

173
00:06:50,000 --> 00:06:54,400
使用Combine運算子

174
00:06:54,400 --> 00:06:56,700
所以我們來在

175
00:06:56,700 --> 00:06:57,900
Publisher上創建一個擴展

176
00:06:57,900 --> 00:07:02,400
輸出是一個陣列,

177
00:07:02,400 --> 00:07:05,666
FeedImage，讓我來創建一個函數

178
00:07:05,666 --> 00:07:09,266
說它是用於緩存

179
00:07:09,266 --> 00:07:15,266
一個cache，就是我們在這裡獲得的

180
00:07:15,266 --> 00:07:18,466
應該返回一個具有

181
00:07:18,466 --> 00:07:19,433
相同類型的Publisher

182
00:07:19,433 --> 00:07:22,300
和失敗，所以我們並不改變

183
00:07:22,300 --> 00:07:23,266
這些類型

184
00:07:23,266 --> 00:07:25,433
我們只是希望注入一個副作用

185
00:07:25,433 --> 00:07:27,166
到這個鏈中

186
00:07:27,166 --> 00:07:30,866
就像我們在這裡做的那樣

187
00:07:30,866 --> 00:07:35,266
讓我們複製並粘貼這個map操作

188
00:07:35,266 --> 00:07:36,800
在這種情況下，我們不需要self

189
00:07:36,800 --> 00:07:38,533
因為我們可以直接訪問到cache

190
00:07:38,533 --> 00:07:43,433
再一次，我們需要將其抹除

191
00:07:43,433 --> 00:07:46,933
轉換到 AnyPublisher 好，就這樣

192
00:07:46,933 --> 00:07:49,166
這基本上就是從

193
00:07:49,166 --> 00:07:50,800
我們之前做的東西複製貼上

194
00:07:50,800 --> 00:07:53,033
因為當你用一個裝飾器

195
00:07:53,033 --> 00:07:54,400
來注入副作用時，

196
00:07:54,400 --> 00:07:56,633
到一個多態介面中，你可以

197
00:07:56,633 --> 00:07:58,000
隨時用

198
00:07:58,000 --> 00:08:00,633
map來取代，事實上，因為我們並非

199
00:08:00,633 --> 00:08:01,500
轉換

200
00:08:01,500 --> 00:08:04,066
這個值，我們只是注入一個副

201
00:08:04,066 --> 00:08:05,166
作用

202
00:08:05,166 --> 00:08:07,666
我們可以用一個其他的被

203
00:08:07,666 --> 00:08:08,466
內建的

204
00:08:08,466 --> 00:08:13,033
專為注入副作用設計的運算子

205
00:08:13,033 --> 00:08:17,333
那就是 handleEvents 操作

206
00:08:17,333 --> 00:08:20,233
在此你獲得一個輸出，你並不

207
00:08:20,233 --> 00:08:22,066
需要回傳

208
00:08:22,066 --> 00:08:24,633
任何東西，因為你不應該

209
00:08:24,633 --> 00:08:25,500
轉換

210
00:08:25,500 --> 00:08:29,166
這個值，就這樣，看看我們如何

211
00:08:29,166 --> 00:08:30,066
注入

212
00:08:30,066 --> 00:08:32,466
副作用，用更少的程式碼

213
00:08:32,466 --> 00:08:33,666
行數

214
00:08:33,666 --> 00:08:36,533
那是一個內建的運算子，我們不需要

215
00:08:36,533 --> 00:08:37,266
來開發

216
00:08:37,266 --> 00:08:40,300
測試並維護它

217
00:08:40,300 --> 00:08:42,366
好，而且由於接收到的輸出

218
00:08:42,366 --> 00:08:44,700
閉包具有相同的簽名

219
00:08:44,700 --> 00:08:47,433
作為 saveIgnoringResult 函數，我們

220
00:08:47,433 --> 00:08:49,433
可以直接傳遞它

221
00:08:49,433 --> 00:08:52,833
看看這個，好的

222
00:08:52,833 --> 00:08:56,000
美麗，所以這整個類別能被

223
00:08:56,000 --> 00:08:57,100
替換

224
00:08:57,100 --> 00:08:59,666
用這個函數，一行代碼

225
00:08:59,666 --> 00:09:01,666
基本上

226
00:09:01,666 --> 00:09:04,933
好的，讓我們移動這個

227
00:09:04,933 --> 00:09:08,800
回到 SceneDelegate 文件

228
00:09:08,800 --> 00:09:12,700
現在我們只需將它加入鏈中

229
00:09:12,700 --> 00:09:16,133
緩存到 feed cache，這邊的

230
00:09:16,133 --> 00:09:17,433
feed cache 是什麼

231
00:09:17,433 --> 00:09:22,366
是 LocalFeedLoader，好的

232
00:09:22,366 --> 00:09:26,466
緩存裝飾器已完成，現在我們需要

233
00:09:26,466 --> 00:09:29,733
fallback 邏輯

234
00:09:29,733 --> 00:09:35,733
讓我們繼續同樣的想法

235
00:09:35,733 --> 00:09:40,000
並在 Publisher 上創建一個擴展

236
00:09:40,000 --> 00:09:43,833
所以我們這裡需要的是從一個

237
00:09:43,833 --> 00:09:45,033
主要的

238
00:09:45,033 --> 00:09:48,300
Publisher 首先載入，如果它失敗了

239
00:09:48,300 --> 00:09:51,200
我們希望嘗試從 fallback 的

240
00:09:51,200 --> 00:09:52,366
Publisher 載入

241
00:09:52,366 --> 00:09:55,500
對的，所以我們需要一個主要的和一個

242
00:09:55,500 --> 00:09:57,733
fallback

243
00:09:57,733 --> 00:10:00,633
所以讓我們在這裡創建我們的 fallback

244
00:10:00,633 --> 00:10:01,266
函數

245
00:10:01,266 --> 00:10:05,500
所以 fallback 到 fallback publisher

246
00:10:05,500 --> 00:10:09,200
這也需要成為一個Publisher

247
00:10:09,200 --> 00:10:11,333
但問題是你不能使用

248
00:10:11,333 --> 00:10:12,933
Publisher 協議

249
00:10:12,933 --> 00:10:16,000
作為參數，因為它有相關的

250
00:10:16,000 --> 00:10:19,666
類型，所以現在讓我們將它設定為

251
00:10:19,666 --> 00:10:20,866
Any

252
00:10:20,866 --> 00:10:25,033
Publisher，但讓我們保持不變

253
00:10:25,033 --> 00:10:29,266
泛型類型 Output 與 Failure

254
00:10:29,266 --> 00:10:31,900
現在我們希望能夠監聽到錯誤，如果

255
00:10:31,900 --> 00:10:33,266
出現錯誤的話，

256
00:10:33,266 --> 00:10:35,200
如果有失敗，我們希望能從

257
00:10:35,200 --> 00:10:37,033
fallback中加載，在這個情況下，我們希望

258
00:10:37,033 --> 00:10:37,666
替換

259
00:10:37,666 --> 00:10:40,233
鏈與 fallback 的 publisher

260
00:10:40,233 --> 00:10:42,233
這有一個操作符可以做到

261
00:10:42,233 --> 00:10:45,433
那就是 catch 操作符，問題

262
00:10:45,433 --> 00:10:46,066
在於

263
00:10:46,066 --> 00:10:49,200
catch 是 Swift 中的一個關鍵字

264
00:10:49,200 --> 00:10:51,433
所以編譯器可能會有點困惑

265
00:10:51,433 --> 00:10:52,933
但我們可以使用

266
00:10:52,933 --> 00:10:55,100
self.catch 來協助

267
00:10:55,100 --> 00:10:56,366
編譯器理解

268
00:10:56,366 --> 00:10:58,300
我們要用的是 catch 函數，而非 catch

269
00:10:58,300 --> 00:10:59,666
關鍵字

270
00:10:59,666 --> 00:11:02,300
而 catch 函數預期一個閉包

271
00:11:02,300 --> 00:11:04,000
那接收一個Error

272
00:11:04,000 --> 00:11:07,333
並返回一個Publisher，所以我們也可以

273
00:11:07,333 --> 00:11:08,133
在這裡設定

274
00:11:08,133 --> 00:11:12,833
一個Error閉包並傳遞給catch

275
00:11:12,833 --> 00:11:18,533
函數和eraseToAnyPublisher

276
00:11:18,533 --> 00:11:21,500
但在我們的composite中我們忽略錯誤

277
00:11:21,500 --> 00:11:24,000
在失敗的情況下

278
00:11:24,000 --> 00:11:27,666
所以我們甚至可以在這裡忽略錯誤

279
00:11:27,666 --> 00:11:31,833
像這樣，對嗎

280
00:11:31,833 --> 00:11:34,933
所以Publisher中的catch操作符是

281
00:11:34,933 --> 00:11:36,366
相當於

282
00:11:36,366 --> 00:11:39,200
我們創建的fallback composite

283
00:11:39,200 --> 00:11:40,466
它是一種

284
00:11:40,466 --> 00:11:44,533
向Publishers注入fallback邏輯的方式

285
00:11:44,533 --> 00:11:47,100
並且它是一種可重用的方式

286
00:11:47,100 --> 00:11:48,533
所以再次提醒你不需要實現

287
00:11:48,533 --> 00:11:52,300
維護並測試該邏輯

288
00:11:52,300 --> 00:11:53,600
好的，我們將其移至Scene

289
00:11:53,600 --> 00:11:55,433
Delegate文件

290
00:11:55,433 --> 00:12:00,233
並繼續我們的組合

291
00:12:00,233 --> 00:12:02,233
所以現在我們需要在這裡連接

292
00:12:02,233 --> 00:12:03,666
fallback

293
00:12:03,666 --> 00:12:07,033
操作和fallback

294
00:12:07,033 --> 00:12:13,033
就是LocalFeedLoader的loadPublisher

295
00:12:13,033 --> 00:12:15,333
但是LocalFeedLoader沒有

296
00:12:15,333 --> 00:12:17,500
loadPublisher

297
00:12:17,500 --> 00:12:19,433
所以我們可以選擇複製這個

298
00:12:19,433 --> 00:12:20,933
擴充元件，但是為了

299
00:12:20,933 --> 00:12:24,000
LocalFeedLoader 或我們可以簡短地製作

300
00:12:24,000 --> 00:12:25,266
這個擴充元件

301
00:12:25,266 --> 00:12:28,700
開放給任何 FeedLoader 都可

302
00:12:28,700 --> 00:12:31,733
我們可以做到看，現在任何 Feed

303
00:12:31,733 --> 00:12:32,233
Loader

304
00:12:32,233 --> 00:12:35,433
可以被包裝成 Combine Publishers

305
00:12:35,433 --> 00:12:37,500
這表示我們不再需要這個 Swift.

306
00:12:37,500 --> 00:12:40,066
Error 了

307
00:12:40,066 --> 00:12:42,700
就這樣，這就是組成

308
00:12:42,700 --> 00:12:45,600
與 Combine

309
00:12:45,600 --> 00:12:48,233
這些鏈接操作符等同

310
00:12:48,233 --> 00:12:49,733
於這種組成

311
00:12:49,733 --> 00:12:52,233
與倒退複合和

312
00:12:52,233 --> 00:12:53,733
緩存裝飾器

313
00:12:53,733 --> 00:12:56,800
注入緩存副作用，所以現在

314
00:12:56,800 --> 00:12:57,333
我們可以

315
00:12:57,333 --> 00:12:58,366
更換設計模式

316
00:12:58,366 --> 00:13:00,633
用 Combine

317
00:13:00,633 --> 00:13:03,433
在組織者中也是一樣，所以代替

318
00:13:03,433 --> 00:13:04,133
過去

319
00:13:04,133 --> 00:13:08,000
FeedLoader，我們可以傳遞一個函數

320
00:13:08,000 --> 00:13:11,600
創建 Feedloader Publishers

321
00:13:11,600 --> 00:13:13,833
但在我們可以進行之前，我們需要

322
00:13:13,833 --> 00:13:14,700
再創建一個

323
00:13:14,700 --> 00:13:17,600
操作元，一個可以調配

324
00:13:17,600 --> 00:13:18,366
工作的

325
00:13:18,366 --> 00:13:21,900
在主線程中，所以讓我們復原

326
00:13:21,900 --> 00:13:26,133
我們來檢查一下主要的 dispatch 裝飾器

327
00:13:26,133 --> 00:13:29,100
再一次，讓我們在這裡導入 Combine

328
00:13:29,100 --> 00:13:29,500
讓我們

329
00:13:29,500 --> 00:13:32,833
用 Combine 來複製這種邏輯

330
00:13:32,833 --> 00:13:35,666
所以這個邏輯是當

331
00:13:35,666 --> 00:13:36,800
進行工作分派時

332
00:13:36,800 --> 00:13:39,033
如果我們已經在主線程上

333
00:13:39,033 --> 00:13:40,866
立即完成

334
00:13:40,866 --> 00:13:43,433
否則，將其分派到主隊列

335
00:13:43,433 --> 00:13:46,133
異步地

336
00:13:46,133 --> 00:13:49,600
所以擴展 Publisher

337
00:13:49,600 --> 00:13:53,500
我們稱之為 dispatchOnMainQueue

338
00:13:53,500 --> 00:13:57,033
這應該返回 AnyPublisher

339
00:13:57,033 --> 00:13:59,500
與原來的 Output 和 Failure 一樣, 它不應該

340
00:13:59,500 --> 00:14:00,700
改變型別

341
00:14:00,700 --> 00:14:03,433
應該只注入 dispatch

342
00:14:03,433 --> 00:14:04,866
裝飾器

343
00:14:04,866 --> 00:14:07,333
在 Combine 中有一個可以在任何隊列上分派工作的 operator

344
00:14:07,333 --> 00:14:08,533
名為 receive on a

345
00:14:08,533 --> 00:14:11,666
scheduler

346
00:14:11,666 --> 00:14:13,033
並且 DipatchQueue 實現了

347
00:14:13,033 --> 00:14:15,833
Scheduler 協議

348
00:14:15,833 --> 00:14:17,033
所以我們可以使用 dispatch queue main

349
00:14:17,033 --> 00:14:19,600
scheduler

350
00:14:19,600 --> 00:14:20,366
來分派工作到主隊列

351
00:14:20,366 --> 00:14:23,433
但這裡有一個問題，這個 operator

352
00:14:23,433 --> 00:14:26,466
即 dispatch queue main

353
00:14:26,466 --> 00:14:27,500
scheduler

354
00:14:27,500 --> 00:14:29,733
將始終異步地分派

355
00:14:29,733 --> 00:14:31,333
工作

356
00:14:31,333 --> 00:14:33,033
它不會檢查你是否已經在

357
00:14:33,033 --> 00:14:35,733
主要線程上並立即完成

358
00:14:35,733 --> 00:14:38,133
因此當使用

359
00:14:38,133 --> 00:14:39,433
dispatch queue main時

360
00:14:39,433 --> 00:14:42,533
行為會有所不同，我們希望保持相同

361
00:14:42,533 --> 00:14:43,600
的行為

362
00:14:43,600 --> 00:14:45,900
對，如果我們已經在主

363
00:14:45,900 --> 00:14:47,600
隊列上，我們希望立即完成

364
00:14:47,600 --> 00:14:50,633
所以我們可以做的是將

365
00:14:50,633 --> 00:14:51,666
dispatch queue

366
00:14:51,666 --> 00:14:55,266
main scheduler封裝到我們自己的

367
00:14:55,266 --> 00:14:58,300
scheduler裡，好，讓我們創建

368
00:14:58,300 --> 00:15:01,433
我們的ImmediateWhenOn

369
00:15:01,433 --> 00:15:04,633
MainQueueScheduler，這需要

370
00:15:04,633 --> 00:15:05,333
實現

371
00:15:05,333 --> 00:15:08,366
在Combine框架中定義的

372
00:15:08,366 --> 00:15:10,833
Scheduler協議，讓我們看一下

373
00:15:10,833 --> 00:15:12,000
看一看

374
00:15:12,000 --> 00:15:13,600
所以我們需要定義一些關聯的

375
00:15:13,600 --> 00:15:16,133
類型，並需要提供這些

376
00:15:16,133 --> 00:15:22,133
實現方式

377
00:15:22,133 --> 00:15:25,033
好，由於我們將

378
00:15:25,033 --> 00:15:26,366
dispatch queue main

379
00:15:26,366 --> 00:15:29,433
封裝到這種類型中，我們可以實際使用相同的

380
00:15:29,433 --> 00:15:30,066
類型

381
00:15:30,066 --> 00:15:33,100
DispatchQueue 類型

382
00:15:33,100 --> 00:15:35,733
所以現在它將是這個 DispatchQueue

383
00:15:35,733 --> 00:15:36,633
main

384
00:15:36,633 --> 00:15:39,666
現在的最小公差


385
00:15:39,666 --> 00:15:42,866
是 dispatch queue tolerance，然後這裡

386
00:15:42,866 --> 00:15:44,000
是該方法

387
00:15:44,000 --> 00:15:47,033
我們在意的是那個會進行

388
00:15:47,033 --> 00:15:48,000
執行

389
00:15:48,000 --> 00:15:51,333
工作的 schedule 方法，所以我們在這裡希望增加

390
00:15:51,333 --> 00:15:54,800
我們的邏輯，如果我們已經在

391
00:15:54,800 --> 00:15:58,000
主線程上，我們會直接完成

392
00:15:58,000 --> 00:16:01,166
否則的話

393
00:16:01,166 --> 00:16:04,366
我們會使用 DispatchQueue

394
00:16:04,366 --> 00:16:09,666
來安排主線程的事務，就是這樣

395
00:16:09,666 --> 00:16:11,833
現在如果我們在使用 scheduler 來

396
00:16:11,833 --> 00:16:12,933
安排某事

397
00:16:12,933 --> 00:16:15,500
在特定日期後，我們無法立即執行

398
00:16:15,500 --> 00:16:17,266
這件事

399
00:16:17,266 --> 00:16:19,033
因此我們只好將該信息轉發給

400
00:16:19,033 --> 00:16:23,500
主隊列 scheduler

401
00:16:23,500 --> 00:16:27,166
好的，現在讓我們創建一個靜態的立即

402
00:16:27,166 --> 00:16:32,233
WhenOnMainQueueScheduler

403
00:16:32,233 --> 00:16:33,900
並且現在我們可以使用它來確保我們

404
00:16:33,900 --> 00:16:35,900
保有在應用場景中相同的行為

405
00:16:35,900 --> 00:16:36,233
對的

406
00:16:36,233 --> 00:16:39,733
所以，就這樣成為 MainQueue

407
00:16:39,733 --> 00:16:41,266
DispatchDecorator

408
00:16:41,266 --> 00:16:44,366
能夠無縫替代

409
00:16:44,366 --> 00:16:45,033
接收者

410
00:16:45,033 --> 00:16:48,466
on scheduler operation

411
00:16:48,466 --> 00:16:50,466
所以再次的，讓我們將其移到 Scene

412
00:16:50,466 --> 00:16:52,366
Delegate

413
00:16:52,366 --> 00:16:58,000
現在我們先把所有運算子放在一個地方

414
00:16:58,000 --> 00:16:59,500
現在我們有了我們需要的一切來

415
00:16:59,500 --> 00:17:01,166
以Publisher替換FeedLoader

416
00:17:01,166 --> 00:17:01,900
Publisher

417
00:17:01,900 --> 00:17:05,333
在 Composition Root 中所以這裡

418
00:17:05,333 --> 00:17:05,666
而非

419
00:17:05,666 --> 00:17:07,900
將FeedLoader包裹在裝飾器中

420
00:17:07,900 --> 00:17:09,433
我們打算進行調度

421
00:17:09,433 --> 00:17:13,500
在主隊列中

422
00:17:13,500 --> 00:17:16,766
看看這多麼出色

423
00:17:16,766 --> 00:17:18,400
因此，presentation adapter 不再獲取

424
00:17:18,400 --> 00:17:20,000
FeedLoaders

425
00:17:20,000 --> 00:17:23,433
它獲取的是Publishers，所以我們需要替換

426
00:17:23,433 --> 00:17:25,166
這段程式碼為Publisher

427
00:17:25,166 --> 00:17:28,233
語法，我們可以使用它

428
00:17:28,233 --> 00:17:31,266
透過sink來訂閱Publisher並

429
00:17:31,266 --> 00:17:33,833
啟動運行

430
00:17:33,833 --> 00:17:37,100
所以如果我們收到一個完成

431
00:17:37,100 --> 00:17:40,533
或者我們收到值

432
00:17:40,533 --> 00:17:42,700
我們需要執行完全相同的

433
00:17:42,700 --> 00:17:45,333
邏輯

434
00:17:45,333 --> 00:17:48,533
因此，當我們接收到一個成功的值時

435
00:17:48,533 --> 00:17:50,866
我們告訴presenter我們已完成

436
00:17:50,866 --> 00:17:52,400
載入feed

437
00:17:52,400 --> 00:17:55,433
如果Publisher完成了，無論何種情況

438
00:17:55,433 --> 00:17:56,133
完成

439
00:17:56,133 --> 00:17:59,566
是否有完成案件，在這種情況下

440
00:17:59,566 --> 00:18:00,466
我們不希望這麼做

441
00:18:00,466 --> 00:18:03,566
任何事或者

442
00:18:03,566 --> 00:18:07,100
一個失敗的案例帶有一個錯誤

443
00:18:07,100 --> 00:18:09,333
我們想要告知演繹者

444
00:18:09,333 --> 00:18:11,500
關於錯誤

445
00:18:11,500 --> 00:18:14,633
所以我們需要使 self 變為弱引用，好嗎

446
00:18:14,633 --> 00:18:17,666
所以我們不再需要這個載入

447
00:18:17,666 --> 00:18:20,400
我們需要保持的最後一件事情是

448
00:18:20,400 --> 00:18:23,200
訂閱的結果，就是一個Cancellable

449
00:18:23,200 --> 00:18:25,100
因為如果你不保持 Cancellable

450
00:18:25,100 --> 00:18:26,633
它將會被釋放

451
00:18:26,633 --> 00:18:28,300
並且當 Cancellable 被釋放時

452
00:18:28,300 --> 00:18:34,466
它會取消整個訂閱

453
00:18:34,466 --> 00:18:37,733
好，現在我們只需要更新

454
00:18:37,733 --> 00:18:40,833
我們的組成根源與 Publisher

455
00:18:40,833 --> 00:18:44,400
連接

456
00:18:44,400 --> 00:18:47,733
所以我們不需要 RemoteFeedLoader

457
00:18:47,733 --> 00:18:51,433
或者在這個功能中的網址，好嗎

458
00:18:51,433 --> 00:18:54,833
最後一個建立錯誤我們需要匯入

459
00:18:54,833 --> 00:18:57,600
Combine

460
00:18:57,600 --> 00:19:00,400
讓我們運行測試並且得到一個建立

461
00:19:00,400 --> 00:19:02,233
錯誤

462
00:19:02,233 --> 00:19:05,100
因為我們現在需要將載入器

463
00:19:05,100 --> 00:19:06,133
Publisher

464
00:19:06,133 --> 00:19:08,633
而不需要注入那些 FeedLoaders


465
00:19:08,633 --> 00:19:12,700
所有您需要在測試中改變的

466
00:19:12,700 --> 00:19:16,066
讓我們運行這些測試

467
00:19:16,066 --> 00:19:18,633
它通過了，這意味著組合

468
00:19:18,633 --> 00:19:19,600
有效

469
00:19:19,600 --> 00:19:22,766
好的，那麼替換起來有多容易

470
00:19:22,766 --> 00:19:24,233
裝飾器和合成物

471
00:19:24,233 --> 00:19:27,100
使用 Combine 而不破壞測試

472
00:19:27,100 --> 00:19:29,666
不破壞其他模塊

473
00:19:29,666 --> 00:19:31,433
所以我們不需要 FeedLoaderWith

474
00:19:31,433 --> 00:19:32,866
FallbackComposite

475
00:19:32,866 --> 00:19:36,233
如果我們使用 Combine 是的，我們也

476
00:19:36,233 --> 00:19:37,500
不需要 FeedLoader

477
00:19:37,500 --> 00:19:40,533
CacheDecorator

478
00:19:40,533 --> 00:19:42,933
我們也不需要 FeedLoader Main

479
00:19:42,933 --> 00:19:44,466
QueueDispatchDecorator

480
00:19:44,466 --> 00:19:49,733
extension 也是

481
00:19:49,733 --> 00:19:54,933
所以我們也不需要測試對吧

482
00:19:54,933 --> 00:19:58,400
使用這些內置的

483
00:19:58,400 --> 00:20:01,733
與 Combine 相關的通用抽象，工作量更少

484
00:20:01,733 --> 00:20:05,333
好，讓我們提交吧

485
00:20:05,333 --> 00:20:07,600
將 FeedLoader 的組合替換為

486
00:20:07,600 --> 00:20:08,700
Combine

487
00:20:08,700 --> 00:20:13,433
操作符，讓我們做同樣的事情

488
00:20:13,433 --> 00:20:16,633
對於 FeedImageDataLoader

489
00:20:16,633 --> 00:20:19,333
所以 FeedImageDataLoader 產生

490
00:20:19,333 --> 00:20:20,466
要麼是

491
00:20:20,466 --> 00:20:24,633
Data 或 Error，並需要一個 URL

492
00:20:24,633 --> 00:20:27,733
執行請求，所以我們再次包裹

493
00:20:27,733 --> 00:20:30,933
這項操作在一個Deffered Future裡

494
00:20:30,933 --> 00:20:33,266
我們從中執行loadImageData

495
00:20:33,266 --> 00:20:34,066
URL

496
00:20:34,066 --> 00:20:37,433
有了Future的完成塊

497
00:20:37,433 --> 00:20:40,400
但是loadImageData能夠被取消

498
00:20:40,400 --> 00:20:41,333
對吧

499
00:20:41,333 --> 00:20:44,400
因此我們對那個任務保持一個引用

500
00:20:44,400 --> 00:20:48,066
如果你接收到取消事件，我們

501
00:20:48,066 --> 00:20:48,533
取消

502
00:20:48,533 --> 00:20:50,400
任務。所以我們再一次使用

503
00:20:50,400 --> 00:20:51,600
handleEvents

504
00:20:51,600 --> 00:20:55,200
將一個副作用注入到鏈路中

505
00:20:55,200 --> 00:20:57,833
而這個案例中的副作用，當

506
00:20:57,833 --> 00:20:58,866
接收到取消

507
00:20:58,866 --> 00:21:02,700
事件是，取消運行中的任務

508
00:21:02,700 --> 00:21:05,333
就這樣，我們還需要將

509
00:21:05,333 --> 00:21:06,233
緩存

510
00:21:06,233 --> 00:21:10,633
副作用注入到FeedImageDataCache中

511
00:21:10,633 --> 00:21:12,533
所以我們再使用handle events來

512
00:21:12,533 --> 00:21:13,833
注入副作用

513
00:21:13,833 --> 00:21:17,266
到鏈路中

514
00:21:17,266 --> 00:21:20,466
現在我們能夠創建一個makeLocal

515
00:21:20,466 --> 00:21:23,600
ImageLoaderWithRemote

516
00:21:23,600 --> 00:21:28,866
Fallback function接收一個URL

517
00:21:28,866 --> 00:21:33,200
並返回一個FeedImageDataLoader

518
00:21:33,200 --> 00:21:36,866
出版者，所以在這裡我們需要

519
00:21:36,866 --> 00:21:43,100
遠程和本地的圖像加載器

520
00:21:43,100 --> 00:21:46,400
邏輯是首先

521
00:21:46,400 --> 00:21:49,033
從本地圖像加載器加載，並且

522
00:21:49,033 --> 00:21:49,833
回滯

523
00:21:49,833 --> 00:21:52,533
到遠程加載器，對吧，所以這就是

524
00:21:52,533 --> 00:21:53,266
反向的

525
00:21:53,266 --> 00:21:55,833
與FeedLoader相反，我們首先加載

526
00:21:55,833 --> 00:21:58,133
遠程然後是本地的

527
00:21:58,133 --> 00:22:00,633
所以首先從本地加載這個

528
00:22:00,633 --> 00:22:02,300
加載圖像數據

529
00:22:02,300 --> 00:22:05,600
來自URL的Publisher

530
00:22:05,600 --> 00:22:08,133
然後我們回滯到遠程圖像

531
00:22:08,133 --> 00:22:09,500
加載器

532
00:22:09,500 --> 00:22:12,933
加載圖像的Publisher

533
00:22:12,933 --> 00:22:16,766
使用URL緩存到本地圖像加載器

534
00:22:16,766 --> 00:22:19,900
同樣的，就是這樣

535
00:22:19,900 --> 00:22:21,200
復合

536
00:22:21,200 --> 00:22:24,633
連同Combine一樣，我們與

537
00:22:24,633 --> 00:22:28,866
composite和decorators有一樣的

538
00:22:28,866 --> 00:22:31,833
所以現在我們可以注入一個閉包接收

539
00:22:31,833 --> 00:22:33,200
一個URL

540
00:22:33,200 --> 00:22:36,133
產生FeedImageDataLoader

541
00:22:36,133 --> 00:22:38,933
Publishers

542
00:22:38,933 --> 00:22:40,933
再次我們需要裝飾主

543
00:22:40,933 --> 00:22:42,633
隊列

544
00:22:42,633 --> 00:22:45,666
我們可以重用dispatchOnMainQueue

545
00:22:45,666 --> 00:22:51,433
操作

546
00:22:51,433 --> 00:22:56,000
讓我們導入Combine和Fundation

547
00:22:56,000 --> 00:22:59,033
並用替換imageLoader

548
00:22:59,033 --> 00:23:01,600
透過使用

549
00:23:01,600 --> 00:23:03,333
sink

550
00:23:03,333 --> 00:23:06,533
來訂閱 Publisher

551
00:23:06,533 --> 00:23:10,300
如果事件完結就

552
00:23:10,300 --> 00:23:13,333
終於處理

553
00:23:13,333 --> 00:23:13,833
但如果失敗了我們就傳遞

554
00:23:13,833 --> 00:23:18,866
失敗給 presenter

555
00:23:18,866 --> 00:23:22,300
如果是成功的值結果

556
00:23:22,300 --> 00:23:25,200
資料我們也傳遞給

557
00:23:25,200 --> 00:23:29,033
presenter

558
00:23:29,033 --> 00:23:30,933
當然我們也必須保留

559
00:23:30,933 --> 00:23:32,933
cancellable

560
00:23:32,933 --> 00:23:42,933
此先前是任務

561
00:23:42,933 --> 00:23:46,400
現在我們需要修復測試

562
00:23:46,400 --> 00:23:49,333
通過傳遞 Publisher 而非

563
00:23:49,333 --> 00:23:51,266
加載器

564
00:23:51,266 --> 00:23:54,466
所以測試是通過的

565
00:23:54,466 --> 00:23:57,733
很棒，這意味著我們不需要

566
00:23:57,733 --> 00:24:00,000
為圖片數據加載器使用備選組合

567
00:24:00,000 --> 00:24:01,733
也不再需要

568
00:24:01,733 --> 00:24:04,933
ImageDataLoader

569
00:24:04,933 --> 00:24:06,000
CacheDecorator

570
00:24:06,000 --> 00:24:09,100
我們也可以刪除 MainQueue

571
00:24:09,100 --> 00:24:12,133
DispatchDecorator

572
00:24:12,133 --> 00:24:14,533
這些行為都可以透過

573
00:24:14,533 --> 00:24:15,266
universal

574
00:24:15,266 --> 00:24:18,300
進行抽象化，Combine將這些提供給我們

575
00:24:18,300 --> 00:24:20,466
全部免費


576
00:24:20,466 --> 00:24:23,600
看那裡，乾淨多了，我們再跑

577
00:24:23,600 --> 00:24:25,100
測試一次

578
00:24:25,100 --> 00:24:29,033
通過了，我們提交

579
00:24:29,033 --> 00:24:31,333
所以代替FeedImageDataLoader

580
00:24:31,333 --> 00:24:32,400
組合

581
00:24:32,400 --> 00:24:36,866
使用Combine運算子

582
00:24:36,866 --> 00:24:39,033
好的，現在我們可以將這些Combine

583
00:24:39,033 --> 00:24:45,266
助手移到一個單獨的檔案

584
00:24:45,266 --> 00:24:50,866
跑測試，通過了，提交

585
00:24:50,866 --> 00:24:54,533
把Combine助手移到新的

586
00:24:54,533 --> 00:24:59,733
檔案，所有測試都通過了

587
00:24:59,733 --> 00:25:03,266
運行應用程序

588
00:25:03,266 --> 00:25:07,033
它仍然運作得很好，太好了

589
00:25:07,033 --> 00:25:09,600
這就是我們如何使用Combine來組成

590
00:25:09,600 --> 00:25:10,933
你的應用程式

591
00:25:10,933 --> 00:25:13,266
與萬能抽象在

592
00:25:13,266 --> 00:25:14,466
Composition

593
00:25:14,466 --> 00:25:17,600
Root中的概念是相似的，跟一些

594
00:25:17,600 --> 00:25:18,633
設計模式

595
00:25:18,633 --> 00:25:20,933
你包裝你的類型使用一個

596
00:25:20,933 --> 00:25:21,733
多形的

597
00:25:21,733 --> 00:25:24,766
介面，所以一些設計模式是

598
00:25:24,766 --> 00:25:25,666
相等的

599
00:25:25,666 --> 00:25:28,933
內建的像泛用抽象

600
00:25:28,933 --> 00:25:33,033
map, flatMap, catch, handleEvents

601
00:25:33,033 --> 00:25:36,766
等等，所以你不需要重新發明

602
00:25:36,766 --> 00:25:39,733
輪子，好的，這樣就可以了

603
00:25:39,733 --> 00:25:40,866
就這樣結束了這次的講座

604
00:25:40,866 --> 00:25:43,500
我們下次再見，再見了，大家

605
00:25:43,500 --> 00:25:57,500
再見