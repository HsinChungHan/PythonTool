

1
00:00:01,500 --> 00:00:03,433
你好 Mike，嘿 Caio

2
00:00:03,433 --> 00:00:05,266
所以在上一集我們已經完成了

3
00:00:05,266 --> 00:00:09,100
處理所有的HTTPClient錯誤

4
00:00:09,100 --> 00:00:11,333
現在該開始映射該JSON了

5
00:00:11,333 --> 00:00:12,233
響應

6
00:00:12,233 --> 00:00:15,433
轉換成Feed項目，對吧

7
00:00:15,433 --> 00:00:18,800
Feed項目是該模型的

8
00:00:18,800 --> 00:00:20,066
系統的其餘部份

9
00:00:20,066 --> 00:00:22,700
將要使用，而我們希望該API

10
00:00:22,700 --> 00:00:23,500
模塊

11
00:00:23,500 --> 00:00:26,800
能轉換來自HTTPClient的數據

12
00:00:26,800 --> 00:00:30,800
進入此模型

13
00:00:30,800 --> 00:00:34,533
所以這是我們的模型 FeedItem

14
00:00:34,533 --> 00:00:36,366
並且這裡我們有與後端的契約

15
00:00:36,366 --> 00:00:38,466
這個模型是如何

16
00:00:38,466 --> 00:00:39,500
表示出來的

17
00:00:39,500 --> 00:00:42,533
以JSON形式非常好所以再說一次它是個

18
00:00:42,533 --> 00:00:43,733
200的回應

19
00:00:43,733 --> 00:00:45,900
我們已經正在檢查該點，然後我們

20
00:00:45,900 --> 00:00:46,866
有一個物件

21
00:00:46,866 --> 00:00:49,266
有一個鍵路徑items，它包含一個

22
00:00:49,266 --> 00:00:50,633
陣列物件

23
00:00:50,633 --> 00:00:52,933
並且地點和描述是可選的

24
00:00:52,933 --> 00:00:54,633
所以我們可能不會有一個

25
00:00:54,633 --> 00:00:56,466
當沒有描述或

26
00:00:56,466 --> 00:00:59,033
地點時，它們只是不存在


27
00:00:59,033 --> 00:01:03,266
在JSON表示法中，是的

28
00:01:03,266 --> 00:01:07,333
好的，我們總是以測試為開始

29
00:01:07,333 --> 00:01:09,666
我們先從不滿意的情況著手，對吧？

30
00:01:09,666 --> 00:01:11,666
好的，所以你是在說關於 200

31
00:01:11,666 --> 00:01:12,866
回應

32
00:01:12,866 --> 00:01:16,233
但卻是無效的JSON，對吧？所以他返回一個

33
00:01:16,233 --> 00:01:16,766
錯誤

34
00:01:16,766 --> 00:01:20,700
對，基於 200 HTTP 的回應

35
00:01:20,700 --> 00:01:24,133
但是包含無效的JSON，對吧？

36
00:01:24,133 --> 00:01:26,533
這可能會發生，我們應該就緒，

37
00:01:26,533 --> 00:01:28,700
無論那是否會發生

38
00:01:28,700 --> 00:01:29,433
對

39
00:01:29,433 --> 00:01:31,500
像以前一樣，我們有我們的 sut 和我們的

40
00:01:31,500 --> 00:01:34,066
客戶端

41
00:01:34,066 --> 00:01:38,400
我認為我們甚至可以複制這裡的設置

42
00:01:38,400 --> 00:01:41,200
所以我們正在捕捉錯誤，對吧，我們

43
00:01:41,200 --> 00:01:43,200
完成了一個 200

44
00:01:43,200 --> 00:01:46,066
狀態碼，但現在我們需要傳遞一些

45
00:01:46,066 --> 00:01:46,866
資料

46
00:01:46,866 --> 00:01:49,833
對，是無效的 JSON，是的，這就是

47
00:01:49,833 --> 00:01:51,033
設定部分

48
00:01:51,033 --> 00:01:53,100
而我們想要確定我們

49
00:01:53,100 --> 00:01:54,766
收到了一個 invalidData

50
00:01:54,766 --> 00:01:57,500
錯誤，是的，所以我們需要創建這個

51
00:01:57,500 --> 00:01:59,733
無效的JSON

52
00:01:59,733 --> 00:02:02,866
所以 invalidJSON 等於，嗯，可以是任何東西。

53
00:02:02,866 --> 00:02:03,600
任何

54
00:02:03,600 --> 00:02:06,533
不合規範的 JSON 數據表示。

55
00:02:06,533 --> 00:02:07,733
我們可以造一些

56
00:02:07,733 --> 00:02:10,366
這裡的數據，像這個無效的

57
00:02:10,366 --> 00:02:11,833
JSON

58
00:02:11,833 --> 00:02:15,166
對，好的。

59
00:02:15,166 --> 00:02:18,133
那現在我們的客戶端代碼還不知道如何

60
00:02:18,133 --> 00:02:19,900
處理這個數據。

61
00:02:19,900 --> 00:02:23,566
對，所以讓我們來實現它。

62
00:02:23,566 --> 00:02:26,300
我們現在可以接收數據，但這會

63
00:02:26,300 --> 00:02:27,733
使其他測試失敗。

64
00:02:27,733 --> 00:02:30,400
對，但我們可以給它一個預設

65
00:02:30,400 --> 00:02:30,933
值。

66
00:02:30,933 --> 00:02:33,333
暫時這樣做，然後我們應該如何處理

67
00:02:33,333 --> 00:02:34,466
這個數據？

68
00:02:34,466 --> 00:02:36,233
對，這個數據在成功返回時應該

69
00:02:36,233 --> 00:02:37,666
進入成功分支。

70
00:02:37,666 --> 00:02:40,866
當我們得到回應時，我們也期望

71
00:02:40,866 --> 00:02:42,000
得到數據。

72
00:02:42,000 --> 00:02:45,033
所以我們可以將它加入到enum中的

73
00:02:45,033 --> 00:02:47,266
成功元組中。好，但這會

74
00:02:47,266 --> 00:02:48,866
導致我們的實際代碼出錯，但那是

75
00:02:48,866 --> 00:02:49,500
好事。

76
00:02:49,500 --> 00:02:52,133
沒錯，這正是我們想要的，所以我們需要

77
00:02:52,133 --> 00:02:53,033
添加一些

78
00:02:53,033 --> 00:02:56,133
其他的東西在這個結果類型裡面。是的

79
00:02:56,133 --> 00:03:00,066
這是 Data 和 HTTPURLResponse

80
00:03:00,066 --> 00:03:03,033
我們現在可以建構嗎？好，我們可以建構，並且

81
00:03:03,033 --> 00:03:04,866
測試已通過

82
00:03:04,866 --> 00:03:07,566
對，但我也希望看到一個

83
00:03:07,566 --> 00:03:08,533
失敗的測試

84
00:03:08,533 --> 00:03:11,100
對，所以我們可以迅速就將它註解掉

85
00:03:11,100 --> 00:03:15,100
這一行程式碼

86
00:03:15,100 --> 00:03:17,100
那麼我們可以看到一個失敗的

87
00:03:17,100 --> 00:03:19,033
測試，我們正在覆蓋這個

88
00:03:19,033 --> 00:03:22,300
情境，讓我們將其恢復

89
00:03:22,300 --> 00:03:26,633
已通過，讓我們提交修改：在200 HTTP

90
00:03:26,633 --> 00:03:31,033
回應中發生無效數據錯誤

91
00:03:31,033 --> 00:03:34,533
和無效的 JSON，看起來

92
00:03:34,533 --> 00:03:35,433
不錯

93
00:03:35,433 --> 00:03:37,433
好的，對我來說，在這些

94
00:03:37,433 --> 00:03:39,200
處理錯誤案例的測試中似乎有很多重複

95
00:03:39,200 --> 00:03:42,300
的內容，他們都在重復著這種對

96
00:03:42,300 --> 00:03:44,866
錯誤的捕捉和斷言

97
00:03:44,866 --> 00:03:47,266
正確的值，所以這裡改變的是

98
00:03:47,266 --> 00:03:50,066
只有生成錯誤的行為和錯誤

99
00:03:50,066 --> 00:03:50,933
自身

100
00:03:50,933 --> 00:03:54,133
引起錯誤以及錯誤

101
00:03:54,133 --> 00:03:58,233
所以如果我們可以預期到某一個

102
00:03:58,233 --> 00:04:01,333
錯誤案例，我們可以給予它操作

103
00:04:01,333 --> 00:04:04,466
我認為我們可以在那裡省下一些行數並且

104
00:04:04,466 --> 00:04:05,333
甚至使它

105
00:04:05,333 --> 00:04:07,033
更易於閱讀好的，讓我們嘗試去

106
00:04:07,033 --> 00:04:09,333
建立一個助手，讓我複製

107
00:04:09,333 --> 00:04:12,400
當前的設置我們在這裡建立一個

108
00:04:12,400 --> 00:04:14,400
助手函數並且如你所說它是

109
00:04:14,400 --> 00:04:16,000
像是期望

110
00:04:16,000 --> 00:04:19,833
對，sut RemoteFeedLoader

111
00:04:19,833 --> 00:04:23,166
要完成對，我們將以

112
00:04:23,166 --> 00:04:23,733
錯誤為結

113
00:04:23,733 --> 00:04:26,133
在這些測試中，好的所以完成並帶著

114
00:04:26,133 --> 00:04:27,100
錯誤

115
00:04:27,100 --> 00:04:30,300
並且它是一個 RemoteFeedLoader.Error

116
00:04:30,300 --> 00:04:33,500
然後當某種行為發生

117
00:04:33,500 --> 00:04:37,433
好的，讓我們傳遞一個行為關閉的命令

118
00:04:37,433 --> 00:04:40,466
好的，讓我們看看有没有包含所有項目

119
00:04:40,466 --> 00:04:42,133
這裡是行為的部分

120
00:04:42,133 --> 00:04:43,733
對，客戶不需要，這會

121
00:04:43,733 --> 00:04:45,166
在閉包中進行

122
00:04:45,166 --> 00:04:48,866
所以我們可以在那裡調用行為

123
00:04:48,866 --> 00:04:51,900
對，太棒了，和捕獲的錯誤


124
00:04:51,900 --> 00:04:54,866
是我們剛經過的那個，就是這個

125
00:04:54,866 --> 00:04:55,433
對

126
00:04:55,433 --> 00:04:57,166
好的，讓我們看看我們能否重構這個

127
00:04:57,166 --> 00:04:58,800
試驗一下

128
00:04:58,800 --> 00:05:03,166
所以預期sut會出錯

129
00:05:03,166 --> 00:05:06,300
當資料無效時，對

130
00:05:06,300 --> 00:05:08,800
當我們以200的狀態碼完成時

131
00:05:08,800 --> 00:05:10,066
和無效的JSON

132
00:05:10,066 --> 00:05:13,100
完美，好的看起來對我來說很好

133
00:05:13,100 --> 00:05:16,133
讓我們看看我們是否可以構建，對和這個

134
00:05:16,133 --> 00:05:17,333
測試也通過了

135
00:05:17,333 --> 00:05:19,033
太棒了，但我希望看到一個

136
00:05:19,033 --> 00:05:20,466
失敗的測試，當這個

137
00:05:20,466 --> 00:05:21,166
失敗時會發生什麼

138
00:05:21,166 --> 00:05:24,300
對，好的我們有一個失敗的測試

139
00:05:24,300 --> 00:05:27,166
但我不喜歡錯誤消息

140
00:05:27,166 --> 00:05:28,466
出現在錯誤的地方，我希望能

141
00:05:28,466 --> 00:05:29,833
看到這個消息

142
00:05:29,833 --> 00:05:33,166
在這一行，對吧

143
00:05:33,166 --> 00:05:35,600
所以我們可以傳遞線和文件

144
00:05:35,600 --> 00:05:36,933
參數

145
00:05:36,933 --> 00:05:39,833
給assert equal函數，我們

146
00:05:39,833 --> 00:05:41,166
可以在這裡加上它

147
00:05:41,166 --> 00:05:43,333
帶有默認值，對，讓我們添加

148
00:05:43,333 --> 00:05:45,100
文件和行參數在那裡

149
00:05:45,100 --> 00:05:49,266
檔案，檔案，行數，行數

150
00:05:49,266 --> 00:05:51,433
很好，讓我們看看是否錯誤他現在變了

151
00:05:51,433 --> 00:05:53,833
到正確的地方

152
00:05:53,833 --> 00:05:56,066
它現在是，所以當它失敗時它

153
00:05:56,066 --> 00:05:56,933
失敗

154
00:05:56,933 --> 00:05:59,733
在我們應該查看的確切行數

155
00:05:59,733 --> 00:06:00,633
為了找出錯誤

156
00:06:00,633 --> 00:06:03,333
是的，很好，那麼讓我們把它放回去

157
00:06:03,333 --> 00:06:04,833
讓我們看看是否能通過

158
00:06:04,833 --> 00:06:07,733
仍然可以，讓我們試著重構

159
00:06:07,733 --> 00:06:09,033
其他測試也是一樣

160
00:06:09,033 --> 00:06:13,100
好的，所以我們可以在這裡使用相同的

161
00:06:13,100 --> 00:06:16,633
輔助函數，行動是

162
00:06:16,633 --> 00:06:18,800
伴隨著一個狀態碼完成

163
00:06:18,800 --> 00:06:21,266
是的，我們希望得到invalidData作為

164
00:06:21,266 --> 00:06:22,133
錯誤

165
00:06:22,133 --> 00:06:26,800
讓我們運行測試，太棒了

166
00:06:26,800 --> 00:06:32,400
現在，我們預期連接錯誤

167
00:06:32,400 --> 00:06:35,433
當我們完成一個客戶端

168
00:06:35,433 --> 00:06:38,633
錯誤，讓我們運行測試，也通過了

169
00:06:38,633 --> 00:06:39,166
很美，讓我們提交移除

170
00:06:39,166 --> 00:06:42,233
通過創建

171
00:06:42,233 --> 00:06:45,600
重複的測試代碼

172
00:06:45,600 --> 00:06:48,700
可重用的expect輔助函數方法

173
00:06:48,700 --> 00:06:54,133
就是這樣，好的，所以現在是順利的路徑

174
00:06:54,133 --> 00:06:56,466
但由於這是一組項目的集合

175
00:06:56,466 --> 00:06:58,400
我們從空的情況開始

176
00:06:58,400 --> 00:07:02,400
所以對於200沒有任何項目的交付 

177
00:07:02,400 --> 00:07:06,133
HTTP的響應是一個

178
00:07:06,133 --> 00:07:09,900
空的列表或者是空的

179
00:07:09,900 --> 00:07:13,266
JSON列表，所以設置

180
00:07:13,266 --> 00:07:17,333
與sut和client非常相似

181
00:07:17,333 --> 00:07:20,466
但現在我們想要記錄，對吧

182
00:07:20,466 --> 00:07:23,100
這些是這裡的feed項目，但我們的

183
00:07:23,100 --> 00:07:24,466
功能只能

184
00:07:24,466 --> 00:07:27,833
此時出現錯誤

185
00:07:27,833 --> 00:07:30,800
所以我們面臨著與先前同樣的困境

186
00:07:30,800 --> 00:07:31,333
就像之前一樣

187
00:07:31,333 --> 00:07:33,166
我們是否要有兩種可選類型？

188
00:07:33,166 --> 00:07:34,400
這裡的Error

189
00:07:34,400 --> 00:07:37,433
和FeedItems數組，或者我認為我們可以

190
00:07:37,433 --> 00:07:40,866
在這裡使用result類型，對，如我們

191
00:07:40,866 --> 00:07:42,300
之前所說

192
00:07:42,300 --> 00:07:44,233
當我們結合可選項時，我們只是

193
00:07:44,233 --> 00:07:45,733
指數性地增加

194
00:07:45,733 --> 00:07:47,566
路徑的數量，其中大部分只是

195
00:07:47,566 --> 00:07:48,800
無效的路徑

196
00:07:48,800 --> 00:07:51,833
所以讓我們就使用枚舉，對，所以自從

197
00:07:51,833 --> 00:07:53,100
我們將去改動簽名

198
00:07:53,100 --> 00:07:54,066
這個方法

199
00:07:54,066 --> 00:07:56,400
讓我們註解出目前我們在做什麼，

200
00:07:56,400 --> 00:07:58,300
這裡

201
00:07:58,300 --> 00:08:00,300
讓我們重構之前的測試

202
00:08:00,300 --> 00:08:01,500
接收一個結果類型

203
00:08:01,500 --> 00:08:04,233
這是準備下一步的步驟

204
00:08:04,233 --> 00:08:05,166
即將進行

205
00:08:05,166 --> 00:08:06,633
我喜歡這樣，並且我們已經有了這個

206
00:08:06,633 --> 00:08:08,466
期望方法，我們只需要修改它

207
00:08:08,466 --> 00:08:09,333
在一個地方

208
00:08:09,333 --> 00:08:11,333
對，這是一個好的重構

209
00:08:11,333 --> 00:08:13,500
完全同意，所以我们将替代

210
00:08:13,500 --> 00:08:15,566
capturedErrors我們將會獲得

211
00:08:15,566 --> 00:08:16,866
某種形式的捕獲

212
00:08:16,866 --> 00:08:21,433
結果，沒錯

213
00:08:21,433 --> 00:08:24,133
那麼在這個情況下結果類型是什麼呢？

214
00:08:24,133 --> 00:08:25,266
狀況

215
00:08:25,266 --> 00:08:27,733
對，我們有一個成功的案例

216
00:08:27,733 --> 00:08:28,400
其中包含

217
00:08:28,400 --> 00:08:31,433
一個FeedItems陣列，然後失敗

218
00:08:31,433 --> 00:08:34,633
帶有一個錯誤，好的，哪個錯誤？

219
00:08:34,633 --> 00:08:37,500
嗯，我們有上面的Error類型，對嗎？

220
00:08:37,500 --> 00:08:38,700
好的，所以這個Error

221
00:08:38,700 --> 00:08:41,666
對，完美的，RemoteFeedLoader

222
00:08:41,666 --> 00:08:42,766
Error類型

223
00:08:42,766 --> 00:08:45,200
好的，但是如果這是一個公共的enum


224
00:08:45,200 --> 00:08:46,766
暴露於測試中

225
00:08:46,766 --> 00:08:48,933
對，FeedItem也需要是

226
00:08:48,933 --> 00:08:50,933
公開的，對，我覺得現在該做了

227
00:08:50,933 --> 00:08:51,266
做吧

228
00:08:51,266 --> 00:08:54,466
好，那我們讓這個成為一個公開的

229
00:08:54,466 --> 00:08:57,666
結構，好的

230
00:08:57,666 --> 00:09:00,466
所以現在，當我們比較錯誤時需要

231
00:09:00,466 --> 00:09:00,866
把它

232
00:09:00,866 --> 00:09:03,900
包裹在一個failure result裡

233
00:09:03,900 --> 00:09:07,200
對，但我們正在使用insert equal，

234
00:09:07,200 --> 00:09:09,600
這意味著結果類型需要是

235
00:09:09,600 --> 00:09:10,933
Equatable，對

236
00:09:10,933 --> 00:09:12,933
我們應該讓結果類型變成Equatable嗎？

237
00:09:12,933 --> 00:09:14,066
對，我認為沒錯

238
00:09:14,066 --> 00:09:17,200
正如我們所說

239
00:09:17,200 --> 00:09:20,533
對，它會便於我們這裡的測試，

240
00:09:20,533 --> 00:09:23,100
我喜歡這樣，好的，這也是

241
00:09:23,100 --> 00:09:23,900
最簡單的步驟

242
00:09:23,900 --> 00:09:26,633
所以我們可以在未來重新思考這個，好

243
00:09:26,633 --> 00:09:29,433
所以我們讓這個成為Equatable

244
00:09:29,433 --> 00:09:31,666
但這個不能是Equatable，因為

245
00:09:31,666 --> 00:09:33,100
field item不是Equatable，所以我們

246
00:09:33,100 --> 00:09:34,066
必須要


247
00:09:34,066 --> 00:09:37,033
也讓 FeedItem 等同於我

248
00:09:37,033 --> 00:09:37,833
對於這個我很滿意

249
00:09:37,833 --> 00:09:40,300
它是數據，我認為這是個好的論點

250
00:09:40,300 --> 00:09:40,866
你知道

251
00:09:40,866 --> 00:09:42,933
為什麼它不會是 Equatable，為什麼

252
00:09:42,933 --> 00:09:44,933
你不應該能夠

253
00:09:44,933 --> 00:09:48,300
比較 FeedItems，所以現在我們的

254
00:09:48,300 --> 00:09:52,133
load 方法可以完成一個結果

255
00:09:52,133 --> 00:09:56,233
我們需要將

256
00:09:56,233 --> 00:09:59,433
我們的錯誤封裝到失敗的案例中，對

257
00:09:59,433 --> 00:10:00,233
就是這樣

258
00:10:00,233 --> 00:10:02,066
現在正在建構，並進行測試

259
00:10:02,066 --> 00:10:03,500
測試通過, 好的

260
00:10:03,500 --> 00:10:05,900
所以我們可能需要重新思考這個 Equatable

261
00:10:05,900 --> 00:10:08,066
在結果類型和 FeedItem 中，但

262
00:10:08,066 --> 00:10:10,633
我很樂意繼續進行，絕對的，我同意

263
00:10:10,633 --> 00:10:12,000
我們進行提交

264
00:10:12,000 --> 00:10:14,933
好的，但是我們不要提交已經被註解掉的測試

265
00:10:14,933 --> 00:10:16,233
對

266
00:10:16,233 --> 00:10:20,533
確實，我們暫時還用不到這個測試

267
00:10:20,533 --> 00:10:24,466
所以要加上 RemoteFeedLoader

268
00:10:24,466 --> 00:10:27,500
結果類型和成功

269
00:10:27,500 --> 00:10:31,200
以及失敗的案例，好的現在我認為我們

270
00:10:31,200 --> 00:10:32,000
可以繼續進行了

271
00:10:32,000 --> 00:10:35,433
在我們的測試中，我們也將會

272
00:10:35,433 --> 00:10:36,300
獲取

273
00:10:36,300 --> 00:10:39,333
結果，所以我把這裡複製過來

274
00:10:39,333 --> 00:10:41,900
對於我們要進行的動作

275
00:10:41,900 --> 00:10:43,200
我們希望完成

276
00:10:43,200 --> 00:10:46,700
並以200狀態碼

277
00:10:46,700 --> 00:10:49,900
和一個空的清單

278
00:10:49,900 --> 00:10:54,233
JSON，嗯，所以何謂空的

279
00:10:54,233 --> 00:10:57,833
清單JSON，我們可以創建一個字串

280
00:10:57,833 --> 00:11:01,433
包含著空的

281
00:11:01,433 --> 00:11:02,233
陣列的item鍵值

282
00:11:02,233 --> 00:11:05,200
來代表JSON所以這需要

283
00:11:05,200 --> 00:11:06,133
是一個有效的JSON

284
00:11:06,133 --> 00:11:10,700
對，所以這是一個包含有鍵值

285
00:11:10,700 --> 00:11:17,500
item以及內含空陣列的對象

286
00:11:17,500 --> 00:11:21,100
與我們的payload協議一致

287
00:11:21,100 --> 00:11:25,100
正確，所以現在我們預期成功

288
00:11:25,100 --> 00:11:25,900
在這裡

289
00:11:25,900 --> 00:11:28,800
一個帶有空陣列的成功，好的

290
00:11:28,800 --> 00:11:30,366
我們要進行斷言

291
00:11:30,366 --> 00:11:34,000
確定capturedResults

292
00:11:34,000 --> 00:11:36,700
等於只有一個

293
00:11:36,700 --> 00:11:37,500
completion的陣列

294
00:11:37,500 --> 00:11:40,233
並且它是一個帶有空FeedItems陣列的成功

295
00:11:40,233 --> 00:11:41,100
的FeedItems

296
00:11:41,100 --> 00:11:45,100
對，希望會失敗，嗯


297
00:11:45,100 --> 00:11:48,533
現在它運行得不錯，我們可以開始增加

298
00:11:48,533 --> 00:11:49,733
一些邏輯

299
00:11:49,733 --> 00:11:51,733
好，那麼我們最少需要做什麼來

300
00:11:51,733 --> 00:11:53,200
讓這個通過

301
00:11:53,200 --> 00:11:57,200
那麼我們需要獲取我們的數據在這裡

302
00:11:57,200 --> 00:12:01,666
和我們的響應

303
00:12:01,666 --> 00:12:03,666
為了讓這個通過，我們只需要

304
00:12:03,666 --> 00:12:05,100
確保我們能夠

305
00:12:05,100 --> 00:12:07,100
轉換這個 JSON 對吧，就是

306
00:12:07,100 --> 00:12:09,200
檢查它是否是有效的 JSON

307
00:12:09,200 --> 00:12:12,133
是的，基本上我們可以使用 if let

308
00:12:12,133 --> 00:12:13,033
JSON

309
00:12:13,033 --> 00:12:18,466
等於 JSONSerialization.jsonObject

310
00:12:18,466 --> 00:12:22,000
與數據對吧

311
00:12:22,000 --> 00:12:25,033
然後我們成功完成並讓我們

312
00:12:25,033 --> 00:12:27,100
傳遞一個空的 FeedItems 數組，這就是

313
00:12:27,100 --> 00:12:30,366
我們所有需要的，否則我們完成

314
00:12:30,366 --> 00:12:33,600
失敗 invalidData 出了什麼問題

315
00:12:33,600 --> 00:12:34,300
這裡

316
00:12:34,300 --> 00:12:39,266
這個方法拋出，所以我們需要使用 try

317
00:12:39,266 --> 00:12:41,666
既然我們正在使用響應或者 JSON

318
00:12:41,666 --> 00:12:43,033
我們只需要使用

319
00:12:43,033 --> 00:12:46,133
下劃線 讓我們看看

320
00:12:46,133 --> 00:12:49,666
它通過了，讓我們提交

321
00:12:49,666 --> 00:12:53,100
所以傳遞空的 items 陣列

322
00:12:53,100 --> 00:12:56,533
在 200 HTTP 回應時

323
00:12:56,533 --> 00:12:59,833
帶有 JSON 空列表

324
00:12:59,833 --> 00:13:02,133
我想我們甚至可以在這裡使用 expect

325
00:13:02,133 --> 00:13:03,266
這個方法

326
00:13:03,266 --> 00:13:05,833
在這個測試中對吧，所以這個設置非常

327
00:13:05,833 --> 00:13:07,333
類似於錯誤的情況

328
00:13:07,333 --> 00:13:09,500
是的，好的，所以我們可以做一些重構

329
00:13:09,500 --> 00:13:11,200
而不是說完成錯誤

330
00:13:11,200 --> 00:13:16,300
我們以結果完成，是的

331
00:13:16,300 --> 00:13:18,000
我們不需要再包裝這個了

332
00:13:18,000 --> 00:13:20,000
我們只需要確定我們正在與

333
00:13:20,000 --> 00:13:21,033
一個結果完成

334
00:13:21,033 --> 00:13:24,133
對，這個結果是Equatable，所以我們可以

335
00:13:24,133 --> 00:13:24,866
這麼做

336
00:13:24,866 --> 00:13:26,366
但這將會打破我們當前的

337
00:13:26,366 --> 00:13:29,200
測試，讓我們一個接一個地修正，我們只需要

338
00:13:29,200 --> 00:13:31,833
將它包裝起來

339
00:13:31,833 --> 00:13:38,000
在失敗的情況下，這裡也是一樣

340
00:13:38,000 --> 00:13:43,100
也在這裡

341
00:13:43,100 --> 00:13:45,033
好的，它還在通過，所以現在我們可以

342
00:13:45,033 --> 00:13:46,633
使用相同的

343
00:13:46,633 --> 00:13:51,100
輔助方法在這裡美觀

344
00:13:51,100 --> 00:13:54,133
預期sut完成

345
00:13:54,133 --> 00:13:58,366
用成功與一個空的

346
00:13:58,366 --> 00:14:01,433
陣列當

347
00:14:01,433 --> 00:14:05,600
我們以一個空的JSON列表來完成，對吧

348
00:14:05,600 --> 00:14:09,266
來運行，完美

349
00:14:09,266 --> 00:14:11,100
對，我認為這閱讀起來非常順暢

350
00:14:11,100 --> 00:14:13,033
順便說下我喜歡這樣

351
00:14:13,033 --> 00:14:16,633
讓我們提交重構助手的修改

352
00:14:16,633 --> 00:14:20,366
改為接收結果而不是

353
00:14:20,366 --> 00:14:24,166
錯誤類型，對，以便

354
00:14:24,166 --> 00:14:27,500
不同

355
00:14:27,500 --> 00:14:31,733
可能的結果的重複利用，就是這樣

356
00:14:31,733 --> 00:14:35,033
太棒了

357
00:14:35,033 --> 00:14:38,233
所以下一個測試就是實戰了

358
00:14:38,233 --> 00:14:41,266
我們即將傳遞 FeedItems 條目

359
00:14:41,266 --> 00:14:45,266
對，200的HTTP

360
00:14:45,266 --> 00:14:48,700
回應是在我們有有效的JSON

361
00:14:48,700 --> 00:14:49,666
條目時

362
00:14:49,666 --> 00:14:51,833
所以現在它不是空的，也不是無效的

363
00:14:51,833 --> 00:14:52,700
JSON

364
00:14:52,700 --> 00:14:55,433
對，這不是無效的HTTP回應

365
00:14:55,433 --> 00:14:56,000
這就是

366
00:14:56,000 --> 00:14:58,633
快樂路徑，像是我們擁有物品，我們

367
00:14:58,633 --> 00:14:59,733
有我們需要的一切

368
00:14:59,733 --> 00:15:03,500
我們只需要對它進行映射，是的所以

369
00:15:03,500 --> 00:15:06,700
設置是相同的，對

370
00:15:06,700 --> 00:15:09,433
但現在我們需要創建一些物品

371
00:15:09,433 --> 00:15:11,333
我們可以等價的

372
00:15:11,333 --> 00:15:14,933
比如說，物品一

373
00:15:14,933 --> 00:15:17,600
但如果我沒記錯的話，我們無法創建

374
00:15:17,600 --> 00:15:19,166
FeedItems

375
00:15:19,166 --> 00:15:21,100
對，我們無法進行存取至

376
00:15:21,100 --> 00:15:22,533
初始化器

377
00:15:22,533 --> 00:15:25,600
對，我們需要解決這個問題

378
00:15:25,600 --> 00:15:29,033
那是因為它的初始化器預設為內部的

379
00:15:29,033 --> 00:15:30,000
預設

380
00:15:30,000 --> 00:15:31,900
而我們的模組無法存取

381
00:15:31,900 --> 00:15:33,100
內部類型

382
00:15:33,100 --> 00:15:35,433
正確，所以我們可以將此

383
00:15:35,433 --> 00:15:37,900
模組以測試的方式導入

384
00:15:37,900 --> 00:15:40,300
或者為

385
00:15:40,300 --> 00:15:41,033
結構體創建一個公開的初始化器

386
00:15:41,033 --> 00:15:44,000
對，但如果我們看架構的話

387
00:15:44,000 --> 00:15:44,933
其他模組

388
00:15:44,933 --> 00:15:47,333
將會實現這些接口並使用

389
00:15:47,333 --> 00:15:48,000
這些

390
00:15:48,000 --> 00:15:50,366
FeedItem模型，這意味著他們可能會

391
00:15:50,366 --> 00:15:51,266
創建它

392
00:15:51,266 --> 00:15:53,600
所以如果其他模組要去創建

393
00:15:53,600 --> 00:15:54,933
FeedItems

394
00:15:54,933 --> 00:15:58,933
我們需要有一個公開的初始化器

395
00:15:58,933 --> 00:16:01,266
所以現在我們將要

396
00:16:01,266 --> 00:16:05,333
手動執行這個操作

397
00:16:05,333 --> 00:16:08,800
所以描述，這是個選擇性的字串

398
00:16:08,800 --> 00:16:11,900
地點，這也是選擇性的字串

399
00:16:11,900 --> 00:16:15,333
imageURL則是一個必要的參數

400
00:16:15,333 --> 00:16:22,866
現在我們可以設置屬性

401
00:16:22,866 --> 00:16:25,833
好的好的，現在我們應該可以使用

402
00:16:25,833 --> 00:16:26,800
初始化器

403
00:16:26,800 --> 00:16:30,533
對，我們可以使用了，太好了，所以讓我們

404
00:16:30,533 --> 00:16:32,866
創建任何的UUID，他們總是獨一無二的

405
00:16:32,866 --> 00:16:33,900
每次我們創建他都是不同的

406
00:16:33,900 --> 00:16:36,700
讓我們先有這

407
00:16:36,700 --> 00:16:38,000
第一個項目，

408
00:16:38,000 --> 00:16:41,333
沒有描述，好的，也沒有位置

409
00:16:41,333 --> 00:16:43,733
但它應該有一個圖片URL，所以讓我們

410
00:16:43,733 --> 00:16:46,000
這裡創建一個URL

411
00:16:46,000 --> 00:16:50,000
a-url.com

412
00:16:50,000 --> 00:16:53,333
我們也需要它的JSON表示形式

413
00:16:53,333 --> 00:16:57,600
好的，那就是

414
00:16:57,600 --> 00:17:00,800
一個字典，第一個鍵為

415
00:17:00,800 --> 00:17:04,766
id，它應該有item1

416
00:17:04,766 --> 00:17:07,833
的.id，但是要以String形式，對

417
00:17:07,833 --> 00:17:10,233
所以我們可以將這個UUID轉換為

418
00:17:10,233 --> 00:17:11,733
String

419
00:17:11,733 --> 00:17:14,766
對，但我們不能使用id

420
00:17:14,766 --> 00:17:17,900
屬性，對，讓我們將其公開

421
00:17:17,900 --> 00:17:19,100
實際上讓我們都公開它們

422
00:17:19,100 --> 00:17:20,300
公開，因為我們需要所有的

423
00:17:20,300 --> 00:17:22,133
這些


424
00:17:22,133 --> 00:17:24,700
這個 FeedItem 沒有

425
00:17:24,700 --> 00:17:25,900
描繪

426
00:17:25,900 --> 00:17:28,400
而在我們的 JSON合約中，你不需

427
00:17:28,400 --> 00:17:29,566
有描繪

428
00:17:29,566 --> 00:17:32,300
就不會加到 JSON payload 中

429
00:17:32,300 --> 00:17:34,300
所以我們不會加入描繪

430
00:17:34,300 --> 00:17:37,666
或位置，但它需要一個圖片

431
00:17:37,666 --> 00:17:41,566
URL，關鍵路徑就是圖像

432
00:17:41,566 --> 00:17:44,766
所以 item1.imageURL

433
00:17:44,766 --> 00:17:47,333
.absoluteString 對，我認為這就是

434
00:17:47,333 --> 00:17:49,500
對，應該是

435
00:17:49,500 --> 00:17:51,200
對，我猜這就是 item1

436
00:17:51,200 --> 00:17:53,266
JSON就是如此

437
00:17:53,266 --> 00:17:56,400
那我們再創建另一個，item2

438
00:17:56,400 --> 00:18:00,633
對，這是一個帶有另一個 UUID 的 FeedItem

439
00:18:00,633 --> 00:18:01,500
但是這個將會有一個

440
00:18:01,500 --> 00:18:04,000
描寫，一個描寫，並且

441
00:18:04,000 --> 00:18:12,833
一個地點，以及另外一個 URL

442
00:18:12,833 --> 00:18:14,766
很棒

443
00:18:14,766 --> 00:18:19,433
而 item2JSON 也是一個字典

444
00:18:19,433 --> 00:18:23,333
帶有 id的 item2.id

445
00:18:23,333 --> 00:18:26,633
.uuidString 這個帶有一個描寫

446
00:18:26,633 --> 00:18:30,066
並且關鍵路徑是 description

447
00:18:30,066 --> 00:18:33,266
它有一個位置 item2.location


448
00:18:33,266 --> 00:18:42,533
且它也有一個圖像，對吧

449
00:18:42,533 --> 00:18:44,766
所以那需要很多設定，是的我不

450
00:18:44,766 --> 00:18:46,933
認為我們已經完成了

451
00:18:46,933 --> 00:18:48,933
所以那些是我們正在映射的項目

452
00:18:48,933 --> 00:18:51,033
對了，我們要有我們的項目

453
00:18:51,033 --> 00:18:53,900
一和二，所以我們可以比較它

454
00:18:53,900 --> 00:18:54,700
同時也是它的

455
00:18:54,700 --> 00:18:56,933
JSON表像，對，所以我們需要將

456
00:18:56,933 --> 00:18:58,533
這些包裝到項目中

457
00:18:58,533 --> 00:19:01,733
對應到我們的 

458
00:19:01,733 --> 00:19:04,766
負荷契約，很好，那是根

459
00:19:04,766 --> 00:19:08,133
節點，對吧，所以讓我們創建我們的

460
00:19:08,133 --> 00:19:12,466
項目JSON，這是

461
00:19:12,466 --> 00:19:15,600
一個帶有項目 keypath的字典且

462
00:19:15,600 --> 00:19:16,533
它是一個陣列

463
00:19:16,533 --> 00:19:19,666
含有item1JSON和

464
00:19:19,666 --> 00:19:24,933
item2JSON，對，就是這樣

465
00:19:24,933 --> 00:19:27,600
然後現在我們可以使用我們的期望

466
00:19:27,600 --> 00:19:29,266
期望sut

467
00:19:29,266 --> 00:19:34,000
成功完成

468
00:19:34,000 --> 00:19:37,200
與我們的項目一和項目二

469
00:19:37,200 --> 00:19:42,066
對了，當

470
00:19:42,066 --> 00:19:45,500
client成功完成並且我們的

471
00:19:45,500 --> 00:19:46,633
JSON數據

472
00:19:46,633 --> 00:19:50,533
對了，所以我們需要創建我們的JSON數據

473
00:19:50,533 --> 00:19:51,733
我認為我們可以使用JSON

474
00:19:51,733 --> 00:19:54,466
在這裡進行序列化，以JSON格式處理數據

475
00:19:54,466 --> 00:19:55,433
對象

476
00:19:55,433 --> 00:19:59,600
項目JSON，對，我們需要試一試這個

477
00:19:59,600 --> 00:20:01,833
是的，因為它會抛出異常，既然我們知道

478
00:20:01,833 --> 00:20:03,200
這是一個有效的JSON

479
00:20:03,200 --> 00:20:06,066
我們可以強制嘗試，我認為這就是

480
00:20:06,066 --> 00:20:07,600
測試

481
00:20:07,600 --> 00:20:10,000
對，它失敗了，太好了，所以現在

482
00:20:10,000 --> 00:20:11,100
該我們了

483
00:20:11,100 --> 00:20:14,400
將這些項目反序列化，對，決定

484
00:20:14,400 --> 00:20:18,400
時間到

485
00:20:18,400 --> 00:20:21,500
我們可以使用Decodable，對的

486
00:20:21,500 --> 00:20:24,700
可以擴展FeedItem

487
00:20:24,700 --> 00:20:28,466
使其符合Decodable，然後我們就可以

488
00:20:28,466 --> 00:20:30,933
解碼JSON並返回Feed

489
00:20:30,933 --> 00:20:31,500
項目

490
00:20:31,500 --> 00:20:34,300
在FeedLoader中，因為這個陣列

491
00:20:34,300 --> 00:20:35,333
在裡面

492
00:20:35,333 --> 00:20:37,666
這個項目的關鍵路徑中，我們需要創建這個

493
00:20:37,666 --> 00:20:38,766
根節點

494
00:20:38,766 --> 00:20:43,200
首先，我們還可以將其設置為私有

495
00:20:43,200 --> 00:20:46,933
所以它應該有一個項目的陣列

496
00:20:46,933 --> 00:20:51,600
並且它應該是Decodable的

497
00:20:51,600 --> 00:20:55,833
所以現在我們可以使用我們的JSONDecoder

498
00:20:55,833 --> 00:20:59,500
將我們的 root

499
00:20:59,500 --> 00:21:02,933
元素從收到的數據中解碼

500
00:21:02,933 --> 00:21:05,033
如果我們有一個 root node，我們可以

501
00:21:05,033 --> 00:21:07,033
成功地完成

502
00:21:07,033 --> 00:21:09,500
包含 root node 内的項目，但是

503
00:21:09,500 --> 00:21:10,466
你可以得到

504
00:21:10,466 --> 00:21:12,633
免費的 Decodable 實現，所以

505
00:21:12,633 --> 00:21:13,833
編譯器可以

506
00:21:13,833 --> 00:21:15,900
為我們實現，FeedItem 也需要

507
00:21:15,900 --> 00:21:17,500
實現 Decodable

508
00:21:17,500 --> 00:21:21,433
是的，既然我們的 key 不匹配

509
00:21:21,433 --> 00:21:24,466
我們將不得不實現 JSON key 的

510
00:21:24,466 --> 00:21:25,900
CodingKeys

511
00:21:25,900 --> 00:21:29,033
針對 imageURL 的 enum

512
00:21:29,033 --> 00:21:31,833
因為在我們的 FeedItem 模型裡，

513
00:21:31,833 --> 00:21:32,633
我們稱呼它為 image

514
00:21:32,633 --> 00:21:35,833
URL ，而在 JSON 裡僅為 image，所以它們

515
00:21:35,833 --> 00:21:37,333
不匹配

516
00:21:37,333 --> 00:21:40,133
所以我們需要提供一些映射

517
00:21:40,133 --> 00:21:41,500
指令

518
00:21:41,500 --> 00:21:44,533
對，我們會用 Decodable 來實現

519
00:21:44,533 --> 00:21:48,066
我們的 CodingKeys

520
00:21:48,066 --> 00:21:51,200
那麼 id 就可以了，它相匹配

521
00:21:51,200 --> 00:21:54,300
description 也對，location

522
00:21:54,300 --> 00:21:55,333
也對

523
00:21:55,333 --> 00:21:58,533
但是 imageURL 不對，所以我們

524
00:21:58,533 --> 00:22:00,000
需要告訴它

525
00:22:00,000 --> 00:22:02,300
我們要對應的關鍵是什麼，是的，

526
00:22:02,300 --> 00:22:03,433
它的映像

527
00:22:03,433 --> 00:22:06,766
好的，現在讓我們來執行測試

528
00:22:06,766 --> 00:22:09,333
好了，現在通過了，很好，

529
00:22:09,333 --> 00:22:10,700
讓我們提交

530
00:22:10,700 --> 00:22:14,866
並清理混亂，所以交付

531
00:22:14,866 --> 00:22:18,633
項目陣列在200

532
00:22:18,633 --> 00:22:22,066
HTTP響應與JSON

533
00:22:22,066 --> 00:22:25,600
項目，所以我們這裡還有一些清理工作要做，

534
00:22:25,600 --> 00:22:28,000
但同樣困擾我們的還有

535
00:22:28,000 --> 00:22:28,866
這個鍵

536
00:22:28,866 --> 00:22:32,233
影像這是個API的細節

537
00:22:32,233 --> 00:22:35,333
在這個FeedItem模型中洩漏出來

538
00:22:35,333 --> 00:22:38,533
它應該對API保持中立

539
00:22:38,533 --> 00:22:39,600
模塊

540
00:22:39,600 --> 00:22:42,766
對的，所以FeedItem應該屬於

541
00:22:42,766 --> 00:22:45,600
在我們的FeedLoader模塊，正如我們在

542
00:22:45,600 --> 00:22:46,700
圖中所示，

543
00:22:46,700 --> 00:22:49,200
它並不應該知道任何形式的

544
00:22:49,200 --> 00:22:51,200
來自其他模塊的實現

545
00:22:51,200 --> 00:22:53,666
比如說API，例如，沒有

546
00:22:53,666 --> 00:22:55,100
箭頭

547
00:22:55,100 --> 00:22:58,133
來自FeedLoader指向

548
00:22:58,133 --> 00:23:00,766
至 RemoteFeedLoader 或是 API

549
00:23:00,766 --> 00:23:01,833
模塊，

550
00:23:01,833 --> 00:23:03,200
意味著我們不希望 Feed

551
00:23:03,200 --> 00:23:05,033
這裡是載入器模組

552
00:23:05,033 --> 00:23:08,000
要依賴的特性模組

553
00:23:08,000 --> 00:23:09,266
實作細節

554
00:23:09,266 --> 00:23:11,266
例如我們可能創建

555
00:23:11,266 --> 00:23:12,300
來自於

556
00:23:12,300 --> 00:23:14,766
LocalFeedLoader表示的FeedItems，並且

557
00:23:14,766 --> 00:23:16,766
你可能也需要使用Decodable

558
00:23:16,766 --> 00:23:18,700
對，但如果API中的某些東西改變了

559
00:23:18,700 --> 00:23:20,400
例如

560
00:23:20,400 --> 00:23:23,333
他們在某個時候將這些重新命名為image-url

561
00:23:23,333 --> 00:23:24,633
我們可能會打破其他模組

562
00:23:24,633 --> 00:23:27,200
如果我們將此鍵路徑的知識保留在共享模組中

563
00:23:27,200 --> 00:23:28,300
我們不想因為API的更改而破壞UI或

564
00:23:28,300 --> 00:23:31,333
資料庫，對吧？

565
00:23:31,333 --> 00:23:34,066
然後接下來問題就是我

566
00:23:34,066 --> 00:23:36,400
想我們是不是只為了一個簡單的字串去做這樣的事

567
00:23:36,400 --> 00:23:38,133
就是這個圖像字串，絶對地

568
00:23:38,133 --> 00:23:40,133
好，那我們首先修復測試

569
00:23:40,133 --> 00:23:41,200
我們會繼續做的

570
00:23:41,200 --> 00:23:44,233
好了，所以我們先修測試

571
00:23:44,233 --> 00:23:46,133
然後我們再繼續著手進行

572
00:23:46,133 --> 00:23:47,666
我認為對於一次測試

573
00:23:47,666 --> 00:23:49,500
這需要很多設定，

574
00:23:49,500 --> 00:23:52,400
我們絕對可以將這個簡化。

575
00:23:52,400 --> 00:23:54,300
提供某種工廠方法

576
00:23:54,300 --> 00:23:55,900
為FeedItems

577
00:23:55,900 --> 00:23:59,100
好，那我們就從這裡開始，所以工廠

578
00:23:59,100 --> 00:23:59,666
方法

579
00:23:59,666 --> 00:24:02,933
makeItem，對，我喜歡這個

580
00:24:02,933 --> 00:24:07,266
並且這需要一個UUID，一個描述

581
00:24:07,266 --> 00:24:08,700
對，我猜這個可以預設為

582
00:24:08,700 --> 00:24:11,100
nil，以及一個位置

583
00:24:11,100 --> 00:24:14,766
是的，還有圖片

584
00:24:14,766 --> 00:24:18,066
URL，並且這將返回我們的

585
00:24:18,066 --> 00:24:21,833
FeedItem，對，那麼我們就可以

586
00:24:21,833 --> 00:24:24,933
根據這些創建我們的項目

587
00:24:24,933 --> 00:24:28,466
給定的值

588
00:24:28,466 --> 00:24:31,833
並返回它，好的，但它不會

589
00:24:31,833 --> 00:24:32,766
節省大量

590
00:24:32,766 --> 00:24:34,933
的代碼行數，對吧，如果這個方法

591
00:24:34,933 --> 00:24:36,066
還創建了

592
00:24:36,066 --> 00:24:39,200
JSON對吧，所以我們可以回傳我們的

593
00:24:39,200 --> 00:24:40,700
模型

594
00:24:40,700 --> 00:24:43,500
和一個JSON表示，那就是一個

595
00:24:43,500 --> 00:24:44,400
字典

596
00:24:44,400 --> 00:24:47,900
string any, 對，我喜歡這樣，

597
00:24:47,900 --> 00:24:50,700
因為JSON是實際的

598
00:24:50,700 --> 00:24:51,666
本地

599
00:24:51,666 --> 00:24:54,133
模型的鏡像，我們在這裡得到所有的值，

600
00:24:54,133 --> 00:24:55,100
所以我們可以這樣做


601
00:24:55,100 --> 00:24:58,833
所以它需要 id 也需要

602
00:24:58,833 --> 00:25:00,866
描述

603
00:25:00,866 --> 00:25:04,400
位置和圖像的

604
00:25:04,400 --> 00:25:07,600
URL 好的，就是這些，然後我們返回

605
00:25:07,600 --> 00:25:08,133
項目

606
00:25:08,133 --> 00:25:12,633
和JSON非常好

607
00:25:12,633 --> 00:25:14,700
好，但由於描述和

608
00:25:14,700 --> 00:25:15,666
位置

609
00:25:15,666 --> 00:25:18,700
是可選的，我看見了，是的，類型

610
00:25:18,700 --> 00:25:21,433
在這裡沒有匹配，對，我們可以簡化

611
00:25:21,433 --> 00:25:23,266
它成一個新的字典並刪除

612
00:25:23,266 --> 00:25:25,900
新的值，對，所以我們可以簡化

613
00:25:25,900 --> 00:25:26,766
成一個新的

614
00:25:26,766 --> 00:25:29,733
具有正確類型 String 的

615
00:25:29,733 --> 00:25:31,100
Any 的字典

616
00:25:31,100 --> 00:25:33,600
然後我們可以得到我們累積的新的

617
00:25:33,600 --> 00:25:34,300
字典

618
00:25:34,300 --> 00:25:37,433
和元素 如果

619
00:25:37,433 --> 00:25:40,533
元素元組中有值

620
00:25:40,533 --> 00:25:44,233
我們將其添加到累積字典中

621
00:25:44,233 --> 00:25:46,233
否則我們就不添加，所以我們正在做的

622
00:25:46,233 --> 00:25:48,066
就是刪除新值

623
00:25:48,066 --> 00:25:50,533
並且在 Swift 5中有一個新的 compact

624
00:25:50,533 --> 00:25:52,400
Map 它正好就是這樣做的

625
00:25:52,400 --> 00:25:55,433
但我們還沒有這個，沒關係

626
00:25:55,433 --> 00:25:58,133
也許編譯器會在我們

627
00:25:58,133 --> 00:25:59,433
遷移時警告我們

628
00:25:59,433 --> 00:26:03,100
所以現在我們可以使用我們新的輔助方法

629
00:26:03,100 --> 00:26:05,833
是的，創建項目，我們不再需要

630
00:26:05,833 --> 00:26:07,600
item JSON 了

631
00:26:07,600 --> 00:26:09,433
或者在這種情況下註解和位置

632
00:26:09,433 --> 00:26:11,333
項目和所有的項目，但我們不需要

633
00:26:11,333 --> 00:26:13,333
字典，非常好

634
00:26:13,333 --> 00:26:15,333
我們也可以將這點放為一行

635
00:26:15,333 --> 00:26:17,266
好極了

636
00:26:17,266 --> 00:26:19,100
但現在是 item1.json

637
00:26:19,100 --> 00:26:22,400
和 item2.json 這是 item1

638
00:26:22,400 --> 00:26:26,633
.model

639
00:26:26,633 --> 00:26:27,100
和 item2.model 你甚至可以

640
00:26:27,100 --> 00:26:30,300
把這個放入一個變數中

641
00:26:30,300 --> 00:26:31,500
也可以，這樣短多了

642
00:26:31,500 --> 00:26:35,266
我喜歡這樣，你覺得怎麼樣？對，

643
00:26:35,266 --> 00:26:37,833
絕對如此

644
00:26:37,833 --> 00:26:38,533
我覺得這樣清爽多了，還有其他

645
00:26:38,533 --> 00:26:40,933
我們能做的嗎？ 

646
00:26:40,933 --> 00:26:41,833
我們可以擺脫 JSON

647
00:26:41,833 --> 00:26:43,833
序列化在這裡，我認為這是測試中的

648
00:26:43,833 --> 00:26:45,433
一個實現細節

649
00:26:45,433 --> 00:26:47,266
也許我們可以有一個功能隱藏

650
00:26:47,266 --> 00:26:50,000
那個。

651
00:26:50,000 --> 00:26:50,466
如何

652
00:26:50,466 --> 00:26:52,866
我們序列化 JSON，好像是說

653
00:26:52,866 --> 00:26:54,533
makeItemsJSON

654
00:26:54,533 --> 00:26:57,666
對對，那會接收一個

655
00:26:57,666 --> 00:27:00,700
陣列，對嗎

656
00:27:00,700 --> 00:27:04,700
items JSON 對，並返回

657
00:27:04,700 --> 00:27:09,200
數據，所以現在我們可以進行

658
00:27:09,200 --> 00:27:14,533
items JSON 和序列化的

659
00:27:14,533 --> 00:27:17,433
帶到這裡，我們只是用這個替換

660
00:27:17,433 --> 00:27:18,633
items array

661
00:27:18,633 --> 00:27:22,866
對，我們可以返回，就這樣

662
00:27:22,866 --> 00:27:25,433
甚至使用簡短名稱，這裡我喜歡

663
00:27:25,433 --> 00:27:25,900
這樣，好的

664
00:27:25,900 --> 00:27:30,633
一行，美麗。所以我們現在可以說

665
00:27:30,633 --> 00:27:34,766
make items JSON，我們不需要這個

666
00:27:34,766 --> 00:27:39,033
再也不用了，看看它是否仍然通過

667
00:27:39,033 --> 00:27:42,066
太棒了，我喜歡這個測試，它

668
00:27:42,066 --> 00:27:44,233
又短又清楚，非常

669
00:27:44,233 --> 00:27:45,200
清楚，對

670
00:27:45,200 --> 00:27:47,333
我剛要說那個，好，我們來

671
00:27:47,333 --> 00:27:49,100
提交這個

672
00:27:49,100 --> 00:27:53,333
因此創建工廠方法以簡化

673
00:27:53,333 --> 00:27:57,200
測試設定，好，我們是否可以

674
00:27:57,200 --> 00:27:58,066
重構

675
00:27:58,066 --> 00:28:01,033
更多，再我們處理 Decodable

676
00:28:01,033 --> 00:28:02,866
FeedItem


677
00:28:02,866 --> 00:28:04,933
讓我有點不確定，有一件事一直困擾著我

678
00:28:04,933 --> 00:28:06,700
我們從未使用過回應

679
00:28:06,700 --> 00:28:09,733
這是對的，但為什麼會這樣呢？

680
00:28:09,733 --> 00:28:12,933
對，基本上我們也沒有

681
00:28:12,933 --> 00:28:14,300
使用那裡的狀態代碼

682
00:28:14,300 --> 00:28:16,633
這的確是真的，但我們為此進行了測試

683
00:28:16,633 --> 00:28:18,066
對，這是的

684
00:28:18,066 --> 00:28:20,766
所以這意味著如果我們用一個

685
00:28:20,766 --> 00:28:22,233
有效的JSON完成，

686
00:28:22,233 --> 00:28:24,466
但使用錯誤的狀態代碼，我們將

687
00:28:24,466 --> 00:28:26,366
將它映射，所以我們只是忽略了狀態代碼

688
00:28:26,366 --> 00:28:28,233
這並不是我們想要的

689
00:28:28,233 --> 00:28:33,666
那我們看看我們的設定吧

690
00:28:33,666 --> 00:28:36,133
好的，我們在這裡給一個預設的數據，

691
00:28:36,133 --> 00:28:37,266
這是問題所在

692
00:28:37,266 --> 00:28:40,133
對，讓我移除它，看看會在哪裡出錯

693
00:28:40,133 --> 00:28:42,833
嗯，我們應該更明確

694
00:28:42,833 --> 00:28:45,433
我們傳遞什麼類型的數據

695
00:28:45,433 --> 00:28:45,900
當我們

696
00:28:45,900 --> 00:28:47,900
遇到錯誤的狀態代碼時，

697
00:28:47,900 --> 00:28:50,633
對，所以我們現在需要傳遞一些數據，我

699
00:28:53,200 --> 00:28:55,266
我們可以在這裡傳遞有效的JSON

700
00:28:55,266 --> 00:28:57,333
這基本上會強迫我們

701
00:28:57,333 --> 00:28:59,666
檢查嘿，我們需要這個200的狀態碼

702
00:28:59,666 --> 00:29:00,366
就在那裡

703
00:29:00,366 --> 00:29:01,733
即使我們只有有效的JSON，也不重要

704
00:29:01,733 --> 00:29:03,833
我們需要兩者都有

705
00:29:03,833 --> 00:29:06,766
好，所以我們可以使用makeItemsJSON

706
00:29:06,766 --> 00:29:08,366
那能創建一個有效的JSON

707
00:29:08,366 --> 00:29:11,333
對，只是沒有項目，很簡單，它是有效的，但是

708
00:29:11,333 --> 00:29:12,133
沒有東西可以映射到那裡，我喜歡這樣

709
00:29:12,133 --> 00:29:14,633
我想這應該可以辦到

710
00:29:14,633 --> 00:29:16,066
對，哦，它沒有通過，太棒了

711
00:29:16,066 --> 00:29:19,900
很好，讓我現在來獲取回應

712
00:29:19,900 --> 00:29:22,466
讓我們來檢查一下

713
00:29:22,466 --> 00:29:23,900
回應狀態碼是200

714
00:29:23,900 --> 00:29:27,600
我們可以將它映射過來

715
00:29:27,600 --> 00:29:32,133
現在我對這個滿意，讓我們提交吧

716
00:29:32,133 --> 00:29:35,433
所以使用明確的JSON數據

717
00:29:35,433 --> 00:29:39,100
對於非200 HTTP

718
00:29:39,100 --> 00:29:42,700
回應測試，只是為了確保我們

719
00:29:42,700 --> 00:29:45,900
在這裡做的是正確的事情

720
00:29:45,900 --> 00:29:47,433
我們在這裡做的事情才是正確的

721
00:29:47,433 --> 00:29:49,733
好，現在是我們應對的時間了

722
00:29:49,733 --> 00:29:51,833
面對這個Decodable的東西

723
00:29:51,833 --> 00:29:55,100
對，正如我們所說的這個圖片

724
00:29:55,100 --> 00:29:57,600
keypath這個字串使一個

725
00:29:57,600 --> 00:29:59,666
API的實現細節洩漏出來

726
00:29:59,666 --> 00:30:02,466
進入FeedItem模型而這是API

727
00:30:02,466 --> 00:30:03,433
特有的

728
00:30:03,433 --> 00:30:05,200
如果這在API中改變，我們可能會

729
00:30:05,200 --> 00:30:07,100
破壞其他與API無關的模塊

730
00:30:07,100 --> 00:30:08,133
因此我不認為這關於keypath的知識

731
00:30:08,133 --> 00:30:11,200
應該在模塊中，問題是

732
00:30:11,200 --> 00:30:12,133
如果你將Decodable實現進入

733
00:30:12,133 --> 00:30:14,133
你的型別中

734
00:30:14,133 --> 00:30:15,833
你只能實現它一次，對嗎，所以

735
00:30:15,833 --> 00:30:16,766
你的意思是

736
00:30:16,766 --> 00:30:19,500
你不能將Decodable的擴展放在一個

737
00:30:19,500 --> 00:30:20,000
架構中

738
00:30:20,000 --> 00:30:21,733
讓我說，在一種右架構中有一個Decodable擴展，

739
00:30:21,733 --> 00:30:23,433
另一個右架構中有另一個Decodable擴展，

740
00:30:23,433 --> 00:30:25,433
對於同一種型別，是的，這就是

741
00:30:25,433 --> 00:30:27,033
一個問題，

742
00:30:27,033 --> 00:30:29,266
所以，

743
00:30:29,266 --> 00:30:30,700
這裡的建議是創建一個單獨的

744
00:30:30,700 --> 00:30:32,533
模型來表示API的FeedItem，

745
00:30:32,533 --> 00:30:35,333
這就能解決問題。

746
00:30:35,333 --> 00:30:37,433
對，並將那知識保留在 API

747
00:30:37,433 --> 00:30:39,100
範疇內，我認為我們能做到這一點

748
00:30:39,100 --> 00:30:40,933
而不破壞我們的測試

749
00:30:40,933 --> 00:30:42,366
因為最終我們要

750
00:30:42,366 --> 00:30:44,766
這個模塊生成 FeedItems

751
00:30:44,766 --> 00:30:47,900
但內部我們可以使用一種過渡式

752
00:30:47,900 --> 00:30:49,600
的表示法，絕對可以

753
00:30:49,600 --> 00:30:51,900
來自API的

754
00:30:51,900 --> 00:30:54,866
FeedItem表示法轉換為 FeedItems

755
00:30:54,866 --> 00:30:56,366
所以我想要

756
00:30:56,366 --> 00:30:58,766
去掉這個 Decodable 實現

757
00:30:58,766 --> 00:31:00,366
在此

758
00:31:00,366 --> 00:31:06,066
我們可以透過建立我們自己的

759
00:31:06,066 --> 00:31:09,666
私人類型來達成這個目標

760
00:31:09,666 --> 00:31:12,533
就像我們處理根元素一樣

761
00:31:12,533 --> 00:31:15,266
對

762
00:31:15,266 --> 00:31:17,833
但現在這個的名稱正確地

763
00:31:17,833 --> 00:31:18,700
對應了

764
00:31:18,700 --> 00:31:21,833
API JSON的表示法，對

765
00:31:21,833 --> 00:31:24,000
因此，這個 Item 是 FeedItem 的

766
00:31:24,000 --> 00:31:25,900
內部表示

767
00:31:25,900 --> 00:31:27,900
但對於 API 模組，這將會變成

768
00:31:27,900 --> 00:31:29,333
現在的 Decodable，對

769
00:31:29,333 --> 00:31:32,000
對，我喜歡這樣，然後 Root 會

770
00:31:32,000 --> 00:31:32,766
生成

771
00:31:32,766 --> 00:31:35,266
各種項目的陣列，我們需要一種方式來

772
00:31:35,266 --> 00:31:35,833
映射

773
00:31:35,833 --> 00:31:38,366
我們的 Item 成為 FeedItem，我們可以使用

774
00:31:38,366 --> 00:31:39,200
一個

775
00:31:39,200 --> 00:31:41,833
計算過的 var 來達成，所以在這裡我們

776
00:31:41,833 --> 00:31:42,766
可以返回我們的

777
00:31:42,766 --> 00:31:46,466
具有相同 id、描述、位置和 imageURL 的 FeedItem，

778
00:31:46,466 --> 00:31:49,900
對吧，

779
00:31:49,900 --> 00:31:52,866
我們需要在這裡做的一切就是映射我們的

780
00:31:52,866 --> 00:31:53,833
項目，

781
00:31:53,833 --> 00:31:57,100
變成 FeedItems，對吧。

782
00:31:57,100 --> 00:32:00,466
就這樣，讓我們來運行測試，砰，

783
00:32:00,466 --> 00:32:04,066
依然能運行，太棒了，看看，我們

784
00:32:04,066 --> 00:32:04,700
有我們自己的

785
00:32:04,700 --> 00:32:06,866
項目，代表 API 的 Feed Item，

786
00:32:06,866 --> 00:32:09,833
在這個情境中，

787
00:32:09,833 --> 00:32:12,700
所以 FeedItem 對 API 毫無認識，

788
00:32:12,700 --> 00:32:13,333
再度強調，

789
00:32:13,333 --> 00:32:15,900
即使是 keypaths，因為你可以說

790
00:32:15,900 --> 00:32:17,100
它就是一串字符串，

791
00:32:17,100 --> 00:32:18,866
但不，這是一個細節實現，

792
00:32:18,866 --> 00:32:21,266
它滲漏到了更抽象的，

793
00:32:21,266 --> 00:32:24,300
更高層次的模塊，是的，這個 FeedItem

794
00:32:24,300 --> 00:32:27,033
有一個 imageURL 屬性，就像我們

795
00:32:27,033 --> 00:32:27,333
看到的。

796
00:32:27,333 --> 00:32:30,633
如果之前我們要實現 Decodable，

797
00:32:30,633 --> 00:32:33,266
我們就得有這些 CodingKeys，

798
00:32:33,266 --> 00:32:34,233
我們必須

799
00:32:34,233 --> 00:32:36,366
對編譯器給出映射指示，

800
00:32:36,366 --> 00:32:38,700
把圖片的

801
00:32:38,700 --> 00:32:42,133
JSON 屬性映射到 imageURL，但是現在

802
00:32:42,133 --> 00:32:45,333
有了 Item 結構，API 中的 FeedItem

803
00:32:45,333 --> 00:32:46,700
的內部表示

804
00:32:46,700 --> 00:32:49,433
我們不需要那麼做

805
00:32:49,433 --> 00:32:51,033
我們不需要那樣

806
00:32:51,033 --> 00:32:52,366
如你所見，我們沒有打破

807
00:32:52,366 --> 00:32:54,233
測試，對吧？這是一個簡單的

808
00:32:54,233 --> 00:32:57,100
變動，並且我們保持了我們的模塊

809
00:32:57,100 --> 00:32:58,133
抽象，

810
00:32:58,133 --> 00:33:00,766
確切的說，這顯示了測試是如何

811
00:33:00,766 --> 00:33:01,733
他們並不包含

812
00:33:01,733 --> 00:33:04,700
任何內部實施細節，而且

813
00:33:04,700 --> 00:33:06,466
基本上就是輸入輸出

814
00:33:06,466 --> 00:33:08,633
他們只檢查行為，我真的非常喜歡

815
00:33:08,633 --> 00:33:11,333
這個，讓我們提交

816
00:33:11,333 --> 00:33:15,666
將 Decodable 邏輯移動到新的 private 

817
00:33:15,666 --> 00:33:16,366
Item 

818
00:33:16,366 --> 00:33:20,066
結構類型，以此解結 Feed 

819
00:33:20,066 --> 00:33:23,333
模塊與 API 

820
00:33:23,333 --> 00:33:26,866
實施細節的耦合，看看這個，

821
00:33:26,866 --> 00:33:30,066
這真的太棒了。

822
00:33:30,066 --> 00:33:31,266
但公平地說，我不太喜歡這個

823
00:33:31,266 --> 00:33:32,766
實現方式了，有太多的

824
00:33:32,766 --> 00:33:33,833
事情正在進行

825
00:33:33,833 --> 00:33:36,300
在這個RemoteFeedLoader中，所以為什麼不

826
00:33:36,300 --> 00:33:37,033
我們

827
00:33:37,033 --> 00:33:38,866
通過創建來對這進行一點重構

828
00:33:38,866 --> 00:33:40,300
也許是一種新的類型

829
00:33:40,300 --> 00:33:42,933
我們可以提取一些東西，使FeedLoader

830
00:33:42,933 --> 00:33:43,833
變得更清爽

831
00:33:43,833 --> 00:33:46,366
所以我們現在可以創建一個私有類

832
00:33:46,366 --> 00:33:47,033
比如說

833
00:33:47,033 --> 00:33:50,866
一個FeedItemsMapper

834
00:33:50,866 --> 00:33:52,766
並且，我們可以將它設定為靜態的

835
00:33:52,766 --> 00:33:54,300
功能，我們不需要實例化它

836
00:33:54,300 --> 00:33:54,766
這

837
00:33:54,766 --> 00:33:57,900
不，一個map功能

838
00:33:57,900 --> 00:34:01,900
會接收Data和

839
00:34:01,900 --> 00:34:05,266
response，對，HTTPURLResponse

840
00:34:05,266 --> 00:34:08,133
如果您不能映射它，那就會拋出一個異常

841
00:34:08,133 --> 00:34:09,100
並且它返回

842
00:34:09,100 --> 00:34:11,500
一個FeedItem的陣列，所以我們希望

843
00:34:11,500 --> 00:34:12,700
斷言一下

844
00:34:12,700 --> 00:34:16,000
回應的狀態碼應該是

845
00:34:16,000 --> 00:34:18,633
200，所以我們可以使用guard語句

846
00:34:18,633 --> 00:34:19,166
對

847
00:34:19,166 --> 00:34:20,800
對，我們通常會使用guard語句

848
00:34:20,800 --> 00:34:22,300
在那裡有一個聲明

849
00:34:22,300 --> 00:34:25,266
如果不是200，那我們就會拋出

850
00:34:25,266 --> 00:34:26,300
無效數據

851
00:34:26,300 --> 00:34:30,000
好的，那麼 RemoteFeedLoader.Error.invalidData

852
00:34:30,000 --> 00:34:33,433
對的，否則我們

853
00:34:33,433 --> 00:34:36,633
可以在這裡使用這個邏輯，是的，就像這樣複制

854
00:34:36,633 --> 00:34:37,500
然後貼上

855
00:34:37,500 --> 00:34:40,800
我們解碼我們的 Root 項目，但我們希望

856
00:34:40,800 --> 00:34:42,300
返回

857
00:34:42,300 --> 00:34:45,566
好的，映射的項目，是的，映射的

858
00:34:45,566 --> 00:34:46,533
項目

859
00:34:46,533 --> 00:34:49,166
好，所以現在我們可以用 FeedItems

860
00:34:49,166 --> 00:34:49,900
Mapper 

861
00:34:49,900 --> 00:34:54,066
代替了，對吧 

862
00:34:54,066 --> 00:34:56,466
我們傳送數據和響應，我們

863
00:34:56,466 --> 00:34:57,166
完成

864
00:34:57,166 --> 00:35:00,833
如果成功了，我們用項目來完成

865
00:35:00,833 --> 00:35:03,733
太好了，你甚至可以用 do

866
00:35:03,733 --> 00:35:10,300
catch 語法

867
00:35:10,300 --> 00:35:17,566
如果你想的話

868
00:35:17,566 --> 00:35:19,833
很好，如果你更喜歡 do catch

869
00:35:19,833 --> 00:35:21,433
或是 if let

870
00:35:21,433 --> 00:35:24,000
並不是很重要，我們甚至可以

871
00:35:24,000 --> 00:35:25,033
隱藏

872
00:35:25,033 --> 00:35:28,800
在我們的類別內部私下

873
00:35:28,800 --> 00:35:32,633
所以沒人可以存取它 

874
00:35:32,633 --> 00:35:35,900
你甚至可以新增那些中繼資料 

875
00:35:35,900 --> 00:35:39,666
在方法簽章內部，它同樣可以運作

876
00:35:39,666 --> 00:35:42,866
對吧 

877
00:35:42,866 --> 00:35:45,500
但我還是更喜歡把它們放在類別中


878
00:35:45,500 --> 00:35:45,900
範圍

879
00:35:45,900 --> 00:35:47,666
因為有命名空間，所以它的

880
00:35:47,666 --> 00:35:52,800
只是一種偏好

881
00:35:52,800 --> 00:35:54,400
這種語法裡有很多的點

882
00:35:54,400 --> 00:35:57,433
如果你想，你可以創建一個根

883
00:35:57,433 --> 00:35:59,900
元素並映射它，我們可以自由地改變

884
00:35:59,900 --> 00:36:01,733
這個實現，因為

885
00:36:01,733 --> 00:36:04,933
在這一集中，我們採用了古典主義者的

886
00:36:04,933 --> 00:36:06,933
測試驅動開發的方法

887
00:36:06,933 --> 00:36:08,400
我們並沒有模擬

888
00:36:08,400 --> 00:36:11,033
任何映射項，我們只是

889
00:36:11,033 --> 00:36:12,700
通過公共接口進行測試，如果我傳遞這些數據

890
00:36:12,700 --> 00:36:15,166
我得到一個錯誤或者我得到一個映射的數組

891
00:36:15,166 --> 00:36:17,733
的項目

892
00:36:17,733 --> 00:36:18,400
的項目

893
00:36:18,400 --> 00:36:19,333
所以我們可以自由地更改

894
00:36:19,333 --> 00:36:21,166
實現，不會破壞

895
00:36:21,166 --> 00:36:21,833
測試

896
00:36:21,833 --> 00:36:25,033
這是一個很大的勝利，但是現在我們也

897
00:36:25,033 --> 00:36:26,533
在整合時進行測試，所以當它

898
00:36:26,533 --> 00:36:27,900
失敗，可能

899
00:36:27,900 --> 00:36:30,233
更難找出問題在哪裡

900
00:36:30,233 --> 00:36:31,200
精確點說

901
00:36:31,200 --> 00:36:34,700
是的，但是對於初學者來說

902
00:36:34,700 --> 00:36:38,133
我認為這是一種真實的方法


903
00:36:38,133 --> 00:36:40,633
你知道，某些輸入我們得到某些

904
00:36:40,633 --> 00:36:41,833
確定的輸出

905
00:36:41,833 --> 00:36:43,266
這是你提出的一個非常好的觀點

906
00:36:43,266 --> 00:36:45,500
有關於整合，確實

907
00:36:45,500 --> 00:36:47,566
也許我們需要重新審視這個

908
00:36:47,566 --> 00:36:48,633
解決方案

909
00:36:48,633 --> 00:36:51,900
但在那之前，我很樂意接受它

910
00:36:51,900 --> 00:36:55,200
所以，讓我們確認，好，所以

911
00:36:55,200 --> 00:36:58,233
我們將對應

912
00:36:58,233 --> 00:37:01,900
邏輯移至一種新的類型 Feed

913
00:37:01,900 --> 00:37:05,500
ItemsMapper 是的，就是這樣

914
00:37:05,500 --> 00:37:07,200
所以在這個過程中我們學到很多重要的課題

915
00:37:07,200 --> 00:37:09,266
是的，首先

916
00:37:09,266 --> 00:37:11,833
要小心處理 Decodable 的設計

917
00:37:11,833 --> 00:37:12,933
因為它能

918
00:37:12,933 --> 00:37:16,233
將模塊耦合，這是對

919
00:37:16,233 --> 00:37:17,200
紀律的真實考驗

920
00:37:17,200 --> 00:37:21,666
因為忽略這一點如此容易

921
00:37:21,666 --> 00:37:23,500
只是說你知道這個

922
00:37:23,500 --> 00:37:25,733
將是 Decodable，這並不重要

923
00:37:25,733 --> 00:37:27,666
我將在那裡擁有這個 CodingKeys

924
00:37:27,666 --> 00:37:29,333
你知道，因為現在

925
00:37:29,333 --> 00:37:31,900
這將給你做任何事情提供方便

926
00:37:31,900 --> 00:37:33,500
你的任務將會是

927
00:37:33,500 --> 00:37:36,933
但它具有影響性，並且

928
00:37:36,933 --> 00:37:39,733
如我所說，你需要有紀律去

929
00:37:39,733 --> 00:37:41,433
理解這些影響性並且

930
00:37:41,433 --> 00:37:42,533
抵抗

931
00:37:42,533 --> 00:37:45,500
通過找到更模組化的解決方案去

932
00:37:45,500 --> 00:37:46,700
解決你的問題

933
00:37:46,700 --> 00:37:48,700
還有那經典方法，我們

934
00:37:48,700 --> 00:37:50,700
不斷添加測試並重構

935
00:37:50,700 --> 00:37:52,866
毫不留情地，測試仍然

936
00:37:52,866 --> 00:37:55,033
通過一切都好

937
00:37:55,033 --> 00:37:57,100
我覺得這是一個大贏，但是這

938
00:37:57,100 --> 00:37:58,300
整合類型的

939
00:37:58,300 --> 00:38:01,033
測試可能會在將來困擾我們，所以我們

940
00:38:01,033 --> 00:38:03,566
需要密切注意它們

941
00:38:03,566 --> 00:38:06,866
同意，現在我對它很滿意，我們看到

942
00:38:06,866 --> 00:38:08,466
也有一些很棒的重構

943
00:38:08,466 --> 00:38:11,500
在我看來，測試非常

944
00:38:11,500 --> 00:38:12,133
可讀

945
00:38:12,133 --> 00:38:14,233
確實，例如期望sut為

946
00:38:14,233 --> 00:38:15,433
失敗完成

947
00:38:15,433 --> 00:38:18,466
當我們用200 

948
00:38:18,466 --> 00:38:19,266
狀態完成但

949
00:38:19,266 --> 00:38:22,466
無效的JSON，我覺得這很好

950
00:38:22,466 --> 00:38:24,533
對，所以我想我們可以做另一次重構

951
00:38:24,533 --> 00:38:26,633
這裡也是用

952
00:38:26,633 --> 00:38:29,900
makeItemsJSON配合空字典

953
00:38:29,900 --> 00:38:31,033
所以我們

954
00:38:31,033 --> 00:38:33,200
移除這個資料實現的細節

955
00:38:33,200 --> 00:38:34,400
從我們的測試設置中

956
00:38:34,400 --> 00:38:39,500
這樣可以讓它變得更容易閱讀

957
00:38:39,500 --> 00:38:42,700
我們來提交替換硬

958
00:38:42,700 --> 00:38:52,133
碼化的JSON與輔助方法

959
00:38:52,133 --> 00:38:55,200
同時這裡的程式碼相當乾淨

960
00:38:55,200 --> 00:38:57,500
我認為我們應該開始移動

961
00:38:57,500 --> 00:39:00,300
某些類型至其自有的檔案但是我們可以

962
00:39:00,300 --> 00:39:02,066
在下一集中進行這項操作

963
00:39:02,066 --> 00:39:03,500
啊我認為我們應該在下一

964
00:39:03,500 --> 00:39:06,233
集開始時做些清理工作

965
00:39:06,233 --> 00:39:08,533
有些人不喜歡這些硬編碼的

966
00:39:08,533 --> 00:39:09,900
這裡的值

967
00:39:09,900 --> 00:39:14,466
對所以我們可以創建某種

968
00:39:14,466 --> 00:39:19,500
DSL，像是好的，200

969
00:39:19,500 --> 00:39:21,333
對所以它已經不再是魔術數字

970
00:39:21,333 --> 00:39:26,833
它有了某種上下文關係

971
00:39:26,833 --> 00:39:30,300
確實

972
00:39:30,300 --> 00:39:33,900
因此替換魔術數字

973
00:39:33,900 --> 00:39:38,466
用帶有更多語境的變數代替

974
00:39:38,466 --> 00:39:40,533
對我們可以隨意改變這個

975
00:39:40,533 --> 00:39:42,533
實現方式而不破壞測試程序

976
00:39:42,533 --> 00:39:45,333
這非常好，所以下集我們

977
00:39:45,333 --> 00:39:46,800
應該開始移動那些類型

978
00:39:46,800 --> 00:39:48,933
來清理那些檔案，對吧

979
00:39:48,933 --> 00:40:03,433
我們下次見，再見了，我們見。
