

1
00:00:01,200 --> 00:00:02,040
大家好。

2
00:00:05,200 --> 00:00:06,800
歡迎大家。

3
00:00:06,800 --> 00:00:08,480
我叫Bogdan，

4
00:00:08,480 --> 00:00:12,320
我是學院的一名講師

5
00:00:12,320 --> 00:00:15,340
我非常高興今天能和你們一起參與

6
00:00:15,340 --> 00:00:16,600
這場直播活動。

7
00:00:17,640 --> 00:00:20,800
我將進行一場有關Xcode工具的講座

8
00:00:22,080 --> 00:00:25,760
涵蓋Xcode中著名和鮮為人知的部分

9
00:00:25,760 --> 00:00:30,760
因為身為開發人員，我們在Xcode中的時間非常多

10
00:00:32,480 --> 00:00:35,800
所以我們需要更好地了解如何利用它。

11
00:00:35,800 --> 00:00:39,260
我甚至利用Xcode寫我的日記。

12
00:00:43,480 --> 00:00:46,960
所以請繼續留心講座的進行

13
00:00:46,960 --> 00:00:50,720
我會優雅地請求您打開您的相機

14
00:00:50,720 --> 00:00:55,720
這樣我可以看到你們並根據你們的反應獲得反饋。

15
00:00:56,000 --> 00:00:57,080
我會很感謝的。

16
00:00:58,280 --> 00:00:59,240
我們開始吧。

17
00:01:01,080 --> 00:01:03,820
在我們深入主題之前，

18
00:01:03,820 --> 00:01:08,180
我們建議您查閱Apple對Xcode的官方文檔。

19
00:01:09,800 --> 00:01:12,600
有許多文件資料。

20
00:01:13,500 --> 00:01:16,320
還有 WWDC 的議程。

21
00:01:16,320 --> 00:01:20,320
所以確保你有查看那些。

22
00:01:20,320 --> 00:01:22,600
我們並不試圖重複這些文件中的資訊

23
00:01:22,600 --> 00:01:26,260
在這裡。

24
00:01:30,760 --> 00:01:34,880
這是今天的議程。

25
00:01:34,880 --> 00:01:38,900
我們將研究一些有用的輔助功能

26
00:01:38,900 --> 00:01:40,660
和編輯器選項。

27
00:01:42,600 --> 00:01:46,080
我們將深入研究項目概述

28
00:01:46,080 --> 00:01:48,580
並討論項目資訊，生成設定，

29
00:01:48,580 --> 00:01:53,580
目標一般簽名功能，資訊，

30
00:01:53,760 --> 00:01:57,720
再次檢視生成設定，生成階段等等。

31
00:01:57,720 --> 00:02:02,020
我們將試圖理解 PBX 文件格式。

32
00:02:05,040 --> 00:02:08,900
我們將解釋 Xcode 新項目介面選項，

33
00:02:10,000 --> 00:02:11,980
Storyboard 對比 SwiftUI。

34
00:02:13,480 --> 00:02:16,420
我們來看看 Xcode 項目的默認項目結構

35
00:02:16,420 --> 00:02:18,800
就是 Xcode 項目的組成。

36
00:02:18,800 --> 00:02:22,680
我們來看看在 Xcode 應用程式包中有什麼

37
00:02:22,680 --> 00:02:25,140
以及它所包含的內嵌工具鏈。

38
00:02:26,520 --> 00:02:29,520
我們接下來會討論如何在同一台機器上保持多個版本

39
00:02:29,520 --> 00:02:31,140
的Xcode。

40
00:02:32,320 --> 00:02:35,560
我們會在結束時進行問答環節。

41
00:02:35,560 --> 00:02:38,040
但是，如果有任何問題，

42
00:02:39,080 --> 00:02:41,160
都可以隨時在聊天框中提出

43
00:02:41,160 --> 00:02:46,160
如果問題與當下的主題直接相關，我會回覆。

44
00:02:47,360 --> 00:02:49,520
與投影片相關的部分。

45
00:02:51,280 --> 00:02:53,800
好，助理功能。

46
00:02:53,800 --> 00:02:56,800
Xcode提供了許多助理功能

47
00:02:56,800 --> 00:03:00,080
這些並不是開發者們特別喜歡的，

48
00:03:00,080 --> 00:03:03,800
但是真的可以加快開發速度。

49
00:03:03,800 --> 00:03:08,800
以下是一些有趣的助理。

50
00:03:21,420 --> 00:03:25,720
首先，這個我剛選擇的雙文件助理

51
00:03:25,720 --> 00:03:26,960
根據你在第一步的選擇

52
00:03:29,280 --> 00:03:33,240
自動改變第二個分頁的選擇。

53
00:03:33,240 --> 00:03:36,480
所以如果你在編輯一個生產文件，

54
00:03:36,480 --> 00:03:40,120
對應的測試文件通常會顯示在相對應的雙文件助理裡，

55
00:03:40,120 --> 00:03:44,380
反之亦然。

57
00:03:46,420 --> 00:03:49,100
此外，如果你正在編輯一個ViewController

58
00:03:49,100 --> 00:03:53,340
並且它有對應的 Storyboard 或 C File，

59
00:03:53,340 --> 00:03:56,920
則對應的部分將自動設定為那個。

60
00:03:57,760 --> 00:03:59,980
所以在我對FeedItemsMapper的案例中，

61
00:03:59,980 --> 00:04:04,980
我可以立即獲得 FeedItemsMapperTests。

62
00:04:06,460 --> 00:04:07,900
這可能真的很有用，

63
00:04:07,900 --> 00:04:10,440
特別是與我們的 TDD 工作流程。

64
00:04:18,280 --> 00:04:21,420
我要提到的下一個助理

65
00:04:21,420 --> 00:04:24,380
是 super classes 助理。

66
00:04:26,640 --> 00:04:29,900
這個助理顯示我目前 class 的所有 super classes 的清單

67
00:04:29,900 --> 00:04:32,040
。

68
00:04:32,040 --> 00:04:35,700
所以由於我選擇了 ListViewController，

69
00:04:36,900 --> 00:04:41,900
我的 super classes 在一個階層裏是 NSObject，

70
00:04:41,900 --> 00:04:46,280
UIResponder，UIViewController 和 UITableViewController。

71
00:04:46,280 --> 00:04:50,440
所以我可以快速查看這些。

72
00:04:50,440 --> 00:04:55,440
下一個助理是 extensions。

73
00:05:00,640 --> 00:05:03,960
我可以立即看到，我的 ListViewController 上有四種 extensions

74
00:05:03,960 --> 00:05:05,680
。

75
00:05:05,680 --> 00:05:09,600
我可以使用這個助手去訪問每一個項目

76
00:05:10,480 --> 00:05:11,320
非常方便。

77
00:05:11,320 --> 00:05:16,320
用戶介面既是助手。

78
00:05:21,040 --> 00:05:24,040
我只會提到在我們的示範中，

79
00:05:24,040 --> 00:05:26,000
EssentialFeed案例項目中，

80
00:05:26,000 --> 00:05:27,620
我們沒有任何storyboards，

81
00:05:27,620 --> 00:05:29,920
但如果我們有的話，

82
00:05:29,920 --> 00:05:39,920
它們將會在助手中被加載。

83
00:05:43,540 --> 00:05:48,540
我接下來會看看調用者助手。

84
00:05:52,740 --> 00:05:57,540
我選擇了ListViewController中唯一的refresh屬性，

85
00:05:57,540 --> 00:05:59,300
在ListViewController上。

86
00:05:59,300 --> 00:06:03,140
我可以看到有三個組件

87
00:06:03,140 --> 00:06:06,060
調用此屬性。

88
00:06:08,900 --> 00:06:11,260
一個在ListViewController中，

89
00:06:11,260 --> 00:06:14,900
另外兩個是來自composition route的Composers。

90
00:06:14,900 --> 00:06:16,260
從組合路由的Composers。

91
00:06:18,540 --> 00:06:19,380
也很有用。

92
00:06:24,300 --> 00:06:27,940
還有一個測試類的助手，

93
00:06:27,940 --> 00:06:32,940
這種人説實在與對應的助手是一樣的，

94
00:06:33,340 --> 00:06:36,060
它選擇對應的測試文件。

95
00:06:40,980 --> 00:06:45,300
一個有趣的助手是預處理助手，

96
00:06:45,300 --> 00:06:49,220
它與Objective-C一同使用效果最佳。

97
00:06:49,220 --> 00:06:53,460
所以我打算切換到一個開源項目，

98
00:06:53,460 --> 00:06:58,460
Cocoa Lumberjack，並解釋為何這個處理器有用

99
00:06:58,540 --> 00:07:03,540
是因為它真的有助於我們理解宏是如何運作的。

100
00:07:04,180 --> 00:07:08,460
所以它就是將預處理器的工作函數實現，

101
00:07:08,460 --> 00:07:09,980
擴展所有的宏。

102
00:07:09,980 --> 00:07:11,540
那麼這有何用處？

103
00:07:11,540 --> 00:07:15,700
嗯，擴展宏的意思就是用其定義來替換宏

104
00:07:15,700 --> 00:07:17,780
。

105
00:07:17,780 --> 00:07:21,640
所以這適用於定义，導入，包含，

106
00:07:21,640 --> 00:07:24,740
所有C語言風格的宏。

107
00:07:27,500 --> 00:07:30,780
所以這確實會幫助我們理解

108
00:07:30,780 --> 00:07:34,700
為什麼Objective-C的導入會對編譯時間有如此大的影響，

109
00:07:34,700 --> 00:07:36,540
因為即使只是幾行代碼的文件

110
00:07:36,540 --> 00:07:39,380
和像這種情況下的一兩個導入，

111
00:07:39,380 --> 00:07:44,380


112
00:07:44,440 --> 00:07:48,740
被轉譯成一個更大的 File

113
00:07:48,740 --> 00:07:51,060
並經過編譯器。

114
00:07:51,060 --> 00:07:56,060
這非常強大。

115
00:08:03,900 --> 00:08:08,460
我要重新切回我們的 EssentialFeed 案例項目

116
00:08:08,460 --> 00:08:10,860
並觀看另一個助手，

117
00:08:10,860 --> 00:08:14,140
那就是 Generated Interface 助手，

118
00:08:16,120 --> 00:08:20,900
它顯示我們 component 的公開接口

119
00:08:20,900 --> 00:08:22,140
對於我們的 component。

120
00:08:22,140 --> 00:08:27,140
所以我將使用 LoadResourcePresenter

121
00:08:29,260 --> 00:08:31,780
它有多個實體，

122
00:08:31,780 --> 00:08:34,020
我們將看生成的界面。

123
00:08:34,020 --> 00:08:37,580
所以對於第一個協議基本上是相同的。

124
00:08:37,580 --> 00:08:42,100
然後對於我的 class，我只能看到公開的元素

125
00:08:43,740 --> 00:08:45,440
以及它們的簽名。

126
00:08:45,440 --> 00:08:50,440
在審查你的界面時，這可能非常有用。

127
00:08:54,420 --> 00:08:58,460
接下來，我想看一些編輯器選項。

128
00:09:03,580 --> 00:09:06,520
Xcode 中有一些。

129
00:09:08,280 --> 00:09:09,920
其中一個是 minimap，

130
00:09:09,920 --> 00:09:12,780
這是一種很好的圖形表示

131
00:09:12,780 --> 00:09:17,580
你所選擇的File，甚至允許我

132
00:09:17,580 --> 00:09:18,880
進行導航。

133
00:09:18,880 --> 00:09:21,980
所以如果我在這裡點擊一個項目，

134
00:09:21,980 --> 00:09:26,740
我馬上就能到達File裡的那個地方。

135
00:09:29,820 --> 00:09:32,860
下一個選項是authors，

136
00:09:33,760 --> 00:09:37,960
而authors顯示的是每行或每組行的作者和commit資訊

137
00:09:37,960 --> 00:09:40,000
在每一行或一組行之上。

138
00:09:40,000 --> 00:09:45,000
我可以點擊它，我可以去git裡的commit，

139
00:09:48,100 --> 00:09:49,940
或者我甚至可以給Caio寄電郵。

140
00:09:54,400 --> 00:09:57,080
最後一個，但我認為最強大的一個

141
00:09:57,080 --> 00:09:58,480
是code coverage。

142
00:10:00,300 --> 00:10:03,420
Code coverage顯示的是code coverage

143
00:10:03,420 --> 00:10:06,580
使用不同顏色來呈現最後一次測試執行的覆蓋率。

144
00:10:06,580 --> 00:10:11,580
紅色的部分是任何一個測試都未執行的行。

145
00:10:12,540 --> 00:10:14,960
所以在這個情況下，這個public initializer

146
00:10:14,960 --> 00:10:17,420
並未被我們的Tests呼叫。

147
00:10:19,440 --> 00:10:24,440
以灰色表示的部分是被測試執行的行

148
00:10:24,920 --> 00:10:27,400
並且他們旁邊有一個計數器

149
00:10:27,400 --> 00:10:31,720
顯示有多少Tests實際上呼叫了那一行

150
00:10:31,720 --> 00:10:34,180
或者呼叫了多少次。

151
00:10:34,180 --> 00:10:37,220
當你在檢查的時候，這非常有用

152
00:10:37,220 --> 00:10:41,780
你的測試覆蓋範圍和確定路徑

153
00:10:41,780 --> 00:10:44,180
沒有被Tests覆蓋。

154
00:10:48,780 --> 00:10:51,260
這部分就講到這裡。

155
00:10:55,380 --> 00:10:59,100
接下來，我們將看看Xcode專案。

156
00:11:00,880 --> 00:11:04,160
所以選擇在檔案導航器中的Xcode專案

157
00:11:04,160 --> 00:11:07,240
能看到專案和目標設置的視圖。

158
00:11:08,140 --> 00:11:11,260
當你透過這些介面做出變化時，

159
00:11:11,260 --> 00:11:14,660
Xcode將把它們轉化為實際的文字變化

160
00:11:14,660 --> 00:11:19,540
到專案檔案，即是project.xcodeproj

161
00:11:19,540 --> 00:11:22,340
則是project PBXproj。

162
00:11:27,280 --> 00:11:30,000
你可能知道這點，但一個專案

163
00:11:30,000 --> 00:11:32,220
可以包含多個目標

164
00:11:32,220 --> 00:11:34,780
以及多個配置。

165
00:11:38,900 --> 00:11:43,520
如您所見，每個配置對每個目標都存在。

166
00:11:44,700 --> 00:11:46,340
這是理解的重要部分。

167
00:11:52,140 --> 00:11:55,220
建置配置是一套建置設置

168
00:11:55,220 --> 00:11:59,120
用來以特定方式建立目標產品。

169
00:11:59,120 --> 00:12:01,720
預設情況下，當您建立該專案，

170
00:12:01,720 --> 00:12:05,100
您會得到兩個配置，debug 和 release。

171
00:12:08,580 --> 00:12:10,620
您可以增加更多的配置

172
00:12:10,620 --> 00:12:14,300
或者您甚至可以重命名或刪除這些預設的配置，

173
00:12:14,300 --> 00:12:15,860
這是我不建議您執行的

174
00:12:15,860 --> 00:12:19,840
因為在我們的行業裡，這被認為是一種標準，

175
00:12:19,840 --> 00:12:22,460
具有這兩種debug和release配置。

176
00:12:22,460 --> 00:12:25,580
所以我建議你保持它们的原樣。

177
00:12:25,580 --> 00:12:30,580
有兩種配置或更多的原因

178
00:12:32,180 --> 00:12:34,660
我們通常需要不同的行為

179
00:12:34,660 --> 00:12:39,500
在我們在我們的開發機器上本地運行或調試的生成

180
00:12:39,500 --> 00:12:44,260
與我們傳遞給我們組織內部使用者的生成相對。

181
00:12:44,260 --> 00:12:46,340
或甚至是我們的AppStore用戶。

182
00:12:51,540 --> 00:12:54,180
例如，發布配置

183
00:12:54,180 --> 00:12:57,300
使用各種優化以提升運行速度，

184
00:12:57,300 --> 00:12:59,940
二進制速度，抱歉我應該說二進制大小，

185
00:12:59,940 --> 00:13:02,340
但它通常需要更多的建構時間。

186
00:13:03,160 --> 00:13:05,060
另一方面，調試配置

187
00:13:05,060 --> 00:13:07,420
並未優化二進制碼

188
00:13:07,420 --> 00:13:12,140
並且像是增量編譯這類的更快。

189
00:13:14,660 --> 00:13:19,220
你有時會看到項目用像是一個額外的配置，

190
00:13:19,220 --> 00:13:22,100
位於調試和發布之間的中間地段。

191
00:13:22,100 --> 00:13:26,020
有些人稱它為臨時或內部或階段。

192
00:13:26,020 --> 00:13:27,940
在這種情況下，這第四種配置

193
00:13:27,940 --> 00:13:31,580
將使用臨時或企業編碼簽名，

194
00:13:31,580 --> 00:13:34,620
但其他設定與發布配置相同。

195
00:13:34,620 --> 00:13:38,340
因此基本上建立了與發布建構相當的版本

196
00:13:38,340 --> 00:13:40,460
該版本是內部分發的。

197
00:13:43,540 --> 00:13:46,820
就是為了把我們的文件整理齊全，

198
00:13:46,820 --> 00:13:50,220
我們通常把一個構建稱為debug構建

199
00:13:50,220 --> 00:13:53,100
當它使用debug配置構建時

200
00:13:53,100 --> 00:13:54,940
和一個release構建，

201
00:13:55,980 --> 00:13:58,620
一個使用release配置構建的構建。

202
00:14:02,340 --> 00:14:04,820
讓我們看看這些配置在哪裡被使用。

203
00:14:04,820 --> 00:14:08,260
首先，它們被使用

204
00:14:08,260 --> 00:14:10,660
每當我們在Xcode中對任何目標執行任何操作時。

205
00:14:10,660 --> 00:14:12,580
所以建立，存檔，分析等等。

206
00:14:12,580 --> 00:14:16,160
每一個都有一個預配置的配置使用。

207
00:14:16,160 --> 00:14:20,440
你可以在方案編輯器中看到這一點。

208
00:14:21,920 --> 00:14:24,960
例如，運行操作使用debug配置

209
00:14:26,700 --> 00:14:31,700
而存檔操作使用release配置。

210
00:14:31,700 --> 00:14:34,540
它們可以輕易地被編輯和改變。

211
00:14:35,480 --> 00:14:38,500
在使用CommandLine時的其他使用情況，

212
00:14:41,060 --> 00:14:43,820
例如，構建，可以傳遞配置

213
00:14:43,820 --> 00:14:47,940
給構建CommandLine

214
00:14:48,900 --> 00:14:51,800
到構建CommandLine

215
00:14:51,800 --> 00:14:55,320
或依賴你的配置方案。

216
00:14:57,600 --> 00:15:00,860
現在讓我們來看看項目概覽

217
00:15:00,860 --> 00:15:02,880
以及其可用的標籤。

218
00:15:07,240 --> 00:15:09,960
所以我選擇了項目

219
00:15:09,960 --> 00:15:12,540
然後我確保在這個左側面板，

220
00:15:12,540 --> 00:15:16,160
我選擇的是項目而不是目標。

221
00:15:17,220 --> 00:15:19,760
我有幾個可用的標籤。

222
00:15:20,700 --> 00:15:22,840
讓我們逐一看過去。

223
00:15:26,420 --> 00:15:31,420
信息標籤顯示最重要的項目設置。

224
00:15:33,220 --> 00:15:35,100
部署目標代表

225
00:15:35,100 --> 00:15:38,340
每個平台的最低支持OS版本，

226
00:15:38,340 --> 00:15:41,080
如果項目使用我們所做的多個平台。

227
00:15:41,080 --> 00:15:46,080
這些是在建立設置下設定的相同值

228
00:15:46,640 --> 00:15:49,680
在部署部分作為iOS

229
00:15:49,680 --> 00:15:52,160
或macOS部署目標。

230
00:15:52,160 --> 00:15:55,580
所以改變一個將間接改變另一個。

231
00:15:57,240 --> 00:15:59,000
接下來我們有配置

232
00:15:59,000 --> 00:16:02,080
我們看見主要已經提到的，

233
00:16:02,080 --> 00:16:03,320
debug 和 release，

234
00:16:04,900 --> 00:16:07,280
或者我們可能有的其他配置。

235
00:16:07,280 --> 00:16:12,280
接下來，我們也會看到基於配置File，

236
00:16:13,960 --> 00:16:17,480
基本上包含了所有支援的本地化

237
00:16:17,480 --> 00:16:18,640
在這個專案上。

238
00:16:21,720 --> 00:16:23,440
下一個是構建設定標籤。

239
00:16:25,100 --> 00:16:27,640
而我就不進一步細說了

240
00:16:27,640 --> 00:16:30,720
因為我們還要說到構建設定

241
00:16:30,720 --> 00:16:39,480
在目標設定中，他們是相互關聯的。

242
00:16:39,480 --> 00:16:43,400
程式包依賴性就是我們設置

243
00:16:43,400 --> 00:16:44,680
Swift Package Manager的地方。

244
00:16:46,520 --> 00:16:51,520
舉例來說，我們可以迅速添加Swift algorithms

245
00:16:53,400 --> 00:16:57,400
到我們的專案，但我不會這麼做。

246
00:16:57,400 --> 00:17:02,400
所以我選擇了EssentialFeed iOS目標

247
00:17:04,160 --> 00:17:09,160
並且我們將會看到目標設定

248
00:17:10,480 --> 00:17:14,680
和所有的標籤在Xcode的這部分。

249
00:17:17,080 --> 00:17:19,680
首先，有一個是一般標籤

250
00:17:21,200 --> 00:17:25,120
這跟專案信息標籤非常類似

251
00:17:25,120 --> 00:17:28,360
顯示每個目標的通用設定。

252
00:17:36,200 --> 00:17:38,640
首先，我們有身份組別，

253
00:17:38,640 --> 00:17:41,280
我們有Bundle display name，

254
00:17:42,680 --> 00:17:45,280
這是用戶看到的Bundle名稱。

255
00:17:46,280 --> 00:17:50,760
App targets指的是用戶看到的app名稱。

256
00:17:50,760 --> 00:17:53,040
例如，在iOS上，這是app名稱，

257
00:17:53,040 --> 00:17:56,080
您在裝置主畫面上看到的app名稱。

258
00:17:58,080 --> 00:18:01,560
使用BundleIdentifier來識別每個Bundle

259
00:18:03,080 --> 00:18:07,040
這通常是反向DNS地址。

260
00:18:07,040 --> 00:18:11,600
因此在我們的情況下，它是com.essentialdeveloper.EssentialFeediOS。

261
00:18:13,880 --> 00:18:16,640
接下來是版本和構建，

262
00:18:16,640 --> 00:18:21,640
這兩個是從Info.plist.cfbundle version 

263
00:18:21,640 --> 00:18:26,640
和 cfbundle短版本字符串值解析出來的。

264
00:18:29,720 --> 00:18:32,040
接下來，部署信息標籤。

265
00:18:35,200 --> 00:18:39,160
如之前所述，這代表了每個平台的最低支持OS版本

266
00:18:39,160 --> 00:18:42,600
如果目標是多平台的話。


267
00:18:44,360 --> 00:18:46,320
再次強調，那些都是相同的值

268
00:18:46,320 --> 00:18:49,560
來自於建立設定部署部分的值

269
00:18:49,560 --> 00:18:53,120
改變其中一個會改變另一個。

270
00:18:55,540 --> 00:18:58,100
請注意，這些值優先於

271
00:18:58,100 --> 00:19:00,620
項目級別的部署目標，

272
00:19:01,620 --> 00:19:06,060
我們會在即將前往建立設定時解釋。

273
00:19:09,580 --> 00:19:12,260
接下來，我們有框架和庫，

274
00:19:12,260 --> 00:19:14,820
列出了所有模組

275
00:19:14,820 --> 00:19:17,940
目標會明確地連結到，

276
00:19:17,940 --> 00:19:22,300
即使Xcode可能會隱式解析依賴關係，

277
00:19:22,300 --> 00:19:24,440
但在此最好明確地保留。

278
00:19:25,540 --> 00:19:29,460
在此範例中，我們的EssentialFeediOS框架

279
00:19:29,460 --> 00:19:33,100
連結到EssentialFeed框架。

280
00:19:40,540 --> 00:19:45,080
連結類型可以是必需的或是選擇性的。

281
00:19:45,080 --> 00:19:48,620
當模組可能不存在於某些平台或OS版本

282
00:19:48,620 --> 00:19:51,100
我們會選用選擇性的。

283
00:19:52,780 --> 00:19:55,520
此外，我們有一個嵌入選項。

284
00:19:57,380 --> 00:20:02,020
基本上，嵌入是指複製該模組

285
00:20:02,020 --> 00:20:04,540
到目標的 Bundle 中。

286
00:20:04,540 --> 00:20:08,180
這在連接動態框架時非常有用

287
00:20:08,180 --> 00:20:10,500
或是動態庫。

288
00:20:10,500 --> 00:20:12,260
我知道這是一個廣泛的主題

289
00:20:12,260 --> 00:20:14,080
我不想深入討論，

290
00:20:14,080 --> 00:20:16,300
但你可能不需要嵌入框架

291
00:20:16,300 --> 00:20:18,740
或者靜態連接的庫

292
00:20:18,740 --> 00:20:22,700
因為鏈接器已經複製了所有符號

293
00:20:22,700 --> 00:20:24,400
你的二進制檔案用到的，

294
00:20:24,400 --> 00:20:26,260
所以我們不需要再嵌入它。

295
00:20:31,060 --> 00:20:34,980
最後，開發資源是在開發過程中使用的資源，

296
00:20:34,980 --> 00:20:39,980
比如在SwiftUI預覽中。

297
00:20:39,980 --> 00:20:44,980
這些並不會被複製到你的應用程式Bundle中。

298
00:20:45,500 --> 00:20:46,540
有問題嗎？

299
00:20:51,340 --> 00:20:54,020
所以問題是，如果我們提高了Main target的編譯號碼，

300
00:20:54,020 --> 00:20:55,540
我們是否也應該提高其他目標的編譯號？

301
00:20:55,540 --> 00:20:58,460
我們是否也應該提高其他目標的編譯號？

302
00:20:58,460 --> 00:20:59,480
在其他目標上？

303
00:20:59,480 --> 00:21:00,320
我認為不需要。

304
00:21:00,320 --> 00:21:01,700
我認為他們是獨立的

305
00:21:01,700 --> 00:21:03,860
每個目標都可以有自己的版本。

306
00:21:05,620 --> 00:21:09,240
接下來，我們要來看看簽名和能力。

307
00:21:09,240 --> 00:21:12,380
對於這點，我認為EssentialApp

308
00:21:12,380 --> 00:21:14,220
會更好一些。

309
00:21:18,940 --> 00:21:22,220
所以每種配置都有其對應的代碼簽名設置。

310
00:21:24,180 --> 00:21:26,880
而這個螢幕顯示的是錯誤

311
00:21:26,880 --> 00:21:29,780
表示設定有錯，就像我的情況。

312
00:21:31,660 --> 00:21:34,220
這是因為我沒有安裝認證，

313
00:21:34,220 --> 00:21:35,940
或者是供應配置文件，

314
00:21:35,940 --> 00:21:40,140
所以Xcode會這樣標記出來。

315
00:21:43,980 --> 00:21:47,540
第一個選項是讓Xcode自動管理簽名，

316
00:21:47,540 --> 00:21:51,120
基本上就能讓Xcode自動創建，

317
00:21:51,120 --> 00:21:53,560
更新證書和供應，

318
00:21:53,560 --> 00:21:56,660
並確保您確實使用的是最新的證書。

319
00:21:56,660 --> 00:22:00,500
我更偏好自己手動管理我的項目，

320
00:22:00,500 --> 00:22:01,960
所以我可以對它們有控制，

321
00:22:01,960 --> 00:22:06,960
但這只是我個人的偏好。

322
00:22:07,860 --> 00:22:10,820
團隊識別碼是一個獨特的識別碼，

323
00:22:10,820 --> 00:22:13,380
這在蘋果開發者計劃中被指定

324
00:22:13,380 --> 00:22:15,720
給每一隊伍，並在應用程式間分享。

325
00:22:19,280 --> 00:22:24,280
BundleIdentifier是每一個應用程式獨有的，

326
00:22:25,300 --> 00:22:29,860
需要與應用程式標識符合，

327
00:22:29,860 --> 00:22:33,180
它是這種描述應用程式的抽象實體

328
00:22:33,180 --> 00:22:35,180
及其功能，

329
00:22:35,180 --> 00:22:39,180
並且是通過Apple開發者帳戶管理的。

330
00:22:40,940 --> 00:22:43,500
接下來，我們有簽名憑證，

331
00:22:44,540 --> 00:22:47,820
這是一個需要有效的證書

332
00:22:47,820 --> 00:22:50,520
並用於簽署二進制文件。

333
00:22:52,300 --> 00:22:57,300
配給檔案剖面是這種抽象的實體

334
00:22:57,300 --> 00:22:59,840
基本上連接了應用程式ID，

335
00:22:59,840 --> 00:23:03,040
一個或多個簽名證書和裝置列表。

336
00:23:09,720 --> 00:23:13,560
您也可以在小圖表中看到這一點

337
00:23:15,800 --> 00:23:20,800
這裡配給檔案剖面是中心位置

338
00:23:20,960 --> 00:23:23,800
是這種裝置之間的關係，

339
00:23:23,800 --> 00:23:27,300
證書和應用程式標識符。

340
00:23:32,740 --> 00:23:36,920
此螢幕也允許管理功能。

341
00:23:36,920 --> 00:23:40,720
功能是從應用程式傳輸安全性


342
00:23:40,720 --> 00:23:45,080
異常，相關域，背景模式，

343
00:23:46,520 --> 00:23:51,520
鑰匙鏈共享，推送通知，

344
00:23:51,520 --> 00:23:56,080
iCloud，應用內購買，

345
00:23:56,080 --> 00:23:58,860
使用Apple登入，等等。

346
00:24:04,120 --> 00:24:06,800
下一個標籤是資源標籤。

347
00:24:07,920 --> 00:24:12,360
這些是按需下載的資源，只有在需要時才下載，

348
00:24:12,360 --> 00:24:14,560
因此並未內嵌在應用程式包中。

349
00:24:15,640 --> 00:24:17,960
它們特別有用，

350
00:24:17,960 --> 00:24:20,680
當您的應用需要大量資源時，

351
00:24:20,680 --> 00:24:22,940
但您不希望增加您的應用大小

352
00:24:22,940 --> 00:24:24,440
在AppStore上。

353
00:24:24,440 --> 00:24:26,000
應用大小很重要。

354
00:24:26,920 --> 00:24:29,280
應用程式越小，用戶就越容易

355
00:24:29,280 --> 00:24:30,960
下載並嘗試它。

356
00:24:30,960 --> 00:24:33,800
例如，Apple的限制是50兆字節，

357
00:24:33,800 --> 00:24:38,280
或者曾經是50，超過該限制的應用程式

358
00:24:38,280 --> 00:24:40,440
只能通過WiFi下載。

359
00:24:44,400 --> 00:24:46,160
接下來是資訊標籤。

360
00:24:46,160 --> 00:24:50,000
這是由Info.plist的設定填充的，

361
00:24:50,880 --> 00:24:54,000
讓我們可以以不同的方式編輯此檔。

362
00:24:54,000 --> 00:24:57,080
如你們可以看到，某些值

363
00:24:57,080 --> 00:25:00,200
可以使用在構建時間解決的變數。

364
00:25:00,200 --> 00:25:03,480
例如，Bundle名稱是解析的

365
00:25:03,480 --> 00:25:05,560
到dollar product underscore name，

366
00:25:05,560 --> 00:25:17,120
dollar product underscore name，實際上是一個構建設定。

367
00:25:17,120 --> 00:25:18,440
現在變得有趣了。

368
00:25:20,040 --> 00:25:21,720
我們正在查看構建設定。

369
00:25:22,760 --> 00:25:27,640
有幾個選擇可以查看這些設定。

370
00:25:28,880 --> 00:25:32,600
預設的Xcode是基本並合併的。

371
00:25:32,600 --> 00:25:36,200
它只顯示以綜合方式的基本設定，

372
00:25:36,200 --> 00:25:43,320
這基本上意味著只有特定設定時才顯示的配置

373
00:25:43,320 --> 00:25:46,680
當他們特別設定時。

374
00:25:47,640 --> 00:25:51,480
我並不真的使用這個視圖，

375
00:25:51,480 --> 00:25:54,200
所以我想看到我所有的設定

376
00:25:54,200 --> 00:25:57,560
我喜歡levels viewer

377
00:25:57,560 --> 00:26:02,360
因為它使設定更清晰。

378
00:26:07,560 --> 00:26:09,000
那麼什麼是建置設定？

379
00:26:09,000 --> 00:26:12,920
建置設定是一種可以應用到您的Xcode目標的屬性，

380
00:26:12,920 --> 00:26:15,480
用於配置如何建成的各個方面。

381
00:26:19,960 --> 00:26:23,720
建置設定可以自訂每個配置，

382
00:26:23,720 --> 00:26:27,640
每個配置、SDK平台等。

383
00:26:30,520 --> 00:26:34,440
管理建置設定是通過兩種機制來實現的。

384
00:26:34,440 --> 00:26:36,680
一種是通過Xcode的建置設定編輯器，

385
00:26:36,680 --> 00:26:37,800
就像我剛才顯示的，

386
00:26:37,800 --> 00:26:40,600
另一種是通過配置文件，

387
00:26:40,600 --> 00:26:43,560
我也提到過，那些XC配置文件。

388
00:26:43,560 --> 00:26:47,400
理解Xcode如何解析建置設定是很有趣的。

389
00:26:48,840 --> 00:26:56,680
每次建置或其他操作之前，都要使用建置設定，

390
00:26:56,680 --> 00:26:59,080
系統必須解析所有的建置設定

391
00:26:59,080 --> 00:27:00,600
對每個正在建的目標。

392
00:27:02,200 --> 00:27:04,600
它使用一種基於回退的系統

393
00:27:04,600 --> 00:27:07,400
並且它不是一個標準的系統。

394
00:27:07,400 --> 00:27:09,000
這不是一個標準的系統，

395
00:27:09,000 --> 00:27:15,960
它使用了一種後備系統，並在這種圖形表示中，

396
00:27:15,960 --> 00:27:18,760
以及在Xcode建構設置頁籤中，

397
00:27:19,400 --> 00:27:24,200
優先級從左至右遞減，或從右至左遞增。

398
00:27:27,320 --> 00:27:31,160
所以首先我們解析，

399
00:27:31,160 --> 00:27:38,680
這就是最終將由建構工具使用的值。

400
00:27:40,120 --> 00:27:41,800
接下來是目標設置。

401
00:27:42,600 --> 00:27:47,560
這些是明確的目標設定，它們覆蓋了任何其他設置。

402
00:27:49,160 --> 00:27:51,320
如果我們設定一個目標配置文件，

403
00:27:51,320 --> 00:27:56,360
它將覆蓋所有的設置，除了左邊的目標明確設定。

404
00:27:57,400 --> 00:28:02,360
然後有專案設置，明確的設置。

405
00:28:04,680 --> 00:28:07,640
當目標設置缺失時，他們會被使用。

406
00:28:08,440 --> 00:28:11,640
否則，它們將會被目標設置覆蓋。

407
00:28:14,200 --> 00:28:17,720
專案配置文件也適用此規則。

408
00:28:17,720 --> 00:28:21,320
如果設定的話，這只會覆蓋平台的預設值。

409
00:28:21,320 --> 00:28:25,960
否則，它將被它左侧的任何東西覆蓋。

410
00:28:27,320 --> 00:28:29,880
最後，有平台預設值。

411
00:28:31,160 --> 00:28:37,080
每個設定可以有一個平台預設值或只是空值。

412
00:28:38,120 --> 00:28:43,320
如果沒有提供其他設定，解析器將使用這些。

413
00:28:43,320 --> 00:28:47,000
為了更清楚，我們應該看一些例子。

414
00:28:48,440 --> 00:28:49,880
所以回到Xcode。

415
00:28:55,240 --> 00:29:00,600
使用EssentialFeed。

416
00:29:00,600 --> 00:29:07,960
使用EssentialFeed。

417
00:29:13,080 --> 00:29:17,240
我選擇了buildActiveArchitectureOnly設定。

418
00:29:18,680 --> 00:29:21,000
我們從右到左來看。

419
00:29:21,000 --> 00:29:26,920
首先，我們可以看到macOS預設設定為否。

420
00:29:26,920 --> 00:29:34,200
然後在EssentialFeed項目中，對於調試配置，我們有一個明確的值設為是。

421
00:29:35,240 --> 00:29:42,200
我們知道這一點，因為該值周圍有一個粗框，文字也是粗體的。

422
00:29:44,200 --> 00:29:49,160
然後在專案上，在目標級別，沒有額外的設置。

423
00:29:49,160 --> 00:30:02,280
因此，最終的Result值對於debug配置是yes，對於release配置則是no，因為它在這種情況下只使用默認值。

424
00:30:08,200 --> 00:30:11,480
另一個是 code signing identity。

425
00:30:14,840 --> 00:30:17,640
平台默認為本地運行的簽名。

426
00:30:17,640 --> 00:30:31,160
我們有一個專案級別的設置，設置為Mac developer，但我們在EssentialFeed目標上也有一個空值設置。

427
00:30:31,880 --> 00:30:34,920
我們看到這一點，因為周圍有這個框。

428
00:30:34,920 --> 00:30:47,240
所以Result值也會是一個空值，因為在這種情況下，該目標有一個明確的設置。

429
00:30:54,120 --> 00:30:57,720
讓我們也來看看iOS的部署目標。

430
00:30:57,720 --> 00:31:02,280
所以在這個情況下，macOS的預設是iOS 15.2。

431
00:31:02,280 --> 00:31:10,840
對於iOS 14.0有一個專案設定，而EssentialFeed目標並無覆寫。

432
00:31:10,840 --> 00:31:13,560
所以結果值是iOS 14.0。

433
00:31:14,360 --> 00:31:17,320
我認為這使得它更清晰一些。

434
00:31:19,560 --> 00:31:21,320
嗯，我看到Dennis留的評論。

435
00:31:21,320 --> 00:31:33,400
的確，如果我們使用助手，我們可以看到這些設定的概要。

436
00:31:35,800 --> 00:31:37,160
這非常有用。

437
00:31:41,480 --> 00:31:42,440
那麼, 構建階段。

438
00:31:42,440 --> 00:31:50,520
這是一個非常重要的部分，它定義了實際構建過程中的步驟和／或關閉步驟。

439
00:31:51,560 --> 00:31:53,720
有幾個預定義的階段。

440
00:31:57,320 --> 00:32:02,920
首先，我將使用EssentialApp。

441
00:32:02,920 --> 00:32:12,040
依賴性。所以明確設定模組之間的依賴性。

442
00:32:13,080 --> 00:32:19,960
設定這種依賴關係會確保在建構我們自己的目標之前，如果需要，Xcode會先建構該依賴。

443
00:32:23,480 --> 00:32:24,760
在這種情況下，我們沒有任何依賴。

444
00:32:26,600 --> 00:32:28,440
接下來，編譯源碼。

445
00:32:28,440 --> 00:32:33,480
這包含所有即將進行編譯的當前目標的源文件。

446
00:32:35,720 --> 00:32:38,600
並且還可以包括編譯器標誌。

447
00:32:40,600 --> 00:32:42,520
與庫連結二進位檔。

448
00:32:43,240 --> 00:32:47,320
列出目標二進位檔將連結的所有模組。

449
00:32:47,320 --> 00:32:53,400
在我們的情況下，EssentialApp連結到EssentialFeed架構和EssentialFeed iOS架構。

450
00:32:53,400 --> 00:33:08,600
接下來是複製 Bundle 資源，該列表列出了所有複製到目標 Bundle 內的資源。

451
00:33:08,600 --> 00:33:15,560
這可能包括任何種類的檔案，例如字串檔案，故事板，XIBs，素材檔案，圖片，字體等等。

452
00:33:15,560 --> 00:33:27,880
而最後一個是 Embed frameworks, 列出了所有將被嵌入到目標 Bundle 的框架。

453
00:33:27,880 --> 00:33:29,880
所以被複製到目標 Bundle 中。

454
00:33:29,880 --> 00:33:43,720
我們也可以添加更多階段，自定義階段，例如複製文件階段或運行腳本階段，我們可以進行需要的自定義操作。

455
00:33:45,720 --> 00:33:49,720
為了加快構建過程，我們可以優化某些建立步驟。

456
00:33:49,720 --> 00:34:00,600
因此，例如，我們可以根據建立類型跳過一些步驟。

457
00:34:00,600 --> 00:34:15,640
當為預覽建立時，沒有必要運行 linter，或者當為模擬器建立時，我們可以跳過生成和上傳調試符號。

458
00:34:15,640 --> 00:34:21,720
最後一個標籤是建立規則。

459
00:34:23,720 --> 00:34:27,800
建立規則指定了應如何編譯不同的文件類型。

460
00:34:28,600 --> 00:34:34,520
如果我們想要對某種File類型加入自定義處理，你可以簡單地增加一個新的建構規則。

461
00:34:35,960 --> 00:34:42,120
它們與建構階段相似，只是每種特定File類型會執行一次。

462
00:34:42,120 --> 00:34:50,120
所以，如果你需要對一些文件進行自定義處理，並行地，一個建構規則比一個建構階段更適合。

463
00:34:56,120 --> 00:35:00,120
接下來，是PBX proj格式。

464
00:35:00,120 --> 00:35:18,120
所以，我們可以通過Xcode專案或目標標籤控制的每一個選項在這個位於Xcode proj文件夾內的PBX proj文本File中都有相應的條目。

465
00:35:18,120 --> 00:35:24,120
理解這個File的基本結構將有助於你處理未來的衝突。

466
00:35:24,120 --> 00:35:32,120
例如，當兩個或多個開發者同時編輯專案File時。我確定這曾經發生在你身上。

467
00:35:32,120 --> 00:35:38,120
所以，讓我們來看看EssentialApp專案的File。

468
00:35:38,120 --> 00:35:48,120
首先，我們知道這是一個包含各種部分的簡單XML File。

469
00:35:48,120 --> 00:36:00,120
讓我們看看它們。PBX構建File部分包含了包含在專案中的所有文件、框架和其他資源。

470
00:36:04,120 --> 00:36:10,120
這是一個構建階段，所以是copy File構建階段。

471
00:36:10,120 --> 00:36:18,120
PBX File reference包含了專案中所有文件的引用。

472
00:36:20,120 --> 00:36:32,120
在其他構建階段裡，PBX組部分包含了所有你在Xcode專案導引中看到的Xcode組和它們的結構。

473
00:36:32,120 --> 00:36:42,120
那麼，舉例來說，這些助手有所有這些子項目，它可以這樣運行。

474
00:36:44,120 --> 00:36:52,120
本機目標通常代表一個目標。所以，在這種情況下，它就是EssentialApp目標。

475
00:36:52,120 --> 00:37:02,120
如你所見，它擁有幾個像產品類型，產品參考的設置，這模仿了我們已經在Xcode中有的設置。

476
00:37:02,120 --> 00:37:10,120
接下來是EssentialApp測試目標以及任何其他可能存在的目標。

477
00:37:10,120 --> 00:37:22,120
PBX項目包含了項目設置，所以這些東西像最後的Swift更新檢查，組織名稱，

478
00:37:24,120 --> 00:37:32,120
本地化，所有我們可以通過項目資訊標籤設置的東西。

479
00:37:32,120 --> 00:37:40,120
然後我們提到的資源建置階段，會複製故事板和XC資源。

480
00:37:42,120 --> 00:37:48,120
源碼建置階段包含所有傳遞給編譯器的文件。

481
00:37:50,120 --> 00:37:56,120
當然，之所以有兩個，是因為我們有兩個目標。

482
00:37:56,120 --> 00:38:06,120
我特別想看的是XC構建配置部分。

483
00:38:06,120 --> 00:38:10,120
這包含了我們剛剛查看過的所有Xcode建設設置。

484
00:38:12,120 --> 00:38:22,120
這裡有趣的是，設置常常重複，因為我們通常會為每一個項目或目標與配置組合獲得一套設定。

485
00:38:22,120 --> 00:38:38,120
所以在我們的案例中，由於我們有一個項目，那就是EssentialApp，並有兩個目標，EssentialApp 和 EssentialAppTests，再加上兩個設定，debug 和 release，

486
00:38:38,120 --> 00:38:50,120
我們將會有六套設置。所以第一套設置是項目加上debug配置設置，你可以在這裡看到。

487
00:38:52,120 --> 00:38:56,120
然後是同一個項目配合release配置。

488
00:38:56,120 --> 00:39:08,120
然後是第一個目標包含debug配置，第一個目標包含release配置，第一個目標是EssentialFeed應用程式。

489
00:39:08,120 --> 00:39:16,120
然後是EssentialFeed應用程式的Tests，debug配置和release配置。挺讓人困惑的，對吧？

490
00:39:16,120 --> 00:39:26,120
現在，我想做個快速的練習，看看在這個結構中，文件實際上出現了多少次。

491
00:39:26,120 --> 00:39:32,120
所以如果我使用FeedUIComposer，我會看到四個條目。

492
00:39:32,120 --> 00:39:46,120
所以一個位於建置文件部分，一個在文件參考部分，一個在群組中，該群組是EssentialApp群組，還有一個在來源建置階段部分。

493
00:39:46,120 --> 00:39:50,120
在編輯衝突時請記住這一點。

494
00:39:50,120 --> 00:40:02,120
另外，我可以做一件有趣的事，就是在EssentialApp中添加一個文件。

495
00:40:02,120 --> 00:40:18,120
我將它命名為我的檔案。

496
00:40:18,120 --> 00:40:38,120
我將會使用源控制，實際上它並不是那麼好。

497
00:40:38,120 --> 00:40:50,120
所以，是的，你看，又有四個項目，一，二，三，和四。

498
00:40:50,120 --> 00:40:52,120
然後回到 sublime。

499
00:40:52,120 --> 00:41:02,120
我會使用我的 sublime。

500
00:41:02,120 --> 00:41:26,120
同樣的情況。因此，在PBX建立檔案部分一次，在檔案引用部分一次，在組中一次，以及在源建構階段一次。

501
00:41:26,120 --> 00:41:44,120
Lucky 說我通常會在 PBX 衝突檔案中搜尋更小，更小，更小，更小的符號，並移除相互衝突的項目。

502
00:41:44,120 --> 00:41:47,120
對，我們通常就是這麼做的。

503
00:41:47,120 --> 00:42:02,120
有一些工具可以自動進行這種工作，但我的重點是理解格式，因為若你破壞了格式，您將開啟一個無法開啟的專案。

504
00:42:02,120 --> 00:42:18,120
可能更糟的事情可以發生，例如你可能會從專案中漏掉一些文件或者類似的事情。

505
00:42:18,120 --> 00:42:22,120
米蘭表示每個文件都會有偶數的條目。

506
00:42:22,120 --> 00:42:33,120
這部分是正確的，因為這取決於你將檔案添加到多少目標。因此，如果你在一個以上的目標上添加了該文件，則可能會得到一個奇數。

507
00:42:33,120 --> 00:42:39,120
所以最好做一個檢查。

508
00:42:39,120 --> 00:42:52,120
接下來，我想快速地看一下Xcode新的專案模板。

509
00:42:52,120 --> 00:43:01,120
還有這裡的介面選項，它讓你選擇使用 SwiftUI 或是 Storyboard。

510
00:43:01,120 --> 00:43:07,120
這在幾天前的Slack中提到。

511
00:43:07,120 --> 00:43:16,120
我們需要理解，這個選擇僅適用於由Xcode模板自動填充的UI入口點。

512
00:43:16,120 --> 00:43:38,120
我們始終可以製作SwiftUI和UIKit，這是storyboards背後的東西，以及沒有任何問題的從代碼中創建的XIBs和UI。 我們也可以在任何時候改變app的入口點。

513
00:43:38,120 --> 00:43:51,120
通過選擇SwiftUI界面選項，我們只獲得一個實現app Protocol的struct，該struct由Main入口點標記，在屏幕右側以at Main的形式表示。

514
00:43:51,120 --> 00:44:06,120
另一方面，如果我們選擇Storyboard選項，這意味著兩件事。 Main 或 UIApplication Main的app入口點設置在AppDelegate類上。

515
00:44:06,120 --> 00:44:14,120
並且在 info P 列表中，新創建的 Main Storyboard 被設定為初始的 Storyboard。

516
00:44:14,120 --> 00:44:19,120
我們可以輕易地移除 Storyboard 並且完全用代碼創建所有的 UI。

517
00:44:19,120 --> 00:44:48,120
我們只需要去 SceneDelegate 並做三件事情。創建一個 UI window instance，將它的 root ViewController 設定為我們需要先顯示的控制器，然後呼叫 make key invisible。

518
00:44:48,120 --> 00:44:59,120
我們將快速地看一下預設的 project 結構。

519
00:44:59,120 --> 00:45:06,120
所以，大多數的 projects 都會有幾個我想要強調的共通元素。

520
00:45:06,120 --> 00:45:15,120
首先，AppDelegate 和 SceneDelegate。

521
00:45:15,120 --> 00:45:27,120
所以 AppDelegate 和 SceneDelegate 是 app 的主要進入點。這通常是我們將我們的 CompositionRoot components 掛勾到的地方。

522
00:45:27,120 --> 00:45:36,120
然後我們有主要故事板檔案，它在我們的情況下被刪除了，以及啟動畫面故事板。

523
00:45:36,120 --> 00:45:50,120
通常情況下，Xcode 會預設創建空的故事板。如果你選擇故事版 UI 選項。啟動畫面通常是操作系統在應用程式啟動時顯示的靜態畫面。

524
00:45:50,120 --> 00:45:54,120
Main 可以包含應用程式的初始畫面。

525
00:45:54,120 --> 00:46:11,120
我建議你至少將每個畫面分開為一個單獨的故事板，或者看起來更容易管理，包括源控制。

526
00:46:11,120 --> 00:46:17,120
Assets 是應用程式使用的資源目錄。

527
00:46:17,120 --> 00:46:27,120
幾乎所有應用程式都有的 Info.plist，包含了重要的目標或 Bundle 設定。

528
00:46:27,120 --> 00:46:45,120
然後我們有一個列出當前專案中所有產品的列表，而這些產品可以是app target、framework target、Bundle等等。

529
00:46:45,120 --> 00:46:55,120
而這裡有一個清單列出了專案目標所鏈接的所有框架。

530
00:46:55,120 --> 00:47:06,120
大致上對於預設的專案結構就是這樣。現在，我想要來看一下Xcode應用程式的Package內容。

531
00:47:06,120 --> 00:47:11,120
所以我打開了查找器（Finder）。

532
00:47:11,120 --> 00:47:17,120
我打開了應用程式資料夾。

533
00:47:17,120 --> 00:47:23,120
我正在打開Xcode應用程式的Package並查看其內容。

534
00:47:23,120 --> 00:47:35,120
首先，在應用程式資料夾中，我們可以看到一些內嵌的應用程式，例如File merge，這是一個很好的diffing和 merging文字檔案的工具。

535
00:47:35,120 --> 00:47:49,120
我們也看到Instruments在這裡。如果我去開發者應用程式，我可以找到模擬器應用程式或Xcode伺服器Builder應用程式。

536
00:47:49,120 --> 00:48:09,120
在開發者平台下，有所有Xcode支援並允許我們連結的平台。所以這包含了Apple TV, iPhone, macOS, watches, 以及driver Kit。

537
00:48:09,120 --> 00:48:14,120
讓我們來看看iPhone OS平台。

538
00:48:14,120 --> 00:48:26,120
首先，我們看到一個設備支援文件夾。這很重要，因為它包含了不同OS版本的符號圖像，可以追溯到非常、非常久遠的時候。

539
00:48:26,120 --> 00:48:33,120
因此在這個情況下，我們有來自iOS 9到iOS 15.2的符號。

540
00:48:33,120 --> 00:48:46,120
這些讓我們可以實際上將我們的Xcode連接到任何這些操作系統上的設備的調試會話。

541
00:48:46,120 --> 00:48:59,120
但它也帶來了一個限制，即如果你在你的手機上升級了你的操作系統，你可能無法使用Xcode調試器，除非你升級了Xcode。

542
00:48:59,120 --> 00:49:08,120
有一些小方式可以解決這問題，但一般來說，你應該小心並同時升級兩者。

543
00:49:08,120 --> 00:49:26,120
在開發者SDKs下，我們可以看到嵌入式SDKs是什麼。所以在這種情況下是iOS 15.2 SDK。

544
00:49:26,120 --> 00:49:37,120
而在工具鏈下，我們有這個Xcode預設的工具鏈。

545
00:49:37,120 --> 00:49:55,120
例如，我們可以看到幾個Swift的版本。所以在這個案子中，有Swift 5.5版本和Swift 5.0版本。

546
00:49:55,120 --> 00:50:04,120
所以，這意味著Xcode至少在其軟體包中嵌入了一個Swift版本。

547
00:50:04,120 --> 00:50:13,120
例如，Xcode 12.5曾經內嵌Swift 5.4。

548
00:50:13,120 --> 00:50:32,120
如果您想在不升級或降級Xcode的情況下安裝其他的Swift版本，您可以通過添加新的工具鏈來安裝。

549
00:50:32,120 --> 00:50:46,120
蘋果有一個很好的網頁，告訴我們一些有關Xcode，其最低需求操作系統版本等有趣的信息，

550
00:50:46,120 --> 00:50:55,120
包括SDKs，架構，發布目標，模擬器和對我而言重要的Swift版本。

551
00:50:55,120 --> 00:51:16,120
所以你可以使用這個頁面，來理解你需要哪一版的Xcode來支援特定版本的Swift，或是特定的模擬器等等。

552
00:51:16,120 --> 00:51:29,120
多個版本的Xcode可以在同一部機器上成功運作，但除非你有強烈的需求，以便於使用且機器更乾淨，

553
00:51:29,120 --> 00:51:33,120
我建議一次只保留一個版本。

554
00:51:33,120 --> 00:51:52,120
但如果你真的需要多個版本，你可以輕鬆地在Dash applications下面進行不同名稱的Xcode apps安裝，或是使用像是Xcode install的工具。

555
00:51:52,120 --> 00:52:04,120
你可以透過使用Xcode偏好設定位置選單，來選擇哪一個版本的Xcode在運行CommandLine命令時被使用。

556
00:52:04,120 --> 00:52:22,120
這個選項，CommandLine工具，如果我有多個版本的Xcode，這就是我選擇要使用哪一個來建構Xcode的指令的地方。

557
00:52:22,120 --> 00:52:36,120
只需要記住，所有版本的Xcode會使用一些公共路徑，例如library developer DI data或library Cache Xcode等，因此可能會發生一些衝突。

558
00:52:36,120 --> 00:52:47,120
我過去常常遇到的一種情況是，嘗試使用不同版本的Xcode來構建同一個項目，通常會因為快取的元件而出錯。

559
00:52:47,120 --> 00:52:53,120
這個問題現在可能已經修正了，但還是記住這可能會發生。

560
00:52:53,120 --> 00:53:04,120
所以，只有當你真的需要它们時，才安裝多個版本。

561
00:53:04,120 --> 00:53:10,120
就是這樣。感謝大家耐心聽我講解。現在我們有時間來做問答。

562
00:53:10,120 --> 00:53:23,120
好的，我來看看問題。所以我個人建議從Apple developer下載Xcode app，而不是從AppStore下載。對，無所謂。你想從哪裡獲取都可以。

563
00:53:23,120 --> 00:53:31,120
我想在這裡補充一點。一定要從官方來源下載。不要從網路上獲取像是通用的Xcodes。

564
00:53:31,120 --> 00:53:38,120
對，從Apple網站獲取。確保你下載的是正確的checksum。

565
00:53:38,120 --> 00:53:49,120
Caio，你指的是幾年前那個情況，當時有一個破解、被黑客攻擊的Xcode版本在開發者之間流傳？

566
00:53:49,120 --> 00:53:51,120
確實如此。對的。

567
00:53:51,120 --> 00:54:02,120
好吧，那情況確實發生過，結果很多人受到影響。講得好。

568
00:54:02,120 --> 00:54:09,120
所以Lucky說很多時候編譯你應該得到固定的移除衍生數據。

569
00:54:09,120 --> 00:54:13,120
對，那是真的。

570
00:54:13,120 --> 00:54:35,120
基本上，衍生數據包含所有中間文件，比如在編譯過程中從你的源文件創建的AnyObject File，中間鏈接器文件，而且建構過程相當複雜。應該需要一個單獨的課程。

571
00:54:35,120 --> 00:54:51,120
是的，當你不明白你的問題是什麼時，你需要嘗試的其中一件事是嘗試清理衍生數據或是做一個項目清理看看是否可以解決。

572
00:54:51,120 --> 00:55:01,120
這通常是StackOverflow上推薦的解決方案。

573
00:55:01,120 --> 00:55:08,120
你能回到你顯示配置的幻燈片，你有測試配置嗎？

574
00:55:08,120 --> 00:55:11,120
可以。

575
00:55:11,120 --> 00:55:13,120
可以。

576
00:55:13,120 --> 00:55:25,120
這很重要，你不能將EssentialFeed的第一行調試版本與EssentialFeedAPI的發布版本鏈接，它們通常需要配置來匹配名稱。

577
00:55:25,120 --> 00:55:34,120
所以，如果你在EssentialFeed中添加新的配置階段，並希望將其鏈接到EssentialApp模塊，他們兩者都需要有相同名稱的配置，除非你自定義。

578
00:55:34,120 --> 00:55:43,120
因為當你構建目標時，會進入名為配置名稱的文件夾，並且你將嘗試在該文件夾中查詢所有依賴性。

579
00:55:43,120 --> 00:55:54,120
所以，如果你用調試版本構建應用程式，你會被添加到一個調試文件夾中，並且你將嘗試在調試文件夾內尋找其他模塊的動態框架的所有依賴性。

580
00:55:54,120 --> 00:56:02,120
但是，如果其中一個模組是用發布配置建立的，那麼將無法找到，因為它在另一個文件夾中。

581
00:56:02,120 --> 00:56:23,120
所以，除非你在建造設定中明確改變配置，否則你將無法做到這點。這就是為什麼如果你在Xcode中創建自定義配置名稱，你將需要為你所有的其他依賴添加這個配置，以確保他們都能被正確建造，並在運行時連結他們。

582
00:56:23,120 --> 00:56:28,120
對，那確實是另一個好點，Caio。

583
00:56:28,120 --> 00:56:32,120
在你真正需要的時候，總是要離網而行。

584
00:56:32,120 --> 00:56:54,120
周圍有很多針對建置設定的解決方案，比如說使用條件式以避免創建額外的設定，或者甚至去刪除主要的那些，這些都會導致許多頭痛的問題。

585
00:56:54,120 --> 00:57:04,120
如果你想讓它更有客製化，可能最好使用XC config，這個我們將在另一堂課中詳細介紹。

586
00:57:04,120 --> 00:57:10,120
關於專案檔案中的衝突，這裡還有另一個評論。

587
00:57:10,120 --> 00:57:34,120
你提到可以考慮使用第三方解決方案，例如Tuist或XcodeGen，來管理額外的項目。是的，這是很有趣的方向。但這也在你的技術棧中增加了新的依賴，所以要確定你是否真的想這麼做，因為也許有一天XcodeGen就不再被維護了，你可能得親自來維護它。

588
00:57:34,120 --> 00:57:38,120
我知道我們經歷過幾次這種情況。

589
00:57:38,120 --> 00:57:54,120
是的，所以這裡的問題是如果你在項目中有衝突，就像有很多人在同一個項目中工作並且總是有衝突，因為如果兩個人都向項目中添加了文件，並嘗試合併他們的更改，那麼總有人要來處理這個衝突。

590
00:57:54,120 --> 00:57:56,120
是的。

591
00:57:56,120 --> 00:58:12,120
所以人們找到的解決方案之一就是不使用Xcode專案。有工具可以從配置文件生成Xcode專案，這樣你就會有更少的衝突，但是你將需要這個工具來生成Xcode。

592
00:58:12,120 --> 00:58:23,120
而或許它們將來可能不再被支援。並且當Xcode 14問世的時候，它可能無法與Xcode 14配合使用，然後開始出現問題。

593
00:58:23,120 --> 00:58:37,120
所以每次你引入由他人建立、開放源碼的額外依賴性時，如同Bogdan所說的，請注意如果別人停止提供支援，你可能要自己來支援它。

594
00:58:37,120 --> 00:58:41,120
這將可能在未來對您造成很大的成本。

595
00:58:41,120 --> 00:58:49,120
而如果您了解PBX項目中的項目結構。

596
00:58:49,120 --> 00:58:56,120
處理衝突的問題其實相當簡單，對吧？

597
00:58:56,120 --> 00:59:14,120
另一點，總是遵循良好的模塊設計。如果您團隊中有太多人在同一個項目中工作，可能將其分成獨立的項目，讓人們可以在系統的部分地區獨立工作，而不產生太多衝突，並且均勻地整合我們的代碼。

598
00:59:14,120 --> 00:59:29,120
儘可能地，每天多次合併。如果您有持續數周的特性分支，當需要合並這些數周的工作時，將會出現許多衝突。但如果您總是在合併，處理小衝突直至大衝突會變得容易得多。

599
00:59:29,120 --> 00:59:36,120
所以總是將你的代碼連續合併到主分支，一天內多次。這就是持續集成。

600
00:59:36,120 --> 00:59:41,120
我們非常推薦這麼做。

601
00:59:41,120 --> 00:59:52,120
下一個問題是，是否可以安全地從Xcode應用項目中刪除iOS 9 和 12 的文件夾。

602
00:59:52,120 --> 01:00:06,120
所以，從Xcode刪除那些較舊的文件夾安全嗎？我不認為是的。我不會建議刪除該Bundle中的任何東西，因為你永遠不知道會出什麼問題。

603
01:00:06,120 --> 01:00:16,120
義大利的下一個問題是，如何使用快捷方式顯示彈出視窗以找到Xcode項目中的符號文件？

604
01:00:16,120 --> 01:00:24,120
我認為它是command shift O。是的，你能快速打開Xcode嗎？可以。

605
01:00:24,120 --> 01:00:29,120
就是 command shift O。對。

606
01:00:29,120 --> 01:00:39,120
輸入任何東西。自動完成功能相當好用。

607
01:00:39,120 --> 01:00:41,120
好。

608
01:00:41,120 --> 01:00:50,120
Milan在先前的Xcode版本中說，我們可以使用跳躍欄控制+1來檢查元使用者。 

609
01:00:50,120 --> 01:01:06,120
打開被呼叫者，但在Xcode 13中已經被移除。你知道這裡有什麼解決方案嗎？我認為，至少被呼叫者助手仍在那裡。所以，我不確定。

610
01:01:06,120 --> 01:01:13,120
可能你錯過了演講的開始部分，但你確實顯示了被呼叫者助手。對。

611
01:01:13,120 --> 01:01:24,120
右鍵點擊同樣可以顯示特定方法或屬性的使用情況。

612
01:01:24,120 --> 01:01:35,120
找到。對，找到。呼叫階層。對。

613
01:01:35,120 --> 01:01:42,120
可能它不運作。

614
01:01:42,120 --> 01:01:48,120
有一個。

615
01:01:48,120 --> 01:01:55,120
也從米蘭來. 是否更好地為dev, QA, UAT和prod創建不同的目標？

616
01:01:55,120 --> 01:01:59,120
你對於管理多個環境有什麼建議？

617
01:01:59,120 --> 01:02:16,120
嗯，如我所說，這確實取決於情況。有更多的方式可以做這種分隔。我或許更偏好為目標保持最小化並利用不同設定檔進行工作。

618
01:02:16,120 --> 01:02:41,120
但這確實取決於情況。所以，如果我不知道，UAT和prod之間唯一的區別就是網路服務的URL，那麼那可以透過有條件的設定檔或類似的東西解決，而不是保留一組額外的設定集。

619
01:02:41,120 --> 01:02:58,120
所以，我認為當你有多個配置和目標時，最大的問題是你必須管理每一個目標和配置的設置。因此，你有的配置和目標越少，管理它們就越容易。

620
01:02:58,120 --> 01:03:13,120
我知道很多人就直接跳入，是的，讓我們添加另一個配置或者，我不知道，我們以前有五個配置所以我們可以輕易地添加第六個，但是總是要考慮你試圖達成什麼，看看是否有任何簡化。

621
01:03:13,120 --> 01:03:32,120
像Caio所說的，我們也會試圖涵蓋XC config檔案。這可以是處理這種技巧的好方法，否則設置的維護工作將瘋狂繁重。

622
01:03:32,120 --> 01:03:48,120
另一個問題，是否可以好好利用像是 dash if 或 elif 的預處理器指令在不同配置的情況下？嗯，可以用的。

623
01:03:48,120 --> 01:04:09,120
我認為在我們的程式中也有提到，對，將這些搬到盡可能靠近入口點的位置，越接近組成路線和你的條件式越好，但是儘量避免在你的所有類別和更高級的模組和實體之間散播它們。

624
01:04:09,120 --> 01:04:14,120
這個肯定要避免的。

625
01:04:14,120 --> 01:04:27,120
下一個是很好的一個。至少我看過幾次。所以有時候當Xcode出乎意料地關閉，會彈出有兩個選項的視窗，保持Xcode版本或使用磁盤上的版本。

626
01:04:27,120 --> 01:04:36,120
如何選擇我們期望的那一個。好吧，在我的例子中，這是在你合併一個衝突或類似的情況時出現的。

627
01:04:36,120 --> 01:04:59,120
切換分支。切換分支也是另一個好例子，對。我嘗試使用硬碟上的版本，但基本上這告訴Xcode重載到硬碟上的任何東西，而不是保持其可能在Cache中的任何東西。

628
01:04:59,120 --> 01:05:15,120
但這可能並不是每一次的答案。對，經驗法則，因為我通常都在切換分支，而Xcode會保留舊版本在InMemory中，我只是想更新到硬碟上的任何東西，所以我也通常使用硬碟上的版本。

629
01:05:15,120 --> 01:05:25,120
或者可能有其他應用程式更改了磁盤上的File，而Xcode正在詢問，嘿，你要保留我在InMemory中的那一個，還是在磁盤上更改的那一個？

630
01:05:25,120 --> 01:05:35,120
通常你會希望保留在磁盤上的，但這取決於情況。可能有其他應用程式更改了File，你並不想保留那個版本。

631
01:05:35,120 --> 01:05:59,120
或者你剛對你的Xcode專案進行了一組更改，然後其他應用程式試圖重置那個，那麼在這種情況下，你可能不希望失去所有的更改。

632
01:05:59,120 --> 01:06:06,120
有任何訣竅嗎？

633
01:06:06,120 --> 01:06:16,120
儘量自動化操作。如果你想提高生產力，自動化處理事情。

634
01:06:16,120 --> 01:06:31,120
嘿，只是小問題，不是個問題，只是一個疑問。我在想像多個項目有不同的目標，對吧，每個目標都有不同的代碼簽名能力，對吧？

635
01:06:31,120 --> 01:06:49,120
所以我們通常使用帶有代碼簽名的應用程序。是的，我的意思是，將代碼簽名附到目標上的實際目的是什麼呢？因為我們通常不使用它。這有什麼特定的目的嗎？

636
01:06:49,120 --> 01:06:56,120
所以問題是我們是否應在每個目標上設定它，如代碼簽名設定？

637
01:06:56,120 --> 01:07:09,120
是的，大部分時候有時會顯示錯誤，但沒關係，因為當你編譯時並不會閱讀它，或者我是說那就是實際情況。它的實際用途是什麼，因為我們不需要設定它，或者不以那種方式使用它，對吧？

638
01:07:09,120 --> 01:07:15,120
好吧，如果你不使用它，你可以直接設定為不進行代碼簽名並完成它。

639
01:07:15,120 --> 01:07:21,120
這比看到一堆Xcode錯誤要容易得多。

640
01:07:21,120 --> 01:07:30,120
是的，這跟你在port spec中使用的第三方框架的情況一樣，你會看到可能有一種代碼簽名能力，但你並未使用它，對吧？

641
01:07:30,120 --> 01:07:41,120
對，通常像是分享開源項目應該設定為不簽署代碼這種東西，以免影響你的簽署。

642
01:07:41,120 --> 01:07:58,120
我不想開始一個更大的討論，但我真的建議盡可能使用靜態鏈接，因為它會使你的應用程序啟動和運行效能快得多。

643
01:07:58,120 --> 01:08:18,120
所以，當你使用靜態鏈接時，你不需要嵌入和簽署所有這些二進制文件。只有在你真正需要動態模組的時候才使用它。我幾週前在出版頻道分享了一篇文章，談到了這個問題。

644
01:08:18,120 --> 01:08:40,120
靜態與動態連結，你可以將其作為參考。但是，這就是為什麼我沒有這個重新簽名的問題，因為我大多數時間我從未使我的依賴性變成動態，所以它們不需要被簽名和嵌入。

645
01:08:40,120 --> 01:08:42,120
是的，我瞭解了。

646
01:08:42,120 --> 01:08:56,120
我的建議是選擇靜態，除非你真的做不到。所以，預設情況下應該是靜態的。無論如何，這就是例如Package manager預設的安裝方式，或者是CocoaPods，這是有原因的。

647
01:08:56,120 --> 01:09:15,120
對，所以你只在少數情況下需要動態模塊，比如你要在兩個或三個其他模塊之間共享庫，或者你有其他更特別的需求。

648
01:09:15,120 --> 01:09:22,120
那是您需要動態框架或庫的時候，除此之外，您應該可以很好地使用靜態的。

649
01:09:22,120 --> 01:09:27,120
如果你願意，我們可以在Slack中詳細討論這個問題。

650
01:09:27,120 --> 01:09:30,120
嗯，當然。

651
01:09:30,120 --> 01:09:39,120
我認為最後一個問題是，如果我們有推送通知和應用內購買，我們應該使用Xcode中的自動簽名功能嗎？

652
01:09:39,120 --> 01:10:00,120
對。任何在你的app ID上設定的能力都不會影響程式碼簽名。 是的，你可以用它。這是一個偏好問題，我認為對於許多人來說這很有用，因為他們可以避免理解什麼是供應檔案配置


653
01:10:00,120 --> 01:10:18,120
以及什麼是應用程式 ID，以及它們如何一起工作。由於我這麼做已經有很長一段時間，我喜歡控制並手動管理我的程式碼簽名身份，這樣我可以清理它們並確知其中的確切內容。

654
01:10:18,120 --> 01:10:27,120
但像我說的，這是一種偏好。如果你嘗試自動的方式，如果可以工作的話，那應該沒問題。

655
01:10:27,120 --> 01:10:39,120
我遇到過自動簽名的問題。我也會在我進行 Xcode 動作自動化時，例如，使用手動簽名。

656
01:10:39,120 --> 01:10:52,120
我可以定義我需要的任何設置，我的供應設定檔，我的證書，我可以非常精確的選擇我使用的是哪一個。我不會依賴於我不知道其運作方式的Xcode內部的某個神秘黑盒。

657
01:10:52,120 --> 01:11:05,120
因為當Xcode的自動簽名機能運作正常時，它真的很棒。但是當它出錯時，我完全不知道原因。沒有什麼好的回饋。但是當我使用手動簽名時，我感覺有更多的控制權。

658
01:11:05,120 --> 01:11:17,120
但要開始的話，從簡單開始。你知道，如果自動方式對你來說運作良好，那就繼續用。更先進的情境可能需要手動簽名。

659
01:11:17,120 --> 01:11:24,120
你需要花費一個小時或者更多的時間來理解。至少。

660
01:11:24,120 --> 01:11:27,120
什麼？遠遠不止。

661
01:11:27,120 --> 01:11:37,120
但如果你有好的資源，也許我們能夠提供幫助。或許可以在未來的某個時候。

662
01:11:37,120 --> 01:11:46,120
在我們的程式中，我們順道一提，我們使用（手動）簽名在主模組中。

663
01:11:46,120 --> 01:11:56,120
那真的很有趣，你將項目中的簽名實體保持加密。

664
01:11:56,120 --> 01:12:19,120
我見過許多團隊苦苦掙扎於如何把證書和資料檔案都放在同一機器上、同一CI機器上，他們設置了超級複雜的配置，而只需要將它們保留在檔案中居然就那麼便利。

665
01:12:19,120 --> 01:12:26,120
也不需要任何第三方工具，使之變得簡單。

666
01:12:26,120 --> 01:12:31,120
但對於更進階的情況，你也可以使用Fastlane。有一些工具在那裡可以用。

667
01:12:31,120 --> 01:12:43,120
如果你需要一個更進階的場景並且你有一個比較大的團隊，需要管理共享證書，Fastlane非常好用。

668
01:12:43,120 --> 01:12:52,120
當它出錯的時候也非常好用。祝你好運。

669
01:12:52,120 --> 01:12:55,120
關於AppCode的問題。

670
01:12:55,120 --> 01:13:02,120
那是給Mike的。

671
01:13:02,120 --> 01:13:05,120
你推薦這個嗎，Mike？

672
01:13:05,120 --> 01:13:11,120
我很長時間沒有使用它。實際上，我根本沒有在Swift中使用過它。

673
01:13:11,120 --> 01:13:17,120
我記得你一開始就是它的狂熱粉絲。哦，其實是在Objective-C中的Swift之前。

674
01:13:17,120 --> 01:13:22,120
它與Objective-C相互配合得很好。

675
01:13:22,120 --> 01:13:38,120
是的，我不使用它，我更喜歡默認的工具，因為你可以得到更多的支持，更多的文檔，你知道，當事情出問題的時候有更多的幫助。找到支持並解決問題會更容易。

676
01:13:38,120 --> 01:13:41,120
所以用新工具是有成本的。

677
01:13:41,120 --> 01:13:50,120
對。再說一次，特別是如果是一個大團隊，你知道，可能不行。只選擇最低成本，且最低成本預設就是最好的。

678
01:13:50,120 --> 01:14:01,120
因為想像一下，訓練團隊中的每一個人，再加上每一個加入團隊的人，你還需要訓練他們使用這個工具，最有可能的是，你聘請的人都不知道如何使用它。

679
01:14:01,120 --> 01:14:03,120
對。

680
01:14:03,120 --> 01:14:08,120
所以除非有大大的好處，否則我不會這麼做。

681
01:14:08,120 --> 01:14:13,120
但它可以像這樣做。團隊中的任何人都可以選擇他們覺得最有效的工具。

682
01:14:13,120 --> 01:14:20,120
所以人們可能更習慣使用AppCode，就讓他們使用AppCode。只要它不妨礙他人。為何不用呢？

683
01:14:20,120 --> 01:14:23,120
對，那是我們的情況，順帶一提。

684
01:14:23,120 --> 01:14:27,120
對，Mike在用AppCode，我在用Xcode。

685
01:14:27,120 --> 01:14:32,120
每個人都很開心。

686
01:14:32,120 --> 01:14:40,120
用vi作為他們的Swift編輯器的人，隨便。

687
01:14:40,120 --> 01:14:42,120
好的。

688
01:14:42,120 --> 01:14:48,120
有沒有什麼技巧？我們正在使用一個舊的Xcode並支持最新的iOS。

689
01:14:48,120 --> 01:14:53,120
有一個技巧，但它並不總是有效。

690
01:14:53,120 --> 01:15:09,120
我知道的技巧是進入Xcode平台並在該設備支持文件夾中創建，如創建一個符號連接

691
01:15:09,120 --> 01:15:23,120
就像用最新的iOS版本名稱到你擁有的前一個。因為在某些版本之間，調試符號非常相似。所以你會能夠啟動調試器。

692
01:15:23,120 --> 01:15:29,120
那並不總是能行得通，可能會導致一些未定義的錯誤。

693
01:15:29,120 --> 01:15:45,120
因此，如我所說的，我真的建議你考慮升級你的設備以及你的開發機器設定，並在實際操作前先考慮這些。

694
01:15:45,120 --> 01:15:54,120
這樣你就有一個計畫了。技巧只有部分有效。

695
01:15:54,120 --> 01:15:56,120
好的。

696
01:15:56,120 --> 01:16:00,120
感謝各位拿出這麼晚的時間。

697
01:16:00,120 --> 01:16:27,120
非常棒。謝謝你。