1
00:00:01.033 --> 00:00:04.066
Hello Mike, hey Caio in this lecture

2
00:00:04.066 --> 00:00:06.000
you'll learn how to create and separate

3
00:00:06.000 --> 00:00:07.200
integration tests

4
00:00:07.200 --> 00:00:09.666
from the unit or also known isolated

5
00:00:09.666 --> 00:00:10.466
tests

6
00:00:10.466 --> 00:00:12.866
the goal is to keep the isolated tests

7
00:00:12.866 --> 00:00:13.733
as fast

8
00:00:13.733 --> 00:00:15.733
as possible as they are the primary

9
00:00:15.733 --> 00:00:17.100
feedback mechanism

10
00:00:17.100 --> 00:00:19.166
for developing our applications you

11
00:00:19.166 --> 00:00:20.633
should be able to run those isolated

12
00:00:20.633 --> 00:00:21.166
tests

13
00:00:21.166 --> 00:00:23.266
several times a day without affecting

14
00:00:23.266 --> 00:00:24.633
your productivity

15
00:00:24.633 --> 00:00:27.266
we recommend you to run them on every

16
00:00:27.266 --> 00:00:28.700
tiny code change

17
00:00:28.700 --> 00:00:30.133
as we've been demonstrating in this

18
00:00:30.133 --> 00:00:32.533
course, isolated tests

19
00:00:32.533 --> 00:00:35.500
give us fast and continuous feedback and

20
00:00:35.500 --> 00:00:36.933
also confidence

21
00:00:36.933 --> 00:00:39.500
that our components work as intended

22
00:00:39.500 --> 00:00:40.233
throughout

23
00:00:40.233 --> 00:00:43.200
the development cycle on the other hand

24
00:00:43.200 --> 00:00:44.533
integration tests

25
00:00:44.533 --> 00:00:46.800
give us confidence that our isolated

26
00:00:46.800 --> 00:00:47.833
components

27
00:00:47.833 --> 00:00:50.533
work well when collaborating together

28
00:00:50.533 --> 00:00:52.000
with no mocks

29
00:00:52.000 --> 00:00:54.700
or any other type of test doubles

30
00:00:54.700 --> 00:00:55.333
however

31
00:00:55.333 --> 00:00:57.900
integration tests can be slow when

32
00:00:57.900 --> 00:00:59.500
making API requests

33
00:00:59.500 --> 00:01:01.600
or interacting with databases or the

34
00:01:01.600 --> 00:01:03.433
File system for example

35
00:01:03.433 --> 00:01:05.566
so we don't run integration tests as

36
00:01:05.566 --> 00:01:06.933
often as the unit

37
00:01:06.933 --> 00:01:10.000
or isolated tests but we do run them

38
00:01:10.000 --> 00:01:10.700
often

39
00:01:10.700 --> 00:01:13.333
and of course as part of our continuous

40
00:01:13.333 --> 00:01:14.933
integration pipeline

41
00:01:14.933 --> 00:01:18.000
exactly code should only be merged to

42
00:01:18.000 --> 00:01:19.033
the master branch

43
00:01:19.033 --> 00:01:22.066
if all integration and isolated tests

44
00:01:22.066 --> 00:01:24.466
pass and all those checks should be

45
00:01:24.466 --> 00:01:25.266
automated

46
00:01:25.266 --> 00:01:27.600
to speed up the team collaboration and

47
00:01:27.600 --> 00:01:29.500
avoid bottlenecks

48
00:01:29.500 --> 00:01:31.433
so let's start by creating a new test

49
00:01:31.433 --> 00:01:33.266
target for our cache

50
00:01:33.266 --> 00:01:35.900
integration tests let's name it

51
00:01:35.900 --> 00:01:37.100
EssentialFeed

52
00:01:37.100 --> 00:01:42.300
CacheIntegrationTests

53
00:01:42.300 --> 00:01:44.633
and let's configure the cache

54
00:01:44.633 --> 00:01:46.000
integration tests

55
00:01:46.000 --> 00:01:50.000
scheme

56
00:01:50.000 --> 00:01:52.300
as always we randomize the execution

57
00:01:52.300 --> 00:01:53.100
order

58
00:01:53.100 --> 00:01:54.633
to guarantee there is no dependency

59
00:01:54.633 --> 00:01:57.900
between tests or the order of execution

60
00:01:57.900 --> 00:02:02.133
exactly let's also gather coverage

61
00:02:02.133 --> 00:02:04.233
for the target we are interested the

62
00:02:04.233 --> 00:02:07.266
EssentialFeed

63
00:02:07.266 --> 00:02:09.566
as you can see we now have a new folder

64
00:02:09.566 --> 00:02:11.666
for the integration tests

65
00:02:11.666 --> 00:02:13.900
with an XCTestCase subclass where we

66
00:02:13.900 --> 00:02:16.400
can start adding our integration tests

67
00:02:16.400 --> 00:02:18.400
the idea is to integrate all the cache

68
00:02:18.400 --> 00:02:19.666
model objects

69
00:02:19.666 --> 00:02:22.133
and see how they behave in collaboration

70
00:02:22.133 --> 00:02:22.700
or

71
00:02:22.700 --> 00:02:25.566
in integration exactly so far we've been

72
00:02:25.566 --> 00:02:27.033
testing them in isolation

73
00:02:27.033 --> 00:02:29.266
by using test doubles but now it's time

74
00:02:29.266 --> 00:02:30.633
to see how they behave

75
00:02:30.633 --> 00:02:33.500
when collaborating with real instances

76
00:02:33.500 --> 00:02:34.866
of the production types

77
00:02:34.866 --> 00:02:37.666
awesome and the EssentialFeedAPI

78
00:02:37.666 --> 00:02:38.700
EndToEndTests

79
00:02:38.700 --> 00:02:41.500
that we created in a previous lecture is

80
00:02:41.500 --> 00:02:42.000
also

81
00:02:42.000 --> 00:02:43.900
an integration test target as it

82
00:02:43.900 --> 00:02:46.533
communicates with multiple modules

83
00:02:46.533 --> 00:02:49.666
and even with the Feed API backend

84
00:02:49.666 --> 00:02:52.866
external service we could add the

85
00:02:52.866 --> 00:02:54.300
cache integration tests

86
00:02:54.300 --> 00:02:57.566
in the API end-to-end tests or even

87
00:02:57.566 --> 00:02:58.533
merge them

88
00:02:58.533 --> 00:03:01.566
in a new integration test target, we

89
00:03:01.566 --> 00:03:02.466
could

90
00:03:02.466 --> 00:03:05.266
however we prefer to keep the API and

91
00:03:05.266 --> 00:03:07.033
the Cache module integration test

92
00:03:07.033 --> 00:03:09.333
separate as they are meant to solve

93
00:03:09.333 --> 00:03:10.633
different problems

94
00:03:10.633 --> 00:03:13.433
and integrate distinct components and

95
00:03:13.433 --> 00:03:14.533
services

96
00:03:14.533 --> 00:03:18.133
exactly so let's run the tests make sure

97
00:03:18.133 --> 00:03:19.433
everything's fine

98
00:03:19.433 --> 00:03:21.733
and let's commit alright it builds

99
00:03:21.733 --> 00:03:23.566
successfully the test is passing even

100
00:03:23.566 --> 00:03:24.700
though we have

101
00:03:24.700 --> 00:03:27.033
no tests but it means we have a clean

102
00:03:27.033 --> 00:03:27.900
target

103
00:03:27.900 --> 00:03:31.733
we can start working on exactly

104
00:03:31.733 --> 00:03:34.000
add EssentialFeedCacheIntegration

105
00:03:34.000 --> 00:03:34.766
Tests

106
00:03:34.766 --> 00:03:36.933
target to separate the potentially

107
00:03:36.933 --> 00:03:39.266
slower cache integration tests

108
00:03:39.266 --> 00:03:42.533
from the fast unit or isolated tests

109
00:03:42.533 --> 00:03:45.433
yeah that's it okay let's start with the

110
00:03:45.433 --> 00:03:46.633
simplest task we can

111
00:03:46.633 --> 00:03:48.933
think of and for me it's just trying to

112
00:03:48.933 --> 00:03:51.100
load from an empty cache

113
00:03:51.100 --> 00:03:53.833
sounds good so we need to create our

114
00:03:53.833 --> 00:03:55.833
LocalFeedLoader which is the system

115
00:03:55.833 --> 00:03:57.266
under test

116
00:03:57.266 --> 00:04:00.066
and perform a load operation and expect

117
00:04:00.066 --> 00:04:01.333
to receive a success

118
00:04:01.333 --> 00:04:04.766
result with an empty array of images

119
00:04:04.766 --> 00:04:06.700
if we get a failure we're going to fail

120
00:04:06.700 --> 00:04:09.333
the tests with a nice error message

121
00:04:09.333 --> 00:04:11.900
yep of course now we need to import the

122
00:04:11.900 --> 00:04:12.866
EssentialFeed

123
00:04:12.866 --> 00:04:18.133
module and we need the makeSUT helper

124
00:04:18.133 --> 00:04:19.733
okay so the system under test is the

125
00:04:19.733 --> 00:04:22.000
LocalFeedLoader in collaboration with

126
00:04:22.000 --> 00:04:22.866
a CoreData

127
00:04:22.866 --> 00:04:25.666
FeedStore the big difference from the

128
00:04:25.666 --> 00:04:27.100
cache integration test

129
00:04:27.100 --> 00:04:30.000
and the Core Data isolated tests is that

130
00:04:30.000 --> 00:04:31.033
now we are using

131
00:04:31.033 --> 00:04:34.633
a real File system URL to save

132
00:04:34.633 --> 00:04:38.000
our Core Data models exactly and that's

133
00:04:38.000 --> 00:04:40.300
instead of the /dev/null that we used in

134
00:04:40.300 --> 00:04:42.300
the CoreDataFeedStore that would

135
00:04:42.300 --> 00:04:43.666
operate in memory

136
00:04:43.666 --> 00:04:45.733
yes because in this case we want to hit

137
00:04:45.733 --> 00:04:46.800
the disk

138
00:04:46.800 --> 00:04:49.500
we want to validate that we are actually

139
00:04:49.500 --> 00:04:50.300
creating

140
00:04:50.300 --> 00:04:53.600
artifacts, state, exactly

141
00:04:53.600 --> 00:04:55.500
we are going all the way from the high

142
00:04:55.500 --> 00:04:56.933
level abstraction

143
00:04:56.933 --> 00:04:59.833
down to the most concrete infrastructure

144
00:04:59.833 --> 00:05:00.700
details

145
00:05:00.700 --> 00:05:02.800
and validating the whole chain works

146
00:05:02.800 --> 00:05:04.800
together awesome

147
00:05:04.800 --> 00:05:06.700
but we have some build errors there the

148
00:05:06.700 --> 00:05:08.700
track for memory leaks

149
00:05:08.700 --> 00:05:11.333
is not visible in this target no because

150
00:05:11.333 --> 00:05:13.900
it's in a separate target

151
00:05:13.900 --> 00:05:16.133
we can add this file to the integration

152
00:05:16.133 --> 00:05:17.433
test target

153
00:05:17.433 --> 00:05:19.600
just like we did with the API end-to-end

154
00:05:19.600 --> 00:05:22.300
tests as well

155
00:05:22.300 --> 00:05:26.066
that should do it let's run the tests

156
00:05:26.066 --> 00:05:27.733
passing but I would like to see a

157
00:05:27.733 --> 00:05:29.100
failing test

158
00:05:29.100 --> 00:05:30.700
so we can change the implementation of

159
00:05:30.700 --> 00:05:32.533
the CoreDataFeedStore

160
00:05:32.533 --> 00:05:35.333
to complete with an error for example

161
00:05:35.333 --> 00:05:37.166
just to force an unexpected behavior

162
00:05:37.166 --> 00:05:39.433
that should generate a failing test

163
00:05:39.433 --> 00:05:40.866
there we have it

164
00:05:40.866 --> 00:05:43.433
it works proving that our test is

165
00:05:43.433 --> 00:05:44.300
testing something

166
00:05:44.300 --> 00:05:47.500
awesome let's undo this change run the

167
00:05:47.500 --> 00:05:49.500
test again

168
00:05:49.500 --> 00:05:53.433
it's passing fantastic let's commit

169
00:05:53.433 --> 00:05:55.500
but we've done two things here one we

170
00:05:55.500 --> 00:05:56.633
added this test

171
00:05:56.633 --> 00:05:58.633
and two we included the memory leak

172
00:05:58.633 --> 00:06:00.866
helper in the integration test target

173
00:06:00.866 --> 00:06:02.233
so I would like to break these into two

174
00:06:02.233 --> 00:06:04.066
commits yeah I like that

175
00:06:04.066 --> 00:06:06.000
first we commit just the memory leak

176
00:06:06.000 --> 00:06:07.500
target membership change

177
00:06:07.500 --> 00:06:09.666
so include memory leak tracking helper

178
00:06:09.666 --> 00:06:12.000
in the cache integration test target

179
00:06:12.000 --> 00:06:15.033
and now we can commit the test so Local

180
00:06:15.033 --> 00:06:15.733
FeedLoader

181
00:06:15.733 --> 00:06:17.500
in integration with the CoreDataFeed

182
00:06:17.500 --> 00:06:19.666
Store delivers no items

183
00:06:19.666 --> 00:06:22.866
on empty cache excellent and I like how

184
00:06:22.866 --> 00:06:24.300
we include in the message

185
00:06:24.300 --> 00:06:26.933
both components that collaborate the

186
00:06:26.933 --> 00:06:28.066
LocalFeedLoader

187
00:06:28.066 --> 00:06:29.733
which collaborates with the CoreData

188
00:06:29.733 --> 00:06:31.900
FeedStore so we're not testing just the

189
00:06:31.900 --> 00:06:32.700
behavior

190
00:06:32.700 --> 00:06:34.400
but we want to make sure that we're

191
00:06:34.400 --> 00:06:36.400
talking about specific components
談論特定的組件

192
00:06:36.400 --> 00:06:39.433
integrating with each other exactly
準確地與其他組件整合

193
00:06:39.433 --> 00:06:42.633
okay second test what happens if we have
好，第二個測試，如果我們有

194
00:06:42.633 --> 00:06:43.900
something cached
一些已緩存的東西

195
00:06:43.900 --> 00:06:46.466
so we have artifacts in disk right we
因此我們在磁盤上有產品，對，我們

196
00:06:46.466 --> 00:06:49.266
should be able to load the items
應該能夠載入這些項目

197
00:06:49.266 --> 00:06:52.633
so the load method should deliver items
因此，加載方法應該能交付保存在

198
00:06:52.633 --> 00:06:55.333
saved on separate instances proving that
分開實例的項目，證明我們正在將事物儲存在磁盤上

199
00:06:55.333 --> 00:06:57.266
we are storing things to disk
另一個實例可以從磁盤上獲取該數據

200
00:06:57.266 --> 00:06:59.166
and another instance can fetch that data
並且另一個實例可以獲取這些數據

201
00:06:59.166 --> 00:07:01.033
from disk which also proves
從磁盤上，這也證明，

202
00:07:01.033 --> 00:07:03.500
that we are storing data across
我們正在跨應用程式執行存儲數據

203
00:07:03.500 --> 00:07:04.866
application runs
確實，所以這很重要，因為

204
00:07:04.866 --> 00:07:07.166
exactly so this is important because
這裡，我們創建了兩個分開的

205
00:07:07.166 --> 00:07:09.033
here we're creating two separate
系統測試的實例，一個

206
00:07:09.033 --> 00:07:12.066
instances of the system under test one
專門用於每一次操作，儲存與

207
00:07:12.066 --> 00:07:14.800
specific for each operation saving and
載入的特定實例

208
00:07:14.800 --> 00:07:15.500
loading
裝載

209
00:07:15.500 --> 00:07:18.233
we don't have this in the unit test yes
我們在單元測試中沒有這個

210
00:07:18.233 --> 00:07:18.700
the Core
那個Core

211
00:07:18.700 --> 00:07:21.733
Data unit tests uses an in-memory
資料單元測試使用內存中的

212
00:07:21.733 --> 00:07:23.566
representation of the data
數據表示法

213
00:07:23.566 --> 00:07:26.533
so having two instances would generate
因此，有兩個實例將生成

214
00:07:26.533 --> 00:07:27.733
two separate
兩個分開的

215
00:07:27.733 --> 00:07:31.033
memory spaces completely isolated now in
記憶空間，完全隔離。現在在

216
00:07:31.033 --> 00:07:33.100
integration we can actually save data to
集成中，我們實際上可以將數據保存到

217
00:07:33.100 --> 00:07:33.733
disk
磁盤上

218
00:07:33.733 --> 00:07:35.566
and use another instance to fetch it
並使用另一個實例來提取它

219
00:07:35.566 --> 00:07:37.900
proving that the whole caching dance
證明整個緩存過程

220
00:07:37.900 --> 00:07:40.933
works accordingly, exactly, so to run this
工作正常，確切地說，所以運行這個

221
00:07:40.933 --> 00:07:41.566
test
測試

222
00:07:41.566 --> 00:07:44.400
we have an sut instance to perform the
我們有一個sut實例來執行

223
00:07:44.400 --> 00:07:46.700
save and want to perform the load
儲存並希望進行載入

224
00:07:46.700 --> 00:07:48.633
first we save and we wait for the save
首先我們儲存並等待儲存

225
00:07:48.633 --> 00:07:50.700
to finish then we load
完成然後我們載入

226
00:07:50.700 --> 00:07:52.633
and we check that we got exactly the
然後我們檢查我們是否得到了具有

227
00:07:52.633 --> 00:07:53.733
same feed we saved
與我們儲存的完全相同的飼料

228
00:07:53.733 --> 00:07:56.000
with the other instance but we are using
使用另一個實例，但我們使用

229
00:07:56.000 --> 00:07:56.800
the helper
輔助者

230
00:07:56.800 --> 00:08:00.000
there is also in a separate target so we
也在單獨的目標中，所以我們

231
00:08:00.000 --> 00:08:01.733
also need to add this Feed Cache test
還需要添加這個 Feed Cache 測試

232
00:08:01.733 --> 00:08:02.466
helpers
輔助者

233
00:08:02.466 --> 00:08:04.300
to the Feed Cache integration tests
至 Feed Cache 集成測試

234
00:08:04.300 --> 00:08:06.233
target
目標

235
00:08:06.233 --> 00:08:09.166
but this file uses a symbol that lives
但這個檔案使用一個在

236
00:08:09.166 --> 00:08:10.400
in another file
其他檔案中的符號

237
00:08:10.400 --> 00:08:12.066
so we also need to include the shared
所以我們也需要將共享

238
00:08:12.066 --> 00:08:14.133
test helpers to the integration test
測試輔助者包含至集成測試

239
00:08:14.133 --> 00:08:16.000
target
目標

240
00:08:16.000 --> 00:08:19.833
run test again it's passing fantastic
再次運行測試，通過了，太好了

241
00:08:19.833 --> 00:08:22.800
and again we can first commit the target
再次，我們可以首先提交目標

242
00:08:22.800 --> 00:08:24.066
membership change
會員資格變更

243
00:08:24.066 --> 00:08:26.933
and then commit the test so include
然後提交測試，所以包含

244
00:08:26.933 --> 00:08:28.400
cache test helpers

245
00:08:28.400 --> 00:08:30.800
in the cache integration tests target
在快取整合測試目標中

246
00:08:30.800 --> 00:08:32.466
that's it
就是這樣

247
00:08:32.466 --> 00:08:36.000
let's run the test again oh
讓我們再次執行測試，哦

248
00:08:36.000 --> 00:08:39.333
failing test okay the first test failed
失敗的測試，好的，第一個測試失敗了

249
00:08:39.333 --> 00:08:42.066
and why is that, artifacts, we are leaving
為什麼呢，產品，我們正在離開

250
00:08:42.066 --> 00:08:43.333
Core Data artifacts
Core Data產品

251
00:08:43.333 --> 00:08:46.133
to disk so it affects the first test and
存到磁碟，所以它影響了第一個測試並且

252
00:08:46.133 --> 00:08:47.200
since they run
由於他們執行

253
00:08:47.200 --> 00:08:49.433
in random order sometimes the second
的順序是隨機的，有時第二個

254
00:08:49.433 --> 00:08:51.733
test runs first sometimes it runs after
測試先執行，有時它是後來執行的

255
00:08:51.733 --> 00:08:53.600
so it's a bit unpredictable
所以有點不可預測

256
00:08:53.600 --> 00:08:56.533
okay so we need to clean the state for
好的，所以我們需要在每個

257
00:08:56.533 --> 00:08:57.600
each test run
測試執行中清理狀態

258
00:08:57.600 --> 00:08:59.266
and we can do that with the setUp and
我們可以使用setUp和

259
00:08:59.266 --> 00:09:00.633
tearDown methods
tearDown方法來做到這一點

260
00:09:00.633 --> 00:09:02.700
as we've done before in the setUp we set
就像我們之前在setUp中設定

261
00:09:02.700 --> 00:09:03.733
up an empty store
一個空的存儲

262
00:09:03.733 --> 00:09:06.133
in the tearDown we undo the store side
在tearDown中我們撤消存儲的這邊

263
00:09:06.133 --> 00:09:07.266
effects
影響

264
00:09:07.266 --> 00:09:10.700
so let's add the test helpers simply
所以讓我們簡單地添加測試助手

265
00:09:10.700 --> 00:09:13.333
removing the file from disk let's run
從磁盤上刪除檔案，然後再次執行

266
00:09:13.333 --> 00:09:14.933
again
再次執行

267
00:09:14.933 --> 00:09:17.200
it's passing let's run again just to
它通過了，我們再執行一次就能

268
00:09:17.200 --> 00:09:18.800
make sure it's still passing
確保它仍然通過

269
00:09:18.800 --> 00:09:22.633
okay run a couple of times it is passing
好的，跑了幾次後，它已通過

270
00:09:22.633 --> 00:09:24.300
but again we've done two things here we
但再一次，我們在這裡做了兩件事

271
00:09:24.300 --> 00:09:26.233
added the side-effects cleanup
我們添加了副作用清理

272
00:09:26.233 --> 00:09:28.000
and also the tests so we can break this
還有測試，所以我們可以將此

273
00:09:28.000 --> 00:09:29.833
down into two commits as well
分為兩個提交

274
00:09:29.833 --> 00:09:31.666
I would like to point out that we are
我想指出的是，我們正在

275
00:09:31.666 --> 00:09:33.833
seeing an emerging pattern here
看到一種新的模式

276
00:09:33.833 --> 00:09:36.066
we are forced to do two or more things
我們被迫做兩件或更多事情

277
00:09:36.066 --> 00:09:37.733
because of all the collaboration
這是因為所有的協作

278
00:09:37.733 --> 00:09:39.833
going on with all the components that we
與我們使用的所有組件的交互

279
00:09:39.833 --> 00:09:40.866
use
是的

280
00:09:40.866 --> 00:09:43.666
exactly when we isolate components we
確切地說，當我們隔離組件時，我們

281
00:09:43.666 --> 00:09:45.733
have a cost of integrating them
也需要付出整合它們的成本

282
00:09:45.733 --> 00:09:47.600
and if we don't manage this well we can
如果我們管理不當就會

283
00:09:47.600 --> 00:09:49.033
create a mess in the codebase
在代碼庫中創建混亂

284
00:09:49.033 --> 00:09:52.000
yes so let's first commit the store side
是的，所以讓我們先提交存儲副作用

285
00:09:52.000 --> 00:09:52.633
effects
的清理

286
00:09:52.633 --> 00:09:54.800
cleanup and then we complete the test
然後我們完成測試

287
00:09:54.800 --> 00:09:55.833
sounds good
聽起來很好

288
00:09:55.833 --> 00:09:58.633
so clean up and undo all cache side
所以清理並撤銷所有緩存側

289
00:09:58.633 --> 00:09:59.333
effects
效應

290
00:09:59.333 --> 00:10:01.900
on setUp and tearDown to avoid sharing
在setUp和tearDown時避免共享

291
00:10:01.900 --> 00:10:02.700
state
狀態

292
00:10:02.700 --> 00:10:05.833
between tests
在測試之間

293
00:10:05.833 --> 00:10:08.533
now we can commit the tests so LocalFeed

294
00:10:08.533 --> 00:10:10.700
Loader in integration with the Core Data
Loader 結合了 Core Data

295
00:10:10.700 --> 00:10:11.433
FeedStore
FeedStore

296
00:10:11.433 --> 00:10:13.733
delivers items saved on separate
儲存在分開的

297
00:10:13.733 --> 00:10:14.700
instances
實例中的項目

298
00:10:14.700 --> 00:10:16.933
proving we correctly persist the data
證明我們正確地將數據

299
00:10:16.933 --> 00:10:18.300
models to disk
模型持久化到磁盤上

300
00:10:18.300 --> 00:10:21.200
that's it and again I really like how we
就是這樣，再次我真的很喜歡我們如何

301
00:10:21.200 --> 00:10:22.800
mentioned the LocalFeedLoader
提到了 LocalFeedLoader

302
00:10:22.800 --> 00:10:24.366
in integration with the CoreDataFeed
與 CoreDataFeed

303
00:10:24.366 --> 00:10:26.866
Store and we have some duplication
Store 結合使用，我們已經有了一些重複的

304
00:10:26.866 --> 00:10:30.466
already with the load method so ideally
使用load 方法，所以理想情況下

305
00:10:30.466 --> 00:10:31.666
we should have an expect
我們應該有一個expect

306
00:10:31.666 --> 00:10:34.066
method that can be reused like we've
方法可以像我們

307
00:10:34.066 --> 00:10:35.600
done in other lectures
在其他講座中做的那樣重複使用

308
00:10:35.600 --> 00:10:38.533
like expect the sut to load an empty
比如預期sut載入一個空的

309
00:10:38.533 --> 00:10:40.233
array of images
圖像陣列

310
00:10:40.233 --> 00:10:42.300
exactly despite these being integration
儘管這些是集成測試

311
00:10:42.300 --> 00:10:43.900
tests the refactoring rules
重構規則依舊適用在這

312
00:10:43.900 --> 00:10:46.700
of course apply here as well, exactly we
我們應該把同樣的心血和用心

313
00:10:46.700 --> 00:10:48.533
should have the same level of care
投入在這裡，完全不同我們

314
00:10:48.533 --> 00:10:51.033
regardless if they are integration tests
應該在集成測試中

315
00:10:51.033 --> 00:10:51.833
unit tests
單元測試

316
00:10:51.833 --> 00:10:54.133
isolated tests or production code they
孤立測試或是生產代碼上

317
00:10:54.133 --> 00:10:55.833
are all code we have to maintain
我們都需要進行維護的代碼

318
00:10:55.833 --> 00:10:58.133
and we should keep high standards on the
我們應該對整個

319
00:10:58.133 --> 00:10:59.266
whole codebase
代碼庫保持高標準

320
00:10:59.266 --> 00:11:02.066
absolutely so this other load operation
絕對如此，這個其他的加載操作

321
00:11:02.066 --> 00:11:03.900
should be replaced with the expect
應該用 expect

322
00:11:03.900 --> 00:11:06.700
sut to perform the load to load the
替換為sut來執行負載，以載入

323
00:11:06.700 --> 00:11:07.200
saved
已保存的

324
00:11:07.200 --> 00:11:10.800
feed now we can add the helper
feed，現在我們可以添加助手

325
00:11:10.800 --> 00:11:13.833
as always with nice assertions and
一如既往的進行良好的斷言和

326
00:11:13.833 --> 00:11:15.100
passing the file and line
傳遞檔案與行數

327
00:11:15.100 --> 00:11:16.933
so we can see failures in the right
所以我們可以在正確的

328
00:11:16.933 --> 00:11:20.300
place let's run the tests
位置看到失敗，讓我們運行測試

329
00:11:20.300 --> 00:11:23.433
passing let's commit extract
通過，讓我們提交提取

330
00:11:23.433 --> 00:11:26.633
duplicate load expectations into a
將重複的加載預期轉移至

331
00:11:26.633 --> 00:11:29.266
shared helper method
共享助手方法中

332
00:11:29.266 --> 00:11:31.266
so we proved we can load from an empty
所以我們證明了我們可以從空的

333
00:11:31.266 --> 00:11:33.200
cache we proved we can load
快取中加載，我們證明我們可以從

334
00:11:33.200 --> 00:11:35.200
from a non empty cache even when
一個非空的快取中加載，即使是

335
00:11:35.200 --> 00:11:37.200
created by a separate instance
由單獨的實例創建的

336
00:11:37.200 --> 00:11:39.433
the last test we need is to prove that
我們需要的最後一項測試是證明我們可以

337
00:11:39.433 --> 00:11:40.700
we can override
覆蓋

338
00:11:40.700 --> 00:11:43.733
the items and disk that were saved by a
由單獨的實例保存的磁盤中的項目

339
00:11:43.733 --> 00:11:45.333
separate instance
單獨的實例

340
00:11:45.333 --> 00:11:48.366
and again we have multiple system under
再次，我們在這裡多次測試系統

341
00:11:48.366 --> 00:11:49.833
test instances here
每一個實例都是為特定的操作而設

342
00:11:49.833 --> 00:11:53.033
each one for each specific operation so
每一個具體操作都有一個測試的實例

343
00:11:53.033 --> 00:11:55.833
an sut to perform the first save another

344
00:11:55.833 --> 00:11:57.200
one to perform the last save
進行最後一次儲存的一個

345
00:11:57.200 --> 00:11:58.800
and another one to perform the load so
還有一個進行加載的

346
00:11:58.800 --> 00:12:00.233
we have three objects
所以我們有三個物件

347
00:12:00.233 --> 00:12:02.233
interacting with the File system here
在這裡與文件系統互動

348
00:12:02.233 --> 00:12:03.600
and two models to save
且兩個模型要儲存

349
00:12:03.600 --> 00:12:05.433
the first and the latest and they are
第一個和最新的且它們是

350
00:12:05.433 --> 00:12:07.500
unique exactly if you compare them
精確地說如果你比較它們

351
00:12:07.500 --> 00:12:10.133
they are different so again we want to
它們是不一樣的所以再次我們希望

352
00:12:10.133 --> 00:12:11.033
guarantee
保證

353
00:12:11.033 --> 00:12:12.933
the collaboration of the components
元件之間的協作

354
00:12:12.933 --> 00:12:14.233
within the whole stack
在整個堆疊中

355
00:12:14.233 --> 00:12:17.333
exactly so first we save with the
確實如此，我們首先用

356
00:12:17.333 --> 00:12:20.133
sut to perform the first save then we
sut 來進行第一次儲存，然後我們

357
00:12:20.133 --> 00:12:20.866
save
儲存

358
00:12:20.866 --> 00:12:23.333
another feed with the sut to perform the
另一個 feed 並用 sut 來進行

359
00:12:23.333 --> 00:12:24.233
last save
最後一次儲存

360
00:12:24.233 --> 00:12:27.200
and then we expect to load the latest
然後我們預期加載最新的

361
00:12:27.200 --> 00:12:27.500
one
一個

362
00:12:27.500 --> 00:12:29.200
not the first one or not empty the
不是第一個或不是空的，而是

363
00:12:29.200 --> 00:12:31.200
latest one
最新的一個

364
00:12:31.200 --> 00:12:34.466
let's run the tests passing
讓我們跑過測試

365
00:12:34.466 --> 00:12:37.600
awesome let's commit
太棒了，讓我們提交

366
00:12:37.600 --> 00:12:39.666
so the LocalFeedLoader in integration
所以 LocalFeedLoader 與 CoreDataFeedStore

367
00:12:39.666 --> 00:12:41.433
with the CoreDataFeedStore
的整合

368
00:12:41.433 --> 00:12:44.233
overrides the items saved by separate
會覆寫由單獨

369
00:12:44.233 --> 00:12:45.033
instances
例項儲存的項目

370
00:12:45.033 --> 00:12:47.200
proving we correctly manage the data
證明我們正確管理資料

371
00:12:47.200 --> 00:12:48.700
models on disk
在磁盤上的模型

372
00:12:48.700 --> 00:12:50.933
that's it now that we have all this
就是這樣，現在我們有了所有這些

373
00:12:50.933 --> 00:12:52.300
duplicate save
重複保存

374
00:12:52.300 --> 00:12:55.266
methods yeah we could also extract them
的方法，是的，我們也可以將它們提取出來

375
00:12:55.266 --> 00:12:57.100
into helpers
成為輔助器

376
00:12:57.100 --> 00:13:00.700
save feed with the sut to perform save
用sut儲存feed，進行保存

377
00:13:00.700 --> 00:13:02.466
that sounds wonderful and in this other
那聽起來很棒，而且在這個別的

378
00:13:02.466 --> 00:13:04.000
test we could have the
測試中，我們也可以有

379
00:13:04.000 --> 00:13:06.133
save the first feed with the sut to
使用sut保存第一個feed，

380
00:13:06.133 --> 00:13:07.666
perform the first save
進行第一次保存

381
00:13:07.666 --> 00:13:11.100
and save the latest feed with the sut to
並且保存最新的feed與sut，

382
00:13:11.100 --> 00:13:12.066
perform
進行

383
00:13:12.066 --> 00:13:14.000
the last save that would be much easier
最後一次保存，那將會容易得多

384
00:13:14.000 --> 00:13:15.833
to read and maintain
閱讀和維護

385
00:13:15.833 --> 00:13:18.800
definitely so here it is the helper we
絕對的，所以這就是我們

386
00:13:18.800 --> 00:13:20.366
created the expectation
創建預期的助手

387
00:13:20.366 --> 00:13:23.266
we save the feed with the given loader
我們用給定的加載器保存feed

388
00:13:23.266 --> 00:13:24.133
and we wait
然後我們等待

389
00:13:24.133 --> 00:13:27.333
until the save operation has finished
直到保存操作完成

390
00:13:27.333 --> 00:13:30.533
let's run the tests it's passing ok
讓我們運行測試，好的，它通過了

391
00:13:30.533 --> 00:13:33.600
let's commit so extract
我們來提交，所以，提取

392
00:13:33.600 --> 00:13:36.466
duplicate save operation into a shared
重複的保存操作變成共享

393
00:13:36.466 --> 00:13:38.633
helper method
助手方法

394
00:13:38.633 --> 00:13:41.600
okay we are done with integration tests
好的，我們完成了整合測試

395
00:13:41.600 --> 00:13:42.933
it seems that we have touched only the
看起來我們只接觸了

396
00:13:42.933 --> 00:13:43.666
happy path

397
00:13:43.666 --> 00:13:46.300
what about the error cases well we are
那麼錯誤的情況呢，好的，我們正在

398
00:13:46.300 --> 00:13:46.866
testing
進行測試

399
00:13:46.866 --> 00:13:49.100
all possible scenarios on a component
在單元

400
00:13:49.100 --> 00:13:50.633
level in the unit
或獨立測試裡對組件進行所有可能情境的檢驗

401
00:13:50.633 --> 00:13:53.900
or isolated tests otherwise
否則的話

402
00:13:53.900 --> 00:13:56.233
if we were to test all edge cases in
如果我們把所有邊際情況都放在

403
00:13:56.233 --> 00:13:57.333
integration tests
整合測試裡面去檢驗

404
00:13:57.333 --> 00:13:59.266
the number of cases would grow
會造成測試案例數量

405
00:13:59.266 --> 00:14:00.466
exponentially
成指數性的增長

406
00:14:00.466 --> 00:14:02.066
depending on the number of components
這取決於組件的數量

407
00:14:02.066 --> 00:14:03.833
that participate in the integration
參與了整合的組件數量愈多

408
00:14:03.833 --> 00:14:04.233
right
對吧

409
00:14:04.233 --> 00:14:06.533
the more components the more tests the
組件數量越多，測試與邊際情況就越多

410
00:14:06.533 --> 00:14:07.733
more edge cases
但若在單元裡測試邊際情況，當你把它們組合起來時

411
00:14:07.733 --> 00:14:10.700
but if you test edge cases in the unit
你只需要測試快樂路線，對吧

412
00:14:10.700 --> 00:14:12.300
when you compose them together
舉例來說，我不能在整合層級強制產生錯誤，但是我

413
00:14:12.300 --> 00:14:15.166
you can test only the happy path right
可以在單元層級模擬錯誤，我們已經

414
00:14:15.166 --> 00:14:17.033
for example I cannot force
這樣做過了。例如，在整合階段中我無法強制

415
00:14:17.033 --> 00:14:19.333
an error at the integration level but I
產生錯誤，但我可以在單元層級模擬

416
00:14:19.333 --> 00:14:20.300
can mock
錯誤，而我們已經

417
00:14:20.300 --> 00:14:23.500
an error in the unit level and we have
進行過這樣的操作。精確地說，在整合階段我們

418
00:14:23.500 --> 00:14:24.466
done it
並不使用

419
00:14:24.466 --> 00:14:27.100
exactly here on the integration level we
任何模擬或測試替身，我們使用的是

420
00:14:27.100 --> 00:14:28.000
are not using
真實的

421
00:14:28.000 --> 00:14:30.633
any mocks or test doubles we're using
組件，並且，如果你把所有的

422
00:14:30.633 --> 00:14:31.033
real
測試

423
00:14:31.033 --> 00:14:34.533
components yes and if you move all your
全部移至整合級別，這將

424
00:14:34.533 --> 00:14:35.433
tests
會導致你的

425
00:14:35.433 --> 00:14:37.333
to the integration level that would
測試範圍過於龐大

426
00:14:37.333 --> 00:14:39.900
result in an unmaintainable number of
導致無法維護的測試數量

427
00:14:39.900 --> 00:14:43.266
tests and very slow test times yes
和非常慢的測試時間 是的

428
00:14:43.266 --> 00:14:46.066
we do not recommend that definitely not
我們絕對不建議這種情況

429
00:14:46.066 --> 00:14:47.500
and there are other problems
並且還有其他的問題

430
00:14:47.500 --> 00:14:49.900
in testing only in the integration level
在僅在整合級別進行測試時

431
00:14:49.900 --> 00:14:51.600
for example when there is a failure
例如，當出現失敗時

432
00:14:51.600 --> 00:14:53.666
you have to debug to find out where is
你必須進行調試以找出問題在哪裡

433
00:14:53.666 --> 00:14:55.600
the problem you don't know exactly which
你並不確知哪一個

434
00:14:55.600 --> 00:14:56.633
component
組件

435
00:14:56.633 --> 00:14:59.033
is misbehaving right so it's not a
是在行為不正確，所以這並不是一個

436
00:14:59.033 --> 00:14:59.900
matter of
問題

437
00:14:59.900 --> 00:15:02.366
should I do only unit tests or should I
我應該只做單元測試還是我應該

438
00:15:02.366 --> 00:15:04.233
do only integration tests
只做整合測試

439
00:15:04.233 --> 00:15:06.000
you probably need both but the huge
你可能兩者都需要，但是絕大部分應該是單元測試

440
00:15:06.000 --> 00:15:07.900
majority should be unit tests
所有的邊緣案例都在那裡然後

441
00:15:07.900 --> 00:15:09.666
that's all the edge cases there then
整合所有的組件

442
00:15:09.666 --> 00:15:11.033
integrate all the components
並看看他們一起的行為

443
00:15:11.033 --> 00:15:12.633
and see how they behave together that
這將給你足夠的信心來

444
00:15:12.633 --> 00:15:14.700
will give you enough confidence to move
快速行動，我們希望能快速行動，絕對的。

445
00:15:14.700 --> 00:15:18.366
fast and we want to move fast absolutely

446
00:15:18.366 --> 00:15:21.600
so again we are not mocking anything in
所以再說一遍，我們在

447
00:15:21.600 --> 00:15:22.633
these tests
這些測試中並未模擬任何事情

448
00:15:22.633 --> 00:15:24.533
we've already proved the components work
我們已經證明了組件是可以運作的

449
00:15:24.533 --> 00:15:27.100
in isolation so using mocks here
在孤立中，所以在這裡使用mocks

450
00:15:27.100 --> 00:15:29.833
won't have much value another thing we
並沒有太大的價值，我們還有

451
00:15:29.833 --> 00:15:30.933
can do here
其他的作法

452
00:15:30.933 --> 00:15:33.666
is to just replace the CoreDataFeed
就是直接將CoreDataFeed

453
00:15:33.666 --> 00:15:35.266
Store with the Codable
Store替換成Codable

454
00:15:35.266 --> 00:15:39.433
FeedStore and it should also work
FeedStore，這樣也應該可以運作

455
00:15:39.433 --> 00:15:43.333
let's run the tests boom they pass
讓我們運行測試，成功了

456
00:15:43.333 --> 00:15:45.600
this is amazing and this is possible
這真的太神奇了，而這是可行的 

457
00:15:45.600 --> 00:15:47.433
because of the application of powerful
因為我們應用了強大的

458
00:15:47.433 --> 00:15:48.366
principles
原則

459
00:15:48.366 --> 00:15:51.433
like Dependency Inversion, the Liskov
如依賴反轉、Liskov

460
00:15:51.433 --> 00:15:52.700
Substitution Principle
替換原則，

461
00:15:52.700 --> 00:15:54.800
the Interface Segregation Principle
接口分離原則，

462
00:15:54.800 --> 00:15:56.300
Dependency Injection
依賴注入，

463
00:15:56.300 --> 00:15:58.300
and every other principle we have
以及我們所學過的所有原則

464
00:15:58.300 --> 00:16:00.066
studied so far basically
基本上就是這樣

465
00:16:00.066 --> 00:16:02.366
exactly so we have two implementations
因此我們有兩個實作

466
00:16:02.366 --> 00:16:03.100
that behave
行為

467
00:16:03.100 --> 00:16:05.833
exactly the same even though they use
完全相同，即使他們使用

468
00:16:05.833 --> 00:16:07.266
completely different
完全不同

469
00:16:07.266 --> 00:16:10.466
frameworks behind the scenes but
的框架，但由於

470
00:16:10.466 --> 00:16:12.300
since we have those two FeedStore
我們有兩個FeedStore

471
00:16:12.300 --> 00:16:13.600
implementations
實作，

472
00:16:13.600 --> 00:16:15.333
and we just need one for this
而我們只需要一個用於此

473
00:16:15.333 --> 00:16:17.600
application I think we can get rid of
應用程式，我想我們可以去掉

474
00:16:17.600 --> 00:16:18.466
one of them
其中一個

475
00:16:18.466 --> 00:16:20.000
and I believe we should keep the Core
我認為我們應該保留 Core

476
00:16:20.000 --> 00:16:22.300
Data one since it's a more

477
00:16:22.300 --> 00:16:25.733
robust solution yeah I agree exploring
強大的解決方案，是的，我同意探索

478
00:16:25.733 --> 00:16:26.466
Core Data
Core Data

479
00:16:26.466 --> 00:16:28.466
in future lectures will be much more
在未來的課程中將更有

480
00:16:28.466 --> 00:16:29.900
valuable so
價值，所以

481
00:16:29.900 --> 00:16:31.433
we can discard the CodableFeedStore
我們可以放棄CodableFeedStore

482
00:16:31.433 --> 00:16:33.033
for now
暫且如此

483
00:16:33.033 --> 00:16:34.700
okay I'm removing the production and
好的，我將移除生產和

484
00:16:34.700 --> 00:16:36.066
test code
測試代碼

485
00:16:36.066 --> 00:16:37.733
for the CodableFeedStore
關於CodableFeedStore的

486
00:16:37.733 --> 00:16:39.833
implementation and of course if we want
實現，當然，如果我們想要

487
00:16:39.833 --> 00:16:41.666
to bring back the CodableFeedStore we
將CodableFeedStore帶回來，我們

488
00:16:41.666 --> 00:16:43.833
can do so easily as it will always be in
可以輕易做到，因為它會永遠在

489
00:16:43.833 --> 00:16:45.733
the git history of our repository
我們倉庫的git歷史中

490
00:16:45.733 --> 00:16:49.333
let's run the tests passing let's also
讓我們運行測試，通過，讓我們也

491
00:16:49.333 --> 00:16:50.066
run
運行

492
00:16:50.066 --> 00:16:53.666
the EssentialFeedTests fantastic
EssentialFeedTests，太好了

493
00:16:53.666 --> 00:16:57.266
all good let's commit delete the Codable
一切順利，讓我們提交刪除 Codable

494
00:16:57.266 --> 00:16:58.233
FeedStore
FeedStore

495
00:16:58.233 --> 00:17:00.800
in favor of the CoreDataFeedStore we
選擇CoreDataFeedStore，我們

496
00:17:00.800 --> 00:17:02.700
just need one in this project
只需要一個在這個項目中

497
00:17:02.700 --> 00:17:05.033
if needed of course we can revert this
如果需要的話，我們可以撤銷這個

498
00:17:05.033 --> 00:17:06.533
commit and restore
提交以及恢復

499
00:17:06.533 --> 00:17:10.133
the Codable implementation okay
Codable實現，好的

500
00:17:10.133 --> 00:17:11.733
as a final change I would like to
最後的修改，我想要

501
00:17:11.733 --> 00:17:15.500
configure the CI scheme
配置CI方案

502
00:17:15.500 --> 00:17:18.400
to include the new cache integration
要包括新的cache integration

503
00:17:18.400 --> 00:17:21.333
tests
測試

504
00:17:21.333 --> 00:17:24.300
and of course execute the tests in
並且當然要執行

505
00:17:24.300 --> 00:17:26.700
random order
隨機順序的測試

506
00:17:26.700 --> 00:17:29.833
okay let's run the tests in the CI
好的，讓我們在 CI 中執行這些測試

507
00:17:29.833 --> 00:17:30.400
scheme
方案

508
00:17:30.400 --> 00:17:33.666
that should run for all the targets
這應該要針對所有的目標進行

509
00:17:33.666 --> 00:17:37.500
passing excellent let's commit
驗證成功，讓我們提交

510
00:17:37.500 --> 00:17:39.666
so include the cache integration tests
所以包括cache integration tests

511
00:17:39.666 --> 00:17:40.533
target
目標

512
00:17:40.533 --> 00:17:43.100
in the CI scheme to guarantee we build
在 CI 方案中要確保我們建立

513
00:17:43.100 --> 00:17:43.833
and run
並執行

514
00:17:43.833 --> 00:17:46.400
all cache integration tests as part of
所有的cache integration tests 作為

515
00:17:46.400 --> 00:17:49.333
the continuous integration pipeline
持續整合流程的一部分

516
00:17:49.333 --> 00:17:52.133
and we are all set okay let's have a
一切都準備好了，好的，讓我們看看

517
00:17:52.133 --> 00:17:53.100
look at the logs
日誌

518
00:17:53.100 --> 00:17:55.900
for test times as you can see the unit
對於測試時間，如你所見，單元

519
00:17:55.900 --> 00:17:57.200
tests
測試

520
00:17:57.200 --> 00:18:00.533
55 tests took 0.5 seconds to run
55個測試只花了0.5秒來執行

521
00:18:00.533 --> 00:18:04.233
the API end-to-end tests took 2.6
API 端對端測試花了2.6

522
00:18:04.233 --> 00:18:07.266
seconds to run 1 test right and the
秒來執行1個測試，對於

523
00:18:07.266 --> 00:18:08.633
cache integration tests
cache integration tests

524
00:18:08.633 --> 00:18:10.466
that goes all the way storing the Core
完全儲存到 Core

525
00:18:10.466 --> 00:18:12.400
Data artifacts to disk
Data 的文件中

526
00:18:12.400 --> 00:18:16.233
took 0.3 seconds for 3 tests
3個測試用了0.3秒

527
00:18:16.233 --> 00:18:18.066
so you can see how this would not scale
所以你可以看到這樣是無法擴展的

528
00:18:18.066 --> 00:18:20.400
yeah the more integration tests we add
對，我們添加的集成測試越多

529
00:18:20.400 --> 00:18:22.866
the slower your development process will
你的開發進程就會越慢

530
00:18:22.866 --> 00:18:23.733
be
會變慢

531
00:18:23.733 --> 00:18:26.766
exactly when you see these numbers you
確實，當你看到這些數字時，你

532
00:18:26.766 --> 00:18:28.766
need to think about the future
需要去思考未來

533
00:18:28.766 --> 00:18:31.900
clearly 0.5 seconds or 0.3 seconds
顯然，0.5秒或0.3秒

534
00:18:31.900 --> 00:18:34.066
doesn't seem a lot right now but as you
現在看起來不算多，但是你

535
00:18:34.066 --> 00:18:35.266
said can this
說過，這能

536
00:18:35.266 --> 00:18:38.133
scale and the answer is no clearly it
擴展嗎？答案顯然是不能

537
00:18:38.133 --> 00:18:38.700
can't
不能

538
00:18:38.700 --> 00:18:41.433
in large projects, no it will become a
在大型項目中，不，它將成為一個

539
00:18:41.433 --> 00:18:42.466
bottleneck
瓶頸

540
00:18:42.466 --> 00:18:45.100
yes and then most probably developers
對，然後開發人員最可能

541
00:18:45.100 --> 00:18:45.600
will stop
會停止

542
00:18:45.600 --> 00:18:48.000
running the tests we don't want that no
執行測試，我們不希望這樣，不

543
00:18:48.000 --> 00:18:49.500
we want the unit tests to be part of the
我們希望單元測試成為工作流程的一部分

544
00:18:49.500 --> 00:18:50.133
workflow
工作流程的一部分

545
00:18:50.133 --> 00:18:52.233
we want to run them several times a
我們希望每分鐘執行它們好幾次

546
00:18:52.233 --> 00:18:53.900
minute we want it to take
我們希望不管有多少測試

547
00:18:53.900 --> 00:18:56.233
seconds regardless of how many tests you
我們希望它只需要

548
00:18:56.233 --> 00:18:57.666
have exactly
幾秒鐘，確實

549
00:18:57.666 --> 00:18:59.900
as the tests start becoming a bottleneck
當測試開始成為瓶頸時

550
00:18:59.900 --> 00:19:02.000
we need to find ways to speed it up
我們需要找到加快的方法

551
00:19:02.000 --> 00:19:04.133
proactivity is the word we're looking
我們在尋找的詞匯是積極性

552
00:19:04.133 --> 00:19:05.200
for here
在這裡

553
00:19:05.200 --> 00:19:06.766
so separating integration tests from
所以分離整合測試與

554
00:19:06.766 --> 00:19:09.100
unit tests may be mandatory
單元測試可能是必須的

555
00:19:09.100 --> 00:19:11.433
as you grow your application and your
當你擴大應用程序和你的

556
00:19:11.433 --> 00:19:12.633
development team
開發團隊時

557
00:19:12.633 --> 00:19:14.766
that's it for this lecture remember to
這次講座到此結束，記住要

558
00:19:14.766 --> 00:19:16.700
separate integration tests from the unit
將整合測試從單元

559
00:19:16.700 --> 00:19:18.233
or isolated tests
或孤立的測試中分離出來

560
00:19:18.233 --> 00:19:20.766
when there is a performance impact on
當對你的生產力造成影響時

561
00:19:20.766 --> 00:19:22.066
your productivity
也要持續度量建造和測試

562
00:19:22.066 --> 00:19:24.766
also continuously measure build and test
時間以避免瓶頸

563
00:19:24.766 --> 00:19:26.400
times to avoid bottlenecks
在開發流程中，我們完成了Persistence

564
00:19:26.400 --> 00:19:28.533
in the development process and we are
模塊很棒，我們將在

565
00:19:28.533 --> 00:19:30.066
done with the Persistence
下一堂講座見到大家

566
00:19:30.066 --> 00:19:32.700
module awesome we'll see you all in the
非常感謝，我們在

567
00:19:32.700 --> 00:19:33.666
next lecture
下次講座見

568
00:19:33.666 --> 00:19:45.833
bye y'all, see ya
再見，我們下次見