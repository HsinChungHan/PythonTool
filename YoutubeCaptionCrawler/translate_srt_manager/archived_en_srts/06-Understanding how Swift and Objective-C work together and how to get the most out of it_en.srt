
1
00:00:01.000 --> 00:00:04.840
Hi everyone, and welcome back to our tooling series.

2
00:00:05.720 --> 00:00:08.720
Today we'll explore another cool topic

3
00:00:08.720 --> 00:00:13.520
which is mixing Objective-C and Swift together.

4
00:00:13.520 --> 00:00:16.200
This is important because many projects out there

5
00:00:16.200 --> 00:00:18.960
still contain a mix of Swift and Objective-C.

6
00:00:19.800 --> 00:00:23.100
And even those Swift only projects

7
00:00:23.100 --> 00:00:24.640
use the system frameworks

8
00:00:24.640 --> 00:00:27.360
which are mostly written in Objective-C.

9
00:00:27.360 --> 00:00:32.140
So to become a complete senior iOS developer,

10
00:00:32.140 --> 00:00:33.580
it's really important to know

11
00:00:33.580 --> 00:00:35.960
how to mix together the two languages

12
00:00:35.960 --> 00:00:37.780
and how to get the most out of it.

13
00:00:40.460 --> 00:00:44.940
Our plan for today is to understand how Clang

14
00:00:44.940 --> 00:00:49.420
or C-Lang and the Swift compiler work to find declarations

15
00:00:51.060 --> 00:00:53.860
and how to mix Swift and Objective-C code

16
00:00:53.860 --> 00:00:55.460
in different setups.

17
00:00:55.460 --> 00:01:00.460
See how we can make our Objective-C APIs more Swifty,

18
00:01:01.500 --> 00:01:03.300
if that's an accepted word.

19
00:01:04.980 --> 00:01:08.100
And take a look at a common problem,

20
00:01:08.100 --> 00:01:10.620
how we can write Swift code

21
00:01:10.620 --> 00:01:12.860
that uses all the language features

22
00:01:12.860 --> 00:01:15.440
if we need to expose this code to Objective-C.

23
00:01:16.420 --> 00:01:18.860
We'll give you a solution on how to approach this.

24
00:01:20.740 --> 00:01:23.180
And as always, we'll wrap it up with the Q&A,

25
00:01:23.180 --> 00:01:26.780
but if there are questions during the lecture,

26
00:01:26.780 --> 00:01:30.160
I'll try to respond to them as they come.

27
00:01:32.260 --> 00:01:34.840
A quick recap from our previous lecture

28
00:01:34.840 --> 00:01:36.120
about the build system.

29
00:01:37.140 --> 00:01:40.020
We know that Apple ships two different compilers

30
00:01:40.020 --> 00:01:41.260
embedded in Xcode.

31
00:01:42.340 --> 00:01:47.340
C-Lang or Clang is the compiler for the C-based languages

32
00:01:47.340 --> 00:01:51.420
like C, C++, Objective-C, Objective-C++.

33
00:01:51.420 --> 00:01:54.620
The Swift compiler is compiling Swift code.

34
00:01:56.740 --> 00:01:59.700
So an important part of how the build system works

35
00:01:59.700 --> 00:02:02.960
is influenced by how the two compilers work together.

36
00:02:04.860 --> 00:02:08.660
Clang compiles each Objective-C File separately.

37
00:02:10.860 --> 00:02:13.860
If you want to refer to a class from another File,

38
00:02:13.860 --> 00:02:18.660
you have to import a header that declares that class.

39
00:02:18.660 --> 00:02:21.900
We'll dive into how these header File works

40
00:02:21.900 --> 00:02:23.040
in a few minutes,

41
00:02:24.540 --> 00:02:27.040
but I think you can recognize the syntax.

42
00:02:30.480 --> 00:02:34.920
By comparison, Swift used to compile each File separate,

43
00:02:35.880 --> 00:02:38.320
but after several improvements Apple made

44
00:02:38.320 --> 00:02:39.940
to the build system,

45
00:02:39.940 --> 00:02:43.240
the Swift compiler can now compile multiple File at once.

46
00:02:44.300 --> 00:02:47.280
This is not as important as the fact that Swift

47
00:02:47.280 --> 00:02:49.460
was designed not to require headers.

48
00:02:50.320 --> 00:02:53.540
This is because headers are repetitive and hard to manage.

49
00:02:54.360 --> 00:02:57.100
Having no headers makes it easy to get started

50
00:02:57.100 --> 00:03:00.640
with the language and avoids repeating declarations.

51
00:03:02.680 --> 00:03:05.800
However, this means that the Swift compiler

52
00:03:05.800 --> 00:03:08.100
has to perform some additional bookkeeping.

53
00:03:11.380 --> 00:03:15.340
So let's use our EssentialFeed use case repo as always,

54
00:03:15.340 --> 00:03:18.660
and see how the compilers resolve declarations

55
00:03:18.660 --> 00:03:21.960
in different scenarios and how that booking View works.

56
00:03:25.860 --> 00:03:29.900
The EssentialFeed repo has no Objective-C code,

57
00:03:29.900 --> 00:03:30.980
but we'll add some.

58
00:03:31.820 --> 00:03:35.980
I'll start by creating an Objective-C class called Logger

59
00:03:35.980 --> 00:03:38.660
and added it into the EssentialFeed project.

60
00:03:40.200 --> 00:03:43.140
So I will right click the EssentialFeed group,

61
00:03:43.140 --> 00:03:47.180
set new File,

62
00:03:47.180 --> 00:03:50.420
and let's spend a few seconds here

63
00:03:50.420 --> 00:03:52.100
looking at the File templates.

64
00:03:54.740 --> 00:03:59.740
There's an Objective-C File template for implementations

65
00:04:00.840 --> 00:04:03.440
and a header File template for headers.

66
00:04:04.820 --> 00:04:09.300
Since no Objective-C relies on combining header files.h

67
00:04:09.300 --> 00:04:11.940
and implementation files.m,

68
00:04:11.940 --> 00:04:14.500
these templates would be enough.

69
00:04:14.500 --> 00:04:18.380
But there's also the CocoaTouch class template,

70
00:04:18.380 --> 00:04:22.660
which is a helper creating both a header

71
00:04:22.660 --> 00:04:25.660
and an implementation File at the same time.

72
00:04:25.660 --> 00:04:28.220
Let's use this one for convenience.

73
00:04:28.220 --> 00:04:29.540
So I'll double click it.

74
00:04:30.620 --> 00:04:33.780
I'll type the name of my class, which will be Logger.

75
00:04:34.660 --> 00:04:36.940
We'll use Objective-C as our language.

76
00:04:36.940 --> 00:04:41.940
And we'll put it at the root folder.

77
00:04:46.220 --> 00:04:51.220
We can immediately notice some interesting instructions

78
00:04:51.220 --> 00:04:53.860
like this nsassume non-node.

79
00:04:53.860 --> 00:04:55.840
For now, I will just remove those

80
00:04:55.840 --> 00:04:57.820
and we'll talk about them later

81
00:04:57.820 --> 00:05:00.860
because we want to really explain what they do.

82
00:05:02.540 --> 00:05:06.520
So now we have a simple interface Logger

83
00:05:06.520 --> 00:05:10.580
that inherits from NSObject and its implementation File,

84
00:05:10.580 --> 00:05:11.480
both empty.

85
00:05:12.820 --> 00:05:15.700
So how does Objective-C find declarations

86
00:05:15.700 --> 00:05:18.500
from other Objective-C files?

87
00:05:18.500 --> 00:05:22.840
Well, by using headers and importing them.

88
00:05:24.200 --> 00:05:28.040
Anyone using Objective-C is pretty familiar with this.

89
00:05:28.040 --> 00:05:30.620
It's those import statements at the beginning

90
00:05:30.620 --> 00:05:34.380
of the.h or.m Objective-C files.

91
00:05:34.380 --> 00:05:39.380
Header files are a concept that Objective-C

92
00:05:40.820 --> 00:05:43.500
borrowed from C and C++.

93
00:05:43.500 --> 00:05:45.620
What's important to know is the headers

94
00:05:45.620 --> 00:05:48.140
must contain the declarations we want to expose

95
00:05:48.140 --> 00:05:49.620
to other files.

96
00:05:49.620 --> 00:05:53.380
Or put it another way, if we want to expose any entity

97
00:05:53.380 --> 00:05:55.480
to another File or another module,

98
00:05:55.480 --> 00:05:57.180
we need to declare it in a header.

99
00:05:58.820 --> 00:06:02.700
And by entities, of course we mean classes, protocols,

100
00:06:02.700 --> 00:06:07.400
global functions, global variables, enums, and many more.

101
00:06:10.260 --> 00:06:13.420
So the declaration of an entity contains

102
00:06:13.420 --> 00:06:16.400
like a high level signature of that entity

103
00:06:16.400 --> 00:06:18.940
without any concrete implementation.

104
00:06:20.660 --> 00:06:22.400
Let's see this difference.

105
00:06:23.820 --> 00:06:28.820
I'll add a method to myLogger class called log.

106
00:06:28.820 --> 00:06:31.420
It's a simple method that returns Void

107
00:06:31.420 --> 00:06:34.420
and takes a String Message parameter.

108
00:06:36.700 --> 00:06:40.700
First, we see the declaration of the Logger class

109
00:06:40.700 --> 00:06:45.700
marked with add interface and the mention of a subclass

110
00:06:47.220 --> 00:06:49.100
from any subject.

111
00:06:49.100 --> 00:06:53.100
And also another declaration of the log Message.

112
00:06:53.100 --> 00:06:58.100
It just contains the signature, but not the body.

113
00:06:59.500 --> 00:07:04.500
Now let's add the implementation of this Objective-C File.

114
00:07:07.420 --> 00:07:12.420
I added implementation for our log Message method,

115
00:07:12.420 --> 00:07:15.860
we added in the header, but I also added

116
00:07:15.860 --> 00:07:19.380
a private function called private log.

117
00:07:19.380 --> 00:07:24.380
Internally, our public method calls the private one.

118
00:07:25.500 --> 00:07:27.820
What I wanted to highlight here is,

119
00:07:27.820 --> 00:07:31.140
one, this time the definition of the Logger class

120
00:07:31.140 --> 00:07:36.140
marked with add implementation is present in the.mp File.

121
00:07:36.860 --> 00:07:41.860
Then the body of the log function is the definition

122
00:07:41.860 --> 00:07:46.780
in the.mp File, and that we can only use the.mp File

123
00:07:46.780 --> 00:07:51.780
and that we can also add other signatures

124
00:07:53.140 --> 00:07:57.900
and their definitions like this private log Message

125
00:07:57.900 --> 00:08:01.620
that we don't need to expose to other files.

126
00:08:03.140 --> 00:08:04.660
Back to our header File.

127
00:08:07.620 --> 00:08:10.260
It's a best practice to keep the header File

128
00:08:10.260 --> 00:08:12.220
as short as possible.

129
00:08:12.220 --> 00:08:15.620
So make sure to only include the declarations

130
00:08:15.620 --> 00:08:18.780
of entities like classes, methods, protocols

131
00:08:18.780 --> 00:08:22.780
that are needed to be shared with other files.

132
00:08:24.380 --> 00:08:26.580
You can still add their definitions

133
00:08:26.580 --> 00:08:28.980
to the.mp File like we did.

134
00:08:30.500 --> 00:08:33.700
Also for headers, it's recommended to keep

135
00:08:33.700 --> 00:08:38.260
the minimum needed imports in each header.

136
00:08:38.260 --> 00:08:42.980
Keeping the imports limited helps the compiler

137
00:08:42.980 --> 00:08:45.700
easily resolve these imports and the resulting code

138
00:08:45.700 --> 00:08:48.460
will be minimal, the code size will be minimal.

139
00:08:52.220 --> 00:08:55.780
We can define more entities inside our.mp implementation

140
00:08:55.780 --> 00:09:00.780
File without exposing any of them to other files.

141
00:09:01.100 --> 00:09:05.260
So I'll replace this implementation we have now

142
00:09:06.540 --> 00:09:08.420
with a more complex one.

143
00:09:08.420 --> 00:09:13.420
So I added a Logger type enum with two cases,

144
00:09:13.940 --> 00:09:15.220
console and File.

145
00:09:16.100 --> 00:09:21.100
I added a, let's call it a private class Logger helper

146
00:09:21.420 --> 00:09:24.820
which is NotVisible outside the.mp File

147
00:09:24.820 --> 00:09:27.820
that has a class method clean logs.

148
00:09:29.580 --> 00:09:33.380
And to make this clear, we're actually calling

149
00:09:33.380 --> 00:09:37.100
the clean logs from the dialog of our Logger.

150
00:09:37.100 --> 00:09:41.180
So whenever we dialog our Logger, we clean the logs.

151
00:09:43.020 --> 00:09:46.420
Again, all these new entities are available

152
00:09:46.420 --> 00:09:50.060
inside my.mp File, but they're not exposed.

153
00:09:50.060 --> 00:09:51.940
They don't belong to any header.

154
00:09:53.980 --> 00:09:56.420
Now we mentioned this term importing headers

155
00:09:56.420 --> 00:09:58.780
and I wanna clarify what this means.

156
00:10:01.900 --> 00:10:06.620
The hash import is a macro and is very similar

157
00:10:06.620 --> 00:10:10.860
to another macro from C, C++, which is include.

158
00:10:10.860 --> 00:10:12.820
They actually are pretty similar.

159
00:10:13.820 --> 00:10:16.340
You'll simply get replaced by the pre-compiler

160
00:10:16.340 --> 00:10:20.540
with that exact full content of the header File

161
00:10:20.540 --> 00:10:24.100
they point to, like a copy and paste.

162
00:10:26.140 --> 00:10:29.020
So since this happens to all the macros

163
00:10:29.020 --> 00:10:31.180
and it's a recursive process,

164
00:10:31.180 --> 00:10:33.540
it can lead to really big files

165
00:10:33.540 --> 00:10:37.060
and of course, potential duplication of symbols.

166
00:10:38.900 --> 00:10:40.980
To make this more clear,

167
00:10:40.980 --> 00:10:44.620
if we go to the Foundation header definition,

168
00:10:44.620 --> 00:10:49.620
you'll see it actually imports like 170 other header files,

169
00:10:51.060 --> 00:10:52.660
all of them with big bodies.

170
00:10:52.660 --> 00:10:57.140
So you can imagine the size of the simple Logger header

171
00:10:57.140 --> 00:10:59.820
when these macros are expanded.

172
00:10:59.820 --> 00:11:04.820
So between the two, the import macro is a bit more advanced

173
00:11:06.220 --> 00:11:08.620
as it was added for Objective-C

174
00:11:08.620 --> 00:11:11.660
and it avoids duplicating the declarations

175
00:11:11.660 --> 00:11:14.620
if the same files are imported multiple times.

176
00:11:15.500 --> 00:11:17.180
If you have an Objective-C project,

177
00:11:17.180 --> 00:11:21.540
you probably import Foundation or UI key many, many times,

178
00:11:21.540 --> 00:11:23.460
but they still work.

179
00:11:23.460 --> 00:11:26.700
So you don't get like duplicate symbols Error

180
00:11:26.700 --> 00:11:30.220
because of that, which includes in C,

181
00:11:30.220 --> 00:11:32.180
we have to be more careful,

182
00:11:32.180 --> 00:11:33.580
which I'll show you in a second

183
00:11:33.580 --> 00:11:37.020
because the Xcode header File template

184
00:11:37.020 --> 00:11:39.220
contains these instructions.

185
00:11:40.740 --> 00:11:43.500
So during time Objective-C has evolved

186
00:11:43.500 --> 00:11:46.580
and Apple added a new way to do imports.

187
00:11:46.580 --> 00:11:48.820
They are called semantic imports

188
00:11:48.820 --> 00:11:53.820
and they kind of try to replace the hashtag import.

189
00:11:53.820 --> 00:11:54.660
Hashtag import.

190
00:11:56.020 --> 00:12:00.060
They look like at import in the name of the framework,

191
00:12:03.540 --> 00:12:04.380
like this.

192
00:12:07.380 --> 00:12:11.780
Actually, if your grand enabled module build setting

193
00:12:11.780 --> 00:12:14.860
is set to yes, and it is so by default,

194
00:12:16.340 --> 00:12:21.340
even those hashtag import are replaced by the compiler

195
00:12:21.340 --> 00:12:25.940
with at imports or these semantic imports.

196
00:12:25.940 --> 00:12:29.620
So you get this for free without having to manually convert

197
00:12:29.620 --> 00:12:31.620
all your existing imports.

198
00:12:33.500 --> 00:12:37.620
Since they do the same, I will remove the ladder for now.

199
00:12:43.020 --> 00:12:44.820
Using these semantic imports

200
00:12:44.820 --> 00:12:47.180
is more efficient than regular imports,

201
00:12:47.180 --> 00:12:48.940
resulting in faster builds

202
00:12:48.940 --> 00:12:52.220
and especially avoiding compiling issues.

203
00:12:52.220 --> 00:12:54.500
The builds are faster because the compiler

204
00:12:54.500 --> 00:12:56.220
doesn't need to parse the headers

205
00:12:57.100 --> 00:12:59.580
as it can rely on module maps.

206
00:12:59.580 --> 00:13:02.020
We'll talk about module maps in a few minutes.

207
00:13:04.700 --> 00:13:08.660
You might wonder, how does Xcode find these header files

208
00:13:08.660 --> 00:13:10.020
we mentioned here?

209
00:13:10.020 --> 00:13:13.660
Well, it turns out it has a pretty complex mechanism

210
00:13:13.660 --> 00:13:16.140
for locating header files.

211
00:13:16.140 --> 00:13:21.140
It uses different build settings like header search paths

212
00:13:24.260 --> 00:13:27.740
or user header surf paths and more,

213
00:13:27.740 --> 00:13:29.380
as well as on system paths

214
00:13:29.380 --> 00:13:33.180
where the system frameworks live to search for headers.

215
00:13:35.940 --> 00:13:38.060
When you want to share Objective-C code

216
00:13:38.060 --> 00:13:40.460
from one module to another,

217
00:13:40.460 --> 00:13:42.620
you have to share the binary of that module

218
00:13:42.620 --> 00:13:43.980
as well as the headers.

219
00:13:43.980 --> 00:13:48.220
Without each header, the clients of your module

220
00:13:48.220 --> 00:13:50.900
cannot find the declarations inside your module,

221
00:13:50.900 --> 00:13:52.700
so they cannot use your types.

222
00:13:53.700 --> 00:13:58.500
Sharing the headers happens through a build phase,

223
00:13:58.500 --> 00:14:02.740
which is called headers in the recent Xcode,

224
00:14:02.740 --> 00:14:06.380
or it used to be called copy headers in previous ones.

225
00:14:06.380 --> 00:14:09.940
If we expand it, we see three subcategories,

226
00:14:09.940 --> 00:14:13.260
and these are three levels of visibility

227
00:14:13.260 --> 00:14:17.620
that each header can have, public, private, and project.

228
00:14:17.620 --> 00:14:18.900
And to understand them,

229
00:14:18.900 --> 00:14:22.940
I'll create a header File for each one of them

230
00:14:22.940 --> 00:14:24.300
and see how they perform.

231
00:14:25.340 --> 00:14:29.540
We already noticed that the project tab contains one File,

232
00:14:29.540 --> 00:14:32.740
which is the Logger header, which we just added.

233
00:14:32.740 --> 00:14:34.660
By default, adding any header

234
00:14:34.660 --> 00:14:38.140
willSet the visibility to project level,

235
00:14:38.140 --> 00:14:39.580
and we'll see what that means.

236
00:14:39.580 --> 00:14:44.580
For now, I will right click, new File,

237
00:14:44.580 --> 00:14:46.980
use the header File template,

238
00:14:46.980 --> 00:14:50.460
and my first one, I'll call public.

239
00:14:51.340 --> 00:14:54.420
I'll check the EssentialFeed target and hit create.

240
00:14:56.100 --> 00:14:59.740
If I use the inspector on the right,

241
00:15:01.580 --> 00:15:04.060
in the target membership, we see the target

242
00:15:04.060 --> 00:15:07.700
that we just added the File to, which is EssentialFeed,

243
00:15:07.700 --> 00:15:09.780
and a selector next to it.

244
00:15:09.780 --> 00:15:12.700
This controls the visibility I just mentioned.

245
00:15:13.940 --> 00:15:17.100
So since I created my File, namely public,

246
00:15:17.100 --> 00:15:20.420
I want this File to be public, so I'll select public here.

247
00:15:23.340 --> 00:15:26.020
Just a quick note about this File template.

248
00:15:26.020 --> 00:15:30.380
I mentioned earlier that for C headers,

249
00:15:30.380 --> 00:15:32.980
the include directive does not know

250
00:15:32.980 --> 00:15:35.820
how to avoid duplicating symbols.

251
00:15:35.820 --> 00:15:40.100
So a common practice in C, C++ was to guard everything

252
00:15:40.100 --> 00:15:43.100
inside the wrapper of these instructions.

253
00:15:43.100 --> 00:15:48.100
So if public underscore H is not defined, define it,

254
00:15:48.100 --> 00:15:49.420
and end if.

255
00:15:49.420 --> 00:15:53.620
In the next File that we'll try to import this header,

256
00:15:53.620 --> 00:15:57.860
we'll actually find that public underscore H is defined

257
00:15:57.860 --> 00:15:59.700
and skip.

258
00:15:59.700 --> 00:16:03.580
That's how it avoids duplicating symbols.

259
00:16:03.580 --> 00:16:07.140
So back to our flow, we added a new header File

260
00:16:07.140 --> 00:16:11.580
called public.H, and we set the visibility to public.

261
00:16:11.580 --> 00:16:13.740
Now, if we get back to the build phases,

262
00:16:15.420 --> 00:16:18.620
and let's make this a bit bigger.

263
00:16:18.620 --> 00:16:22.820
I see my public.H File under public headers.

264
00:16:24.220 --> 00:16:28.820
I will build, everything builds fine,

265
00:16:28.820 --> 00:16:33.820
and I'll use the finder on the derived data folder

266
00:16:35.540 --> 00:16:39.740
to inspect my Bundle of the EssentialFeed framework.

267
00:16:39.740 --> 00:16:43.940
And I see there's a new folder called headers.

268
00:16:44.820 --> 00:16:47.420
If I look into this header, for now,

269
00:16:47.420 --> 00:16:51.340
I will only see the public.H File I just created.

270
00:16:51.340 --> 00:16:53.220
Please ignore the EssentialFeed Swift,

271
00:16:53.220 --> 00:16:56.940
as we'll talk about it in a few minutes.

272
00:16:56.940 --> 00:16:57.900
A few minutes.

273
00:17:00.100 --> 00:17:05.100
So my public header.H was added to headers folder.

274
00:17:09.660 --> 00:17:12.780
All the clients that will import the EssentialFeed

275
00:17:12.780 --> 00:17:14.700
will be able to import this header

276
00:17:14.700 --> 00:17:17.460
and use the definitions inside.

277
00:17:17.460 --> 00:17:18.380
So all good.

278
00:17:20.700 --> 00:17:25.700
Let's repeat the exercise with another File, header File,

279
00:17:25.700 --> 00:17:29.140
header File, which we'll call project.

280
00:17:29.140 --> 00:17:31.260
I'll also add it to our EssentialFeed

281
00:17:32.300 --> 00:17:35.860
and check that it's visibility set to project.

282
00:17:35.860 --> 00:17:40.860
I can also see it appear under the project group,

283
00:17:43.020 --> 00:17:44.740
which now contains two files.

284
00:17:47.860 --> 00:17:48.700
If I build

285
00:17:48.700 --> 00:17:53.700
this and go back to my Bundle

286
00:17:55.500 --> 00:17:57.620
of the EssentialFeed framework,

287
00:17:57.620 --> 00:18:02.020
I will not be able to find this header anywhere.

288
00:18:05.540 --> 00:18:08.140
That's because a project header is not included

289
00:18:08.140 --> 00:18:09.660
into the module Bundle.

290
00:18:09.660 --> 00:18:13.500
The interface is for use only by implementation File

291
00:18:13.500 --> 00:18:15.180
in the current project.

292
00:18:15.180 --> 00:18:18.060
So the symbols inside this header are NotVisible

293
00:18:18.060 --> 00:18:19.980
to clients at all, only to you.

294
00:18:25.380 --> 00:18:27.180
The third level

295
00:18:29.580 --> 00:18:32.020
is private.

296
00:18:32.020 --> 00:18:33.140
Let's see how this works.

297
00:18:33.140 --> 00:18:35.500
I'll create a header File called private.

298
00:18:35.500 --> 00:18:38.180
I'll also add it to the EssentialFeed

299
00:18:38.180 --> 00:18:40.260
and this time I will choose

300
00:18:40.260 --> 00:18:42.540
the private target membership level.

301
00:18:42.540 --> 00:18:47.540
And I'll see the new header under private headers.

302
00:18:52.780 --> 00:18:53.620
Building,

303
00:18:55.340 --> 00:18:57.380
we see a new folder appeared,

304
00:18:57.380 --> 00:18:59.140
which is called private headers.

305
00:19:01.500 --> 00:19:04.940
A private header is actually copied into your Bundle,

306
00:19:04.940 --> 00:19:06.820
but instead of the headers folder,

307
00:19:06.820 --> 00:19:08.980
it will go into the private headers folder.

308
00:19:08.980 --> 00:19:12.620
A private header is included in the product,

309
00:19:12.620 --> 00:19:14.420
but it's marked private.

310
00:19:14.420 --> 00:19:17.660
Thus the symbols are visible to all your clients,

311
00:19:17.660 --> 00:19:19.020
but the clients should understand

312
00:19:19.020 --> 00:19:20.620
you're not supposed to use them.

313
00:19:22.380 --> 00:19:25.700
You should always avoid importing private headers

314
00:19:25.700 --> 00:19:27.820
as this can lead to breaking changes

315
00:19:27.820 --> 00:19:30.020
in Future releases of that module.

316
00:19:30.020 --> 00:19:31.460
So you don't want to be coupled

317
00:19:31.460 --> 00:19:39.700
with these implementation details.

318
00:19:39.700 --> 00:19:42.620
Now that we've seen all these potential levels,

319
00:19:43.620 --> 00:19:46.340
it's really important that you express your intent

320
00:19:46.340 --> 00:19:49.260
by properly setting the visibility level

321
00:19:49.260 --> 00:19:51.380
to each header in your target.

322
00:19:51.380 --> 00:19:53.820
So for all the versions of Objective-C,

323
00:19:53.820 --> 00:19:56.740
sharing headers was enough

324
00:19:56.740 --> 00:20:00.100
to distribute libraries or frameworks.

325
00:20:00.100 --> 00:20:03.340
Clients would import exactly the headers they want

326
00:20:03.340 --> 00:20:06.380
from the module and be done.

327
00:20:07.260 --> 00:20:11.060
But Apple has created an improved option

328
00:20:12.900 --> 00:20:16.340
to expose your Objective-C code to other modules,

329
00:20:16.340 --> 00:20:18.060
either Objective-C or Swift.

330
00:20:19.100 --> 00:20:22.460
You can use an umbrella header and a module Map.

331
00:20:22.460 --> 00:20:24.700
You probably heard this before,

332
00:20:24.700 --> 00:20:30.300
let's explain what each of them are and how they work.

333
00:20:32.420 --> 00:20:34.940
The umbrella header is the Main header

334
00:20:34.940 --> 00:20:38.220
for File for a framework.

335
00:20:38.220 --> 00:20:41.060
It's nothing fancy, just a simple header

336
00:20:41.060 --> 00:20:44.500
that shares the same name as the framework name.

337
00:20:44.500 --> 00:20:47.420
So in our example, that would be EssentialFeed.h.

338
00:20:48.860 --> 00:20:53.260
Let's create this header to make it even more clear.

339
00:20:53.260 --> 00:20:58.260
So I'll create a new header, I'll call it EssentialFeed.

340
00:20:58.380 --> 00:21:03.380
I'll include it into my target and hit create.

341
00:21:03.620 --> 00:21:08.020
I will delete these macros as we don't need them.

342
00:21:08.020 --> 00:21:19.020
I will import the EssentialFeed public header

343
00:21:23.460 --> 00:21:24.620
we just created.

344
00:21:28.300 --> 00:21:33.300
And I'll also import myLogger.h and try to build.

345
00:21:33.300 --> 00:21:37.780
Oops, I got an Error, let's see why.

346
00:21:40.140 --> 00:21:43.300
We get this umbrella header EssentialFeed not found.

347
00:21:44.500 --> 00:21:46.740
This is a pretty common build Error.

348
00:21:46.740 --> 00:21:49.500
This happens pretty often too.

349
00:21:49.500 --> 00:21:53.900
I forgot to set my umbrella header as public.

350
00:21:53.900 --> 00:21:55.500
This is really important.

351
00:21:55.500 --> 00:21:58.700
When trying to compile this umbrella header,

352
00:21:58.700 --> 00:22:02.100
Clang tries to import all of these headers

353
00:22:02.100 --> 00:22:03.700
and they all must be public,

354
00:22:04.540 --> 00:22:08.780
but our Logger.h File is not public.

355
00:22:11.660 --> 00:22:13.420
So if we make it public,

356
00:22:15.100 --> 00:22:18.180
and now everything should work, okay.

357
00:22:20.660 --> 00:22:24.460
So to recap, I created an umbrella header

358
00:22:24.460 --> 00:22:29.180
which has the exact name as the target it belongs to,

359
00:22:29.180 --> 00:22:31.580
the framework EssentialFeed.

360
00:22:31.580 --> 00:22:36.060
And I had to make it public and all the imports

361
00:22:36.060 --> 00:22:40.820
of headers inside of it need to use public headers.

362
00:22:42.340 --> 00:22:45.340
This umbrella header is used to import

363
00:22:45.340 --> 00:22:47.500
all the public headers you want to expose.

364
00:22:48.540 --> 00:22:51.500
A common example is Foundation.h.

365
00:22:54.260 --> 00:22:58.540
As you can see, it's actually an umbrella

366
00:22:58.540 --> 00:23:01.780
like the name says for other header files.

367
00:23:03.060 --> 00:23:08.060
But what this does is it allows us to use this type of import

368
00:23:10.900 --> 00:23:14.540
where we say import Foundation, Foundation.h

369
00:23:14.540 --> 00:23:17.860
instead of having to type each type of import

370
00:23:17.860 --> 00:23:22.860
like NSString.h, NSArray.h and so on.

371
00:23:26.860 --> 00:23:28.100
We don't have to do this.

372
00:23:28.100 --> 00:23:32.540
We can just use the umbrella and get all the definitions.

373
00:23:35.140 --> 00:23:40.140
Now, this is how the umbrella header looks like.

374
00:23:41.220 --> 00:23:43.620
We also mentioned module Map.

375
00:23:43.620 --> 00:23:45.260
Let's see what the module Map is.

376
00:23:46.380 --> 00:23:48.460
But the module Map is a text File.

377
00:23:49.500 --> 00:23:51.740
By default, this is generated by Xcode

378
00:23:51.740 --> 00:23:54.500
from the information describing your module

379
00:23:54.500 --> 00:23:56.220
like the umbrella header.

380
00:23:56.220 --> 00:24:00.620
If the define modules option is enabled,

381
00:24:00.620 --> 00:24:01.580
the one we showed.

382
00:24:03.900 --> 00:24:06.260
It basically describes the mapping

383
00:24:06.260 --> 00:24:08.100
between modules and headers.

384
00:24:09.460 --> 00:24:14.460
As an example, I want to look at our essential feeds,

385
00:24:14.500 --> 00:24:15.940
generated module Map.

386
00:24:17.220 --> 00:24:19.980
So to do this, I'll go back to finer

387
00:24:21.380 --> 00:24:26.060
and inside the EssentialFeed framework Bundle,

388
00:24:26.060 --> 00:24:28.380
there's a modules folder

389
00:24:28.380 --> 00:24:30.940
and inside it, there's a module module Map.

390
00:24:30.940 --> 00:24:33.300
This is the File I want to open.

391
00:24:35.140 --> 00:24:36.740
Let's take a look.

392
00:24:36.740 --> 00:24:39.900
First, it defines the framework inside,

393
00:24:39.900 --> 00:24:42.140
which is EssentialFeed.

394
00:24:42.140 --> 00:24:45.220
Then it mentions that the umbrella header

395
00:24:45.220 --> 00:24:48.860
for this framework is EssentialFeed.h.

396
00:24:48.860 --> 00:24:51.780
And after that, there's a couple of exports

397
00:24:51.780 --> 00:24:53.060
and module definitions,

398
00:24:53.060 --> 00:24:56.900
which basically say that all the headers

399
00:24:58.300 --> 00:24:59.860
imported in umbrella header

400
00:24:59.860 --> 00:25:04.340
will end up in a different sub module.

401
00:25:06.340 --> 00:25:09.580
So we can have this granularity we'll see in a second.

402
00:25:13.020 --> 00:25:15.260
Also, there's a separate module

403
00:25:15.260 --> 00:25:18.140
which is called EssentialFeed.Swift,

404
00:25:18.140 --> 00:25:21.220
which contains that File we'll still haven't introduced yet.

405
00:25:21.220 --> 00:25:22.900
So let's ignore it for now.

406
00:25:30.580 --> 00:25:33.780
Sharing the module Map allows you kind to

407
00:25:33.780 --> 00:25:36.020
import specific parts of your module.

408
00:25:37.700 --> 00:25:42.700
And for example, the EssentialFeed.Swift we saw,

409
00:25:42.940 --> 00:25:45.580
or in case of the system frameworks,

410
00:25:45.580 --> 00:25:50.580
we can import sub components of them.

411
00:25:53.420 --> 00:25:58.420
For example, if we could write import Foundation like this,

412
00:25:58.820 --> 00:26:03.820
we can say Foundation.NSString or Foundation.NSArray.

413
00:26:09.060 --> 00:26:12.900
Autocomplete does not work, but you see this works.

414
00:26:12.900 --> 00:26:17.900
Actually, let's reopen the project.

415
00:26:20.580 --> 00:26:25.460
Sometimes Xcode just wants a reboot.

416
00:26:31.260 --> 00:26:33.700
Yeah, this time it works, autocomplete.

417
00:26:34.940 --> 00:26:35.780
Good.

418
00:26:38.780 --> 00:26:40.060
So we talked about headers

419
00:26:40.060 --> 00:26:45.060
and how the system works to find headers, module maps.

420
00:26:46.860 --> 00:26:49.500
I want to introduce another concept,

421
00:26:50.420 --> 00:26:52.300
which is forward declarations.

422
00:26:55.380 --> 00:26:57.500
You can get your project to compile

423
00:26:57.500 --> 00:27:00.380
by using only imports all over the place,

424
00:27:00.380 --> 00:27:02.780
but keep in mind they're pretty inefficient.

425
00:27:05.260 --> 00:27:08.300
If you import large header for referencing

426
00:27:08.300 --> 00:27:11.220
one or two entities inside that File,

427
00:27:11.220 --> 00:27:16.220
or if you're not careful and clean up imports periodically,

428
00:27:16.540 --> 00:27:21.540
they just add up and you have a huge File to compile

429
00:27:24.700 --> 00:27:27.460
even if some of the imports there are not even needed.

430
00:27:28.700 --> 00:27:32.380
Not to mention, you can have cyclic references

431
00:27:32.380 --> 00:27:36.500
in cases where you'd have a header A imports header B

432
00:27:36.500 --> 00:27:38.980
and header B imports header A.

433
00:27:38.980 --> 00:27:41.020
And this is a situation the compiler

434
00:27:41.020 --> 00:27:42.700
just cannot resolve on its own.

435
00:27:44.380 --> 00:27:47.380
So the Clang compiler offers a more effective solution

436
00:27:47.380 --> 00:27:50.620
to referencing entities from other files or modules,

437
00:27:50.620 --> 00:27:53.420
which are forward declarations.

438
00:27:54.420 --> 00:27:57.100
These are basically promises to the compiler

439
00:27:57.100 --> 00:27:59.540
that a cluster Protocol or another entity

440
00:27:59.540 --> 00:28:02.260
will be declared in another File.

441
00:28:04.180 --> 00:28:06.060
And in situations where you only need

442
00:28:06.060 --> 00:28:11.060
to reference an entity and don't care about all the details,

443
00:28:11.300 --> 00:28:15.100
like for instance, you need to pass a Logger instance,

444
00:28:15.100 --> 00:28:16.820
but you don't care about the properties

445
00:28:16.820 --> 00:28:18.980
or methods on that glass,

446
00:28:18.980 --> 00:28:21.740
you can use a forward declaration instead of an import.

447
00:28:25.180 --> 00:28:26.500
To compile each File,

448
00:28:26.500 --> 00:28:30.980
the compiler doesn't need to resolve this forward declarations.

449
00:28:31.820 --> 00:28:35.100
It's enough to know that they will be declared somewhere else.

450
00:28:35.100 --> 00:28:37.820
Finding these files and filling in the right declaration

451
00:28:37.820 --> 00:28:39.180
will be done by the linker

452
00:28:39.180 --> 00:28:40.940
at the end of the compilation process.

453
00:28:40.940 --> 00:28:43.340
Again, something we described in detail

454
00:28:43.340 --> 00:28:45.420
in the Xcode build process lecture.

455
00:28:45.420 --> 00:28:47.900
So you should check that if it doesn't make sense.

456
00:28:50.860 --> 00:28:52.180
Now let's build an example

457
00:28:52.180 --> 00:28:56.380
by creating a new Objective-C class.

458
00:28:57.540 --> 00:28:59.820
This time I'm gonna call it log manager.

459
00:29:00.820 --> 00:29:02.380
It's not gonna be a Singleton,

460
00:29:02.380 --> 00:29:07.380
but again, let's delete the NSAssume instructions

461
00:29:15.660 --> 00:29:18.100
as we haven't said what they are.

462
00:29:21.660 --> 00:29:26.660
And for this class, I want to add a simple method

463
00:29:26.660 --> 00:29:31.660
that allows code log, that allows passing a Message

464
00:29:32.940 --> 00:29:36.780
and using the Logger, it should know how to log.

465
00:29:38.620 --> 00:29:42.500
Now I immediately see that the compiler is not happy

466
00:29:42.500 --> 00:29:45.140
because there's no Logger type.

467
00:29:47.460 --> 00:29:52.460
Of course I can fix this by using import Logger.h

468
00:29:52.460 --> 00:29:56.380
import Logger.h and everything will be fine.

469
00:29:57.620 --> 00:30:02.620
But as we said, this import will actually be replaced

470
00:30:04.860 --> 00:30:08.900
by the pre-compiler with all the contents of myLogger.h

471
00:30:09.900 --> 00:30:12.180
and I might not need these details

472
00:30:12.180 --> 00:30:15.420
because I just wanna pass a Logger instance.

473
00:30:15.420 --> 00:30:18.980
So what I can do instead is use a forward declaration

474
00:30:18.980 --> 00:30:23.980
at class Logger, compiler is still happy.

475
00:30:26.940 --> 00:30:29.780
And I know some of you are thinking,

476
00:30:29.780 --> 00:30:32.740
yeah, but you didn't add the body of the function.

477
00:30:32.740 --> 00:30:33.580
Let's do that.

478
00:30:37.260 --> 00:30:42.260
So I'll add the body and I'll call the method log.

479
00:30:43.740 --> 00:30:46.500
We added on Logger previously.

480
00:30:46.500 --> 00:30:51.180
If I try to build, I get this Error

481
00:30:51.180 --> 00:30:54.500
which is saying Logger is a forward declaration.

482
00:30:55.900 --> 00:31:00.700
But in the case of the implementation File.m

483
00:31:00.700 --> 00:31:04.700
the compiler really needs to know how to resolve this symbol.

484
00:31:04.700 --> 00:31:09.700
So in this case of the.m File, I need to import the header.

485
00:31:09.700 --> 00:31:14.700
And now it works.

486
00:31:18.380 --> 00:31:23.380
So we've shown how to use at class forward declaration.

487
00:31:23.820 --> 00:31:27.180
There are other types of forward declarations

488
00:31:27.180 --> 00:31:30.980
which I wanna quickly show.

489
00:31:32.300 --> 00:31:34.820
So I'll go back to myLogger.h

490
00:31:34.820 --> 00:31:39.820
since this is the place where I want to stack my entities.

491
00:31:40.540 --> 00:31:45.540
And I'll add an empty Protocol called Logger Protocol.

492
00:31:47.580 --> 00:31:52.580
And if you recall, we added an enum definition

493
00:31:53.140 --> 00:31:58.140
inside the Logger.m and I wanna move this to the header.

494
00:31:58.140 --> 00:32:03.140
So exposing it to other files and back to myLogger manager.

495
00:32:11.220 --> 00:32:14.580
Before declaration for the Logger Protocol

496
00:32:14.580 --> 00:32:18.060
would be add Protocol Logger Protocol.

497
00:32:19.740 --> 00:32:23.860
And this would allow me to use a,

498
00:32:23.860 --> 00:32:28.860
it's like this, it's referencing the Logger Protocol.

499
00:32:34.540 --> 00:32:39.540
And I can also do a forward declaration for the nse enum.

500
00:32:39.540 --> 00:32:44.540
Do a forward declaration for the nse enum and I can pass.

501
00:33:02.820 --> 00:33:06.260
This is how you would use forward declarations.

502
00:33:06.260 --> 00:33:09.540
But there are some cases

503
00:33:09.540 --> 00:33:11.820
where a forward declaration does not work.

504
00:33:13.140 --> 00:33:18.140
And some of them are using NSOptions or in other cases,

505
00:33:19.020 --> 00:33:21.580
but I wanna show like the primary case

506
00:33:21.580 --> 00:33:23.900
where we need the import.

507
00:33:23.900 --> 00:33:26.340
And this is when we try to subclass.

508
00:33:26.340 --> 00:33:29.140
So I'll create a new CocoaTouch class

509
00:33:29.140 --> 00:33:30.900
and I'll call it File Logger.

510
00:33:30.900 --> 00:33:35.900
And I want my File Logger to expand or to subclass Logger.

511
00:33:45.220 --> 00:33:49.540
If I try to use my forward declaration here as before,

512
00:33:50.420 --> 00:33:55.420
I will get an Error because the compiler is not happy

513
00:33:55.420 --> 00:34:00.420
that we just forward declared the Logger class.

514
00:34:01.540 --> 00:34:05.460
Since it's subclassing, it really needs to know

515
00:34:05.460 --> 00:34:07.340
all the signatures, all the methods

516
00:34:07.340 --> 00:34:09.540
that are available on this class.

517
00:34:09.540 --> 00:34:11.140
So in this particular case,

518
00:34:11.140 --> 00:34:15.860
we have to import the Logger.h

519
00:34:17.540 --> 00:34:19.940
in the header File of the File Logger

520
00:34:19.940 --> 00:34:24.940
and now the compiler's happy.

521
00:34:29.780 --> 00:34:34.500
So we covered how Objective-C declarations

522
00:34:34.500 --> 00:34:37.060
used from other Objective-C files are found.

523
00:34:37.060 --> 00:34:40.900
And we have seen that there can be done

524
00:34:40.900 --> 00:34:44.980
through header files or through forward declarations.

525
00:34:44.980 --> 00:34:49.980
Now, let's take a look at how Swift does this.

526
00:34:57.380 --> 00:35:00.100
So I'll take a look at the SceneDelegate class

527
00:35:00.100 --> 00:35:02.060
inside the EssentialApp module.

528
00:35:04.380 --> 00:35:08.940
Let's take a look at this new Store init invocation.

529
00:35:11.580 --> 00:35:13.900
When compiling the SceneDelegate.Swift,

530
00:35:13.900 --> 00:35:16.020
the Swift compiler will look up the type

531
00:35:16.020 --> 00:35:19.980
of the new Store, initialize it, so it can check the call.

532
00:35:22.620 --> 00:35:25.580
The same lookup happens, for instance,

533
00:35:25.580 --> 00:35:29.860
when the compiler tries to resolve the static function

534
00:35:29.860 --> 00:35:33.380
feedComposedWith and these following parameters

535
00:35:33.380 --> 00:35:34.860
on the FeedUIComposer.

536
00:35:37.900 --> 00:35:42.580
But before it can do that, it needs to parse these files.

537
00:35:42.580 --> 00:35:47.580
So we'll Store.Swift File

538
00:35:48.660 --> 00:35:53.660
and the FeedUIComposer.Swift File

539
00:35:56.300 --> 00:35:59.140
and validate them to make sure that the declarations

540
00:35:59.140 --> 00:36:03.580
of the two functions we used in the SceneDelegate Swift

541
00:36:04.420 --> 00:36:05.420
are well formed.

542
00:36:06.500 --> 00:36:08.860
The Swift compiler is smart enough to only check

543
00:36:08.860 --> 00:36:12.260
the declarations of the involvement functions.

544
00:36:12.260 --> 00:36:15.860
So it still needs to do some work to process

545
00:36:15.860 --> 00:36:17.940
the interface parts of the File.

546
00:36:19.060 --> 00:36:21.620
What this means is unlike Clang,

547
00:36:21.620 --> 00:36:25.100
when compiling one Swift File, the Swift compiler parses

548
00:36:25.100 --> 00:36:27.860
all the other Swift files in that target

549
00:36:27.860 --> 00:36:29.780
to examine the parts that are relevant

550
00:36:29.780 --> 00:36:31.580
to the interfaces used.

551
00:36:34.660 --> 00:36:39.660
So to recap, the Swift compiler parses all the Swift files

552
00:36:39.660 --> 00:36:44.460
in a target to find declarations

553
00:36:44.460 --> 00:36:47.380
between Swift files from the same module.

554
00:36:51.220 --> 00:36:54.980
I mentioned the two files are in the same module

555
00:36:54.980 --> 00:36:58.820
because handling the case where we reference the Swift File

556
00:36:58.820 --> 00:37:00.460
from another module is a bit different.

557
00:37:00.460 --> 00:37:02.260
So let's see how that works.

558
00:37:04.300 --> 00:37:06.940
If we go back to our SceneDelegate,

559
00:37:06.940 --> 00:37:11.940
we, for instance, see that it uses the URLSession,

560
00:37:12.860 --> 00:37:16.340
HTTPClient type, which is defined

561
00:37:16.340 --> 00:37:19.300
in the EssentialFeed framework.

562
00:37:19.300 --> 00:37:20.500
So in another module.

563
00:37:25.540 --> 00:37:27.860
We mentioned modules and in Swift the module

564
00:37:27.860 --> 00:37:31.500
is a distributable unit of declarations.

565
00:37:31.500 --> 00:37:33.380
And to be able to use those declarations,

566
00:37:33.380 --> 00:37:37.300
you have to import the module.

567
00:37:37.300 --> 00:37:40.700
In this case, import EssentialFeed.

568
00:37:44.620 --> 00:37:48.260
And in Xcode, any Swift target produces a separate module,

569
00:37:48.260 --> 00:37:50.540
including your app target.

570
00:37:50.540 --> 00:37:55.540
This is why in your test Bundle, unit test Bundle,

571
00:37:58.900 --> 00:38:01.740
you have to import the app module

572
00:38:01.740 --> 00:38:04.300
so you can access its types.

573
00:38:08.100 --> 00:38:08.940
Like this.

574
00:38:11.860 --> 00:38:13.340
So when importing the module,

575
00:38:13.340 --> 00:38:17.060
the compiler deserializes a special Swift module File

576
00:38:17.060 --> 00:38:18.980
to check the types when you use them.

577
00:38:21.060 --> 00:38:23.100
I can show you how this looks.

578
00:38:26.460 --> 00:38:30.180
So we notice that next to the EssentialApp Bundle,

579
00:38:30.180 --> 00:38:33.500
we have the EssentialApp.swiftmodule folder.

580
00:38:35.580 --> 00:38:39.820
Inside this folder, there are files with multiple extensions,

581
00:38:39.820 --> 00:38:42.540
but we care about the Swift module files.

582
00:38:45.300 --> 00:38:50.260
These are serialized binary representation

583
00:38:50.260 --> 00:38:52.060
of the module's declarations.

584
00:38:53.340 --> 00:38:57.100
This includes public, internal, and private declarations

585
00:38:57.100 --> 00:39:00.380
since the internal and private ones are needed for Debugging.

586
00:39:05.460 --> 00:39:09.500
Back to Xcode, if you remember the setUp,

587
00:39:09.500 --> 00:39:12.460
you know that the EssentialApp target

588
00:39:12.460 --> 00:39:14.700
has a link binary with libraries,

589
00:39:14.700 --> 00:39:17.740
implicit dependency to the EssentialFeed framework.

590
00:39:19.140 --> 00:39:21.340
Because of that, Xcode knows to build

591
00:39:21.340 --> 00:39:24.700
the EssentialFeed target before the EssentialApp target.

592
00:39:24.700 --> 00:39:26.780
Now, Xcode uses some optimizations

593
00:39:26.780 --> 00:39:28.220
to allow building in parallel.

594
00:39:28.220 --> 00:39:31.580
So the EssentialApp will only wait for generating

595
00:39:31.580 --> 00:39:34.180
the interface of the EssentialFeed module,

596
00:39:34.180 --> 00:39:36.620
but not wait for the entire build.

597
00:39:36.620 --> 00:39:39.340
So this gives you some parallelization for free.

598
00:39:44.340 --> 00:39:45.540
Back to SceneDelegate.

599
00:39:49.380 --> 00:39:51.740
So to resolve this initializer,

600
00:39:51.740 --> 00:39:56.740
the URL, session, HTTPClient, initializer with the session,

601
00:39:56.740 --> 00:39:58.740
the Swift compiler uses the interface

602
00:39:58.740 --> 00:40:00.740
from the Swift module we just showed

603
00:40:01.620 --> 00:40:03.140
to resolve this declaration.

604
00:40:08.940 --> 00:40:12.140
So to recap, when finding Swift declarations

605
00:40:12.860 --> 00:40:16.140
from other Swift files from different modules,

606
00:40:16.140 --> 00:40:19.860
the Swift compiler relies on Swift modules.

607
00:40:19.860 --> 00:40:21.540
Swift modules.

608
00:40:28.420 --> 00:40:31.340
Now let's start the cross-reference.

609
00:40:31.340 --> 00:40:35.820
So first, finding Objective-C declarations used in Swift.

610
00:40:36.940 --> 00:40:39.900
This is crucial because most of the system frameworks

611
00:40:39.900 --> 00:40:41.580
are written in Objective-C,

612
00:40:42.620 --> 00:40:46.980
including the ones we import in almost all our files,

613
00:40:46.980 --> 00:40:50.340
like Foundation or UIKit.

614
00:40:53.460 --> 00:40:57.220
The Swift compiler embeds a large part of Clang

615
00:40:57.220 --> 00:40:59.660
inside of it and use it as a library

616
00:40:59.660 --> 00:41:02.300
to import Objective-C frameworks directly.

617
00:41:03.260 --> 00:41:06.740
So where do Objective-C declarations come from?

618
00:41:06.740 --> 00:41:08.740
The importer will look in headers

619
00:41:08.740 --> 00:41:10.820
depending on the type of the target.

620
00:41:10.820 --> 00:41:12.380
And we have a few cases here.

621
00:41:12.380 --> 00:41:15.700
When importing an Objective-C framework from Swift,

622
00:41:17.860 --> 00:41:20.540
the importer finds declarations in the headers

623
00:41:20.540 --> 00:41:23.220
exposing Clang's module Map for the framework.

624
00:41:26.420 --> 00:41:31.420
Since we've explored the Foundation umbrella header before,

625
00:41:32.300 --> 00:41:33.900
let's see how the module Map

626
00:41:33.900 --> 00:41:36.100
for the Foundation framework looks like.

627
00:41:37.300 --> 00:41:40.300
I'll use the showing finder

628
00:41:40.300 --> 00:41:45.300
to go to disk at the path

629
00:41:47.300 --> 00:41:49.500
where the Foundation framework is found.

630
00:41:49.500 --> 00:41:53.540
And next to the headers folder, there's the module folder.

631
00:41:55.780 --> 00:41:58.220
And we can explore the module Map

632
00:41:58.220 --> 00:41:59.980
for the Foundation framework.

633
00:42:02.060 --> 00:42:04.460
It's a bit different than the one we just saw

634
00:42:04.460 --> 00:42:06.580
for the central Feed.

635
00:42:06.580 --> 00:42:08.660
It still defines a framework module,

636
00:42:08.660 --> 00:42:11.540
but this time it marks it at extern C

637
00:42:11.540 --> 00:42:14.420
and as a system framework.

638
00:42:14.420 --> 00:42:16.420
Again, there's an umbrella header,

639
00:42:16.420 --> 00:42:18.420
which is the Foundation header,

640
00:42:18.420 --> 00:42:20.460
the same exports and modules

641
00:42:20.460 --> 00:42:24.620
that make the system define a sub-module

642
00:42:24.620 --> 00:42:27.820
out of each header imported in umbrella header.

643
00:42:27.820 --> 00:42:43.820
And there's an interesting case where they exclude a header.

644
00:42:43.820 --> 00:42:50.820
So by having an umbrella header and a module Map,

645
00:42:50.820 --> 00:42:55.420
in Swift we can have concrete imports

646
00:42:55.420 --> 00:43:00.420
like Foundation.nsring or Foundation.nsray,

647
00:43:04.340 --> 00:43:06.140
the one we showed in Objective-C.

648
00:43:09.700 --> 00:43:13.300
So this was the importing Objective-C frameworks from Swift.

649
00:43:14.540 --> 00:43:18.660
Now let's see a case where a framework

650
00:43:18.660 --> 00:43:21.300
mixes Swift and Objective-C.

651
00:43:21.300 --> 00:43:24.260
And this happens to be the case

652
00:43:24.260 --> 00:43:25.940
for our EssentialFeed framework.

653
00:43:27.900 --> 00:43:30.780
So within a framework that mixes Swift and Objective-C,

654
00:43:30.780 --> 00:43:33.860
the importer finds declarations in the umbrella header.

655
00:43:35.060 --> 00:43:36.580
As you remember, this is the header

656
00:43:36.580 --> 00:43:38.580
that defines the public interface.

657
00:43:39.740 --> 00:43:41.260
In this way, the Swift code

658
00:43:41.260 --> 00:43:43.620
inside the EssentialFeed framework

659
00:43:43.620 --> 00:43:46.860
can call public Objective-C code in the same framework.

660
00:43:47.900 --> 00:43:52.420
Remember, we just created the EssentialFeed umbrella header

661
00:43:52.420 --> 00:43:54.420
for the EssentialFeed framework.

662
00:43:55.780 --> 00:43:58.820
Since it imports the Logger.h File,

663
00:43:58.820 --> 00:44:02.660
the Logger class is accessible from Swift.

664
00:44:03.660 --> 00:44:05.060
So as an exercise,

665
00:44:05.060 --> 00:44:07.980
if we go to the LocalFeedImageDataLoader

666
00:44:07.980 --> 00:44:12.980
and we want to maybe log before this do catch,

667
00:44:17.340 --> 00:44:20.660
we can say let Logger equals Logger.

668
00:44:20.660 --> 00:44:25.660
And we can invoke the log with Message Error.

669
00:44:28.540 --> 00:44:31.820
If we build everything is okay.

670
00:44:34.580 --> 00:44:39.580
Again, because the umbrella header EssentialFeed

671
00:44:40.180 --> 00:44:44.620
imports the header File that defines the Logger class.

672
00:44:47.020 --> 00:44:50.580
What's important here is this concept of an umbrella header

673
00:44:50.580 --> 00:44:52.980
exists for framework targets.

674
00:44:52.980 --> 00:44:57.300
It doesn't exist for app targets or unit test targets.

675
00:44:59.580 --> 00:45:01.940
They have something equivalent,

676
00:45:01.940 --> 00:45:03.940
which is called a bridging header.

677
00:45:06.380 --> 00:45:09.140
So within app or unit test targets,

678
00:45:09.140 --> 00:45:12.900
you can add imports to the targets bridging header

679
00:45:12.900 --> 00:45:15.940
to allow declarations from them to be called from Swift.

680
00:45:17.500 --> 00:45:20.100
This bridging header, which I just mentioned

681
00:45:20.100 --> 00:45:23.860
is just a header File that contains all the declarations

682
00:45:23.860 --> 00:45:27.260
or imports of entities, which we expose to Swift.

683
00:45:28.940 --> 00:45:29.940
As I mentioned,

684
00:45:29.940 --> 00:45:32.980
there are no bridging header for framework targets.

685
00:45:32.980 --> 00:45:36.460
So it's either one or the other, you can't mix it up.

686
00:45:39.140 --> 00:45:43.300
To see this in example, let's create one,

687
00:45:43.300 --> 00:45:48.060
but we'll do it through Xcode automatic mechanism.

688
00:45:48.060 --> 00:45:50.940
And I'll just add an Objective-C class

689
00:45:50.940 --> 00:45:54.140
to my EssentialApp target this time.

690
00:45:54.140 --> 00:45:58.060
Again, using the CocoaTouch class template.

691
00:45:58.060 --> 00:46:01.060
And I'll call this String helper and create.

692
00:46:05.500 --> 00:46:09.380
And you see that I got a prompt from Xcode.

693
00:46:09.380 --> 00:46:12.580
Would you like to configure an Objective-C bridging header?

694
00:46:12.580 --> 00:46:16.900
This is because this was my first Objective-C File

695
00:46:16.900 --> 00:46:19.540
being added to the EssentialApp target.

696
00:46:19.540 --> 00:46:23.700
And Xcode knows that to share this code to Swift,

697
00:46:23.700 --> 00:46:27.620
I need to create a bridging header.

698
00:46:27.620 --> 00:46:28.660
So let's create one.

699
00:46:33.380 --> 00:46:36.660
If I look into this EssentialApp bridging header File,

700
00:46:36.660 --> 00:46:40.340
Xcode automatically created, I see it's empty.

701
00:46:40.340 --> 00:46:42.940
Xcode uses like a template for this name,

702
00:46:42.940 --> 00:46:46.140
but we can use any name for the bridging header.

703
00:46:46.140 --> 00:46:48.580
The important thing is there is a build setting

704
00:46:53.860 --> 00:46:55.820
called Objective-C bridging header

705
00:46:58.340 --> 00:47:03.340
or Swift OPC bridging header that contains this name.

706
00:47:03.900 --> 00:47:06.100
So if I rename my File,

707
00:47:06.100 --> 00:47:09.620
I just need to make sure I also update my build setting.

708
00:47:12.380 --> 00:47:14.260
So back to our String helper

709
00:47:14.260 --> 00:47:17.500
and we'll see how the bridging header works in a minute.

710
00:47:19.100 --> 00:47:22.260
I want to add some methods to this class

711
00:47:24.380 --> 00:47:26.780
and I will copy paste them.

712
00:47:31.660 --> 00:47:33.340
So I added three methods.

713
00:47:33.340 --> 00:47:35.420
The first method does nothing.

714
00:47:35.420 --> 00:47:36.940
It's called do nothing,

715
00:47:36.940 --> 00:47:39.340
takes no parameters and returns Void.

716
00:47:39.340 --> 00:47:42.580
The second method returns Void,

717
00:47:42.580 --> 00:47:46.940
returns Void, takes a String and a CG point.

718
00:47:46.940 --> 00:47:49.940
And the third one will return a bool

719
00:47:49.940 --> 00:47:52.980
and takes a String parameter

720
00:47:52.980 --> 00:47:57.860
and uses the NSR double pointer convention

721
00:47:57.860 --> 00:47:59.100
to return an Error.

722
00:48:01.740 --> 00:48:06.740
For the imports, I use the specific header CGGeometry,

723
00:48:07.140 --> 00:48:10.100
which is where CG point is defined.

724
00:48:10.100 --> 00:48:13.340
I also want to add the bodies

725
00:48:13.340 --> 00:48:15.620
so the implementation of the String helper.

726
00:48:21.220 --> 00:48:24.980
So it imports the String helper.age.

727
00:48:24.980 --> 00:48:29.980
We also import a specific header we need from UIKit

728
00:48:30.660 --> 00:48:32.220
to drawString at point.

729
00:48:35.140 --> 00:48:38.580
And this is just an example.

730
00:48:38.580 --> 00:48:43.340
And the body of the validate String method

731
00:48:43.340 --> 00:48:46.500
checks if the length is greater than zero,

732
00:48:46.500 --> 00:48:49.140
we turn true, otherwise we draw an Error.

733
00:48:49.140 --> 00:48:51.380
It is a pretty simple case.

734
00:48:54.860 --> 00:48:58.340
Note that there's a convention in Objective-C

735
00:48:58.340 --> 00:49:01.500
that a function like this that returns bool

736
00:49:01.500 --> 00:49:03.420
and can also return an Error

737
00:49:04.540 --> 00:49:06.580
is considered to have failed,

738
00:49:06.580 --> 00:49:10.860
even if we return false, but provide no Error.

739
00:49:10.860 --> 00:49:12.660
So that's also an Error case.

740
00:49:12.660 --> 00:49:15.820
This is important when you use these methods from Swift.

741
00:49:20.580 --> 00:49:23.260
So let's see if this compiles.

742
00:49:23.260 --> 00:49:25.340
It should compile fine, okay.

743
00:49:27.900 --> 00:49:30.860
Now remember, I didn't add String helper

744
00:49:30.860 --> 00:49:33.180
to my bridging header.

745
00:49:33.180 --> 00:49:36.620
So if I go to SceneDelegate and try to use it,

746
00:49:44.940 --> 00:49:46.540
I'll get a failure.

747
00:49:48.020 --> 00:49:51.340
So I need to go into the bridging header

748
00:49:51.340 --> 00:49:54.780
and explicitly import my String helper.

749
00:49:54.780 --> 00:49:59.780
And now this works.

750
00:50:04.860 --> 00:50:09.860
So I can use String helper.validate String, any String.

751
00:50:11.700 --> 00:50:13.900
And since it will draw,

752
00:50:13.900 --> 00:50:18.900
so we will try question mark to get the compiler to be happy.

753
00:50:19.860 --> 00:50:21.060
And now it works.

754
00:50:21.060 --> 00:50:26.060
So to recap, finding Objective-C declarations

755
00:50:31.300 --> 00:50:32.700
that are used from Swift,

756
00:50:33.940 --> 00:50:37.380
realize on the fact that Swift C or the Swift compiler

757
00:50:37.380 --> 00:50:39.300
embeds Clang as a library.

758
00:50:39.300 --> 00:50:42.700
And this allows importing Objective-C frameworks directly.

759
00:50:43.820 --> 00:50:47.060
We use module maps to partially import these modules

760
00:50:47.060 --> 00:50:50.260
to resolve Objective-C declarations

761
00:50:50.260 --> 00:50:52.140
inside the same framework target.

762
00:50:52.140 --> 00:50:54.700
The compiler uses the umbrella header

763
00:50:54.700 --> 00:50:57.700
while for add target, it uses the bridging header.

764
00:51:04.340 --> 00:51:07.340
When the importer brings in declarations

765
00:51:07.340 --> 00:51:09.820
from Objective-C to Swift,

766
00:51:09.820 --> 00:51:12.620
it often changes them to make them more Swift.

767
00:51:12.620 --> 00:51:17.620
Let's see some examples.

768
00:51:20.100 --> 00:51:25.100
I'll go to the NSManage object context header from CoreData

769
00:51:26.940 --> 00:51:31.940
and try to use the system, but I get a no selection.

770
00:51:32.100 --> 00:51:37.100
So I will reopen my project.

771
00:51:39.660 --> 00:51:41.180
And this time it works.

772
00:51:41.180 --> 00:51:46.180
And I'll use the Generated Interface assistant.

773
00:51:51.380 --> 00:51:55.500
And the method I wanna look at is executeRequest.

774
00:51:58.660 --> 00:52:00.420
And to find its correspondent,

775
00:52:00.420 --> 00:52:02.580
I will use NSPersistentStoreResult,

776
00:52:02.580 --> 00:52:05.580
which is the only function that uses this.

777
00:52:05.580 --> 00:52:10.580
So you can see on the left, the header File

778
00:52:10.860 --> 00:52:15.860
of the NSManage object context from the CoreData.

779
00:52:16.420 --> 00:52:19.420
And on the right, using the Generated Interface assistant,

780
00:52:19.420 --> 00:52:24.420
we basically simulate how Swift would generate

781
00:52:29.980 --> 00:52:32.980
a header File for this object.

782
00:52:32.980 --> 00:52:36.860
A header File for this header

783
00:52:36.860 --> 00:52:39.820
and make it available into Swift.

784
00:52:42.540 --> 00:52:44.300
We notice a few things.

785
00:52:44.300 --> 00:52:47.420
First of all, the method name was executeRequest.

786
00:52:47.420 --> 00:52:51.220
Now the request part was removed

787
00:52:51.220 --> 00:52:52.780
and it's only called execute.

788
00:52:53.660 --> 00:52:56.260
It has no name for the first parameter,

789
00:52:56.260 --> 00:53:00.580
but the request variable name to be used

790
00:53:00.580 --> 00:53:03.260
inside the method definition.

791
00:53:03.260 --> 00:53:06.660
Also, since it was following the convention

792
00:53:06.660 --> 00:53:09.900
like the last parameter is an Error,

793
00:53:09.900 --> 00:53:11.740
double pointer NSError,

794
00:53:12.700 --> 00:53:16.940
it got converted to a throws method.

795
00:53:16.940 --> 00:53:19.780
And you see no NSError parameter nowhere.

796
00:53:21.700 --> 00:53:25.100
And it returns an NSPersistentStoreResult.

797
00:53:25.100 --> 00:53:30.100
Another example, inside the nstring.h,

798
00:53:35.340 --> 00:53:40.340
let's look at the component separated by String API.

799
00:53:50.820 --> 00:53:52.700
And it's a component.

800
00:53:52.700 --> 00:53:55.780
And it's equivalent.

801
00:53:55.780 --> 00:53:59.500
So the Objective-C original API

802
00:53:59.500 --> 00:54:01.780
was called component separated by String.

803
00:54:03.700 --> 00:54:07.140
The Swift Generated Interface name

804
00:54:07.140 --> 00:54:12.140
is components separated by and a separator parameter.

805
00:54:18.020 --> 00:54:22.620
If you're familiar with Objective-C Generics,

806
00:54:22.620 --> 00:54:25.100
we'll explain them in a second.

807
00:54:25.100 --> 00:54:29.660
You see that we have an NSArray of type and a String here.

808
00:54:29.660 --> 00:54:30.860
So an Array of strings.

809
00:54:30.860 --> 00:54:34.060
So that's why the return type of this function

810
00:54:34.060 --> 00:54:35.340
is an Array of String.

811
00:54:40.420 --> 00:54:41.580
Another example

812
00:54:41.580 --> 00:54:46.580
is inside the nstring drawing.h,

813
00:55:00.060 --> 00:55:02.140
we do these two APIs.

814
00:55:02.140 --> 00:55:04.380
So draw at point and draw in rect.

815
00:55:06.100 --> 00:55:10.500
For them, the words point and rect

816
00:55:10.500 --> 00:55:11.660
will be removed.

817
00:55:12.660 --> 00:55:14.380
So let's find them.

818
00:55:16.420 --> 00:55:20.180
Those are the corresponding extension

819
00:55:20.180 --> 00:55:21.820
on an asset with a String.

820
00:55:22.900 --> 00:55:25.060
And you see the first method.

821
00:55:25.060 --> 00:55:28.180
So draw at point was converted to draw at

822
00:55:28.180 --> 00:55:42.700
and draw in rect was converted to draw in.

823
00:55:42.700 --> 00:55:44.980
So these words are omitted in Swift

824
00:55:44.980 --> 00:55:48.500
when the method is imported at simply draw at or draw in.

825
00:55:49.860 --> 00:55:51.380
So how does this work?

826
00:55:51.380 --> 00:55:53.500
Now, you might be surprised to know

827
00:55:53.500 --> 00:55:55.220
that the compiler contains a List

828
00:55:55.220 --> 00:55:58.340
of common English verbs and prepositions.

829
00:55:58.340 --> 00:56:01.300
Because it is just a hard-coded List,

830
00:56:01.300 --> 00:56:04.420
it's limited to only a handful of words.

831
00:56:04.420 --> 00:56:08.500
Furthermore, in order to match Swift's naming conventions,

832
00:56:08.500 --> 00:56:10.700
the importer will also rename methods

833
00:56:10.700 --> 00:56:13.220
to remove words based on the part of speech.

834
00:56:21.780 --> 00:56:24.580
So to check how your Objective-C headers

835
00:56:24.580 --> 00:56:26.220
will be imported into Swift,

836
00:56:26.220 --> 00:56:28.780
you can use the Generated Interface assistant

837
00:56:28.780 --> 00:56:29.740
we just showed.

838
00:56:32.100 --> 00:56:34.660
Let's take a look at our String helper.

839
00:56:43.060 --> 00:56:47.340
So we see it converted all three functions.

840
00:56:49.260 --> 00:56:51.860
So do nothing to do nothing.

841
00:56:51.860 --> 00:56:53.700
This is pretty straightforward.

842
00:56:53.700 --> 00:56:57.780
drawString at point got converted to draw at

843
00:56:59.220 --> 00:57:02.860
and validate String that returned the bool

844
00:57:02.860 --> 00:57:07.300
and had an NSR double pointer

845
00:57:07.300 --> 00:57:10.060
is now validate with the String parameter

846
00:57:10.060 --> 00:57:11.740
and function that throws.

847
00:57:13.700 --> 00:57:18.020
Another interesting thing is the import to core graphics,

848
00:57:18.020 --> 00:57:21.620
CGGeometry.h was replaced by import

849
00:57:21.620 --> 00:57:23.820
core-graphics.CGGeometry.

850
00:57:27.420 --> 00:57:30.220
Now let's see how we can make these APIs

851
00:57:30.220 --> 00:57:31.460
a bit more Swifty.

852
00:57:32.820 --> 00:57:35.860
First of all, we can use NSSwiftName

853
00:57:35.860 --> 00:57:39.900
to control the resulting Swift API name.

854
00:57:43.420 --> 00:57:46.180
So if I want to, let's say,

855
00:57:46.180 --> 00:57:51.820
rename my do nothing method to nothing,

856
00:57:51.820 --> 00:57:55.460
I will add an NSSwiftName and the nothing name.

857
00:57:58.900 --> 00:58:02.060
This is how I refresh the Generated Interface.

858
00:58:03.820 --> 00:58:06.500
And I see that the new name of the function

859
00:58:06.500 --> 00:58:09.900
is nothing as instruct.

860
00:58:09.900 --> 00:58:13.100
But since this function really does nothing,

861
00:58:13.100 --> 00:58:16.780
I want to exclude it from the Generated Interface entirely.

862
00:58:17.700 --> 00:58:20.420
To do this, I can use another attribute

863
00:58:20.420 --> 00:58:23.340
which is NSSwiftUnavailable,

864
00:58:23.340 --> 00:58:25.300
which takes a String parameter

865
00:58:27.180 --> 00:58:29.460
like the information on why this is unavailable.

866
00:58:29.460 --> 00:58:31.820
And let's say it does nothing.

867
00:58:36.220 --> 00:58:39.700
So again, I'll refresh the interface.

868
00:58:39.700 --> 00:58:42.540
Sorry.

869
00:58:46.100 --> 00:58:51.020
And this time, the function has disappeared entirely.

870
00:58:51.020 --> 00:58:54.140
So I only get to draw and validate functions.

871
00:58:54.140 --> 00:58:56.580
This is how NSSwiftUnavailable works.

872
00:59:00.540 --> 00:59:04.460
Now let's take a more deep look

873
00:59:04.460 --> 00:59:07.940
at the parameters of my functions.

874
00:59:07.940 --> 00:59:11.460
So by default, all Objective-C parameters

875
00:59:11.460 --> 00:59:15.500
are imported into Swift as implicitly-unwrapped optionals,

876
00:59:15.500 --> 00:59:16.860
like these strings here.

877
00:59:19.500 --> 00:59:20.820
But I think this is wrong

878
00:59:21.700 --> 00:59:24.300
because an NSString pointer

879
00:59:25.260 --> 00:59:28.260
can either point to a String value or to Null.

880
00:59:29.780 --> 00:59:31.620
But if it's set to Null

881
00:59:31.620 --> 00:59:36.620
and we try to unwrap this implicitly-unwrapped optional,

882
00:59:36.620 --> 00:59:37.900
the app will Crash.

883
00:59:40.380 --> 00:59:42.420
So to help the compilers,

884
00:59:42.420 --> 00:59:46.500
Objective-C added annotations like non-Null or nullable

885
00:59:46.500 --> 00:59:48.940
to explicitly mark which parameters can be Null

886
00:59:48.940 --> 00:59:49.780
and which can't.

887
00:59:53.900 --> 00:59:55.020
I'll mark this

888
00:59:59.980 --> 01:00:03.900
String parameter of drawString as non-Null and build.

889
01:00:03.900 --> 01:00:08.900
And what I can see is I got a few warnings.

890
01:00:12.860 --> 01:00:16.140
This is because once we add one annotation,

891
01:00:16.140 --> 01:00:17.980
one nullable annotation to a File,

892
01:00:17.980 --> 01:00:20.460
the compiler considers we have opted in

893
01:00:20.460 --> 01:00:22.700
to use nullable annotations in that File.

894
01:00:22.700 --> 01:00:25.860
So we must provide this information

895
01:00:25.860 --> 01:00:29.860
for all of the parameters of our methods.

896
01:00:29.860 --> 01:00:34.860
So let's add the remaining annotations.

897
01:00:44.140 --> 01:00:46.100
I marked the second one,

898
01:00:46.940 --> 01:00:49.860
the String pass to validate String as nullable

899
01:00:49.860 --> 01:00:54.060
because we know we can process empty,

900
01:00:54.940 --> 01:00:56.820
so new values there.

901
01:00:56.820 --> 01:01:00.980
And I mark with underscore nullable these pointers.

902
01:01:07.540 --> 01:01:12.540
Build and let's look at the new interface.

903
01:01:16.580 --> 01:01:20.340
Now, the String parameter for the draw function

904
01:01:21.500 --> 01:01:24.860
got changed from a implicitly-unwrapped optional String

905
01:01:24.860 --> 01:01:26.180
to a String.

906
01:01:26.180 --> 01:01:27.860
This is exactly what we want.

907
01:01:29.020 --> 01:01:30.700
For the validate function,

908
01:01:30.700 --> 01:01:32.780
since we marked it as nullable,

909
01:01:32.780 --> 01:01:35.460
the type is now String optional.

910
01:01:40.100 --> 01:01:43.220
But especially in large files,

911
01:01:43.220 --> 01:01:47.340
adding all these annotations can take up a lot of space.

912
01:01:47.340 --> 01:01:52.340
So Apple added some convenience instructions.

913
01:01:52.340 --> 01:01:57.340
These are the nsassume non-new begin and non-Null end

914
01:02:01.220 --> 01:02:03.380
you saw in the File templates

915
01:02:03.380 --> 01:02:05.260
created automatically by Xcode.

916
01:02:06.740 --> 01:02:10.340
Between these, Xcode will consider

917
01:02:10.340 --> 01:02:15.020
all the variables are non-Null.

918
01:02:15.020 --> 01:02:26.020
So you just need to mark the ones which are nullable.

919
01:02:26.100 --> 01:02:30.660
I'll build and regenerate the interface.

920
01:02:33.740 --> 01:02:35.700
And the interface should be the same.

921
01:02:35.700 --> 01:02:51.700
Yes.

922
01:02:51.780 --> 01:02:54.340
Another way we can help the compiler generate

923
01:02:54.340 --> 01:02:57.140
correct interfaces for Swift is to use

924
01:02:59.860 --> 01:03:04.620
three types of instructions.

925
01:03:04.620 --> 01:03:08.980
NSEnum, NSOptions, and NSErrorEnum.

926
01:03:08.980 --> 01:03:13.980
I'll just copy-paste an example in our header File.

927
01:03:16.820 --> 01:03:21.820
So first we type deft MyEnum type,

928
01:03:21.900 --> 01:03:26.460
which uses NSUnsignedIntegers as backing.

929
01:03:27.500 --> 01:03:32.340
With three cases, MyOptions, NSOption type,

930
01:03:32.340 --> 01:03:37.340
also backed by unsigned integers with zero, one or two options.

931
01:03:37.780 --> 01:03:42.780
And an NSErrorEnum called MyError

932
01:03:44.940 --> 01:03:46.540
with two specific Errors.

933
01:03:51.140 --> 01:03:53.460
Let's see how the interfaces look for this.

934
01:03:53.460 --> 01:03:58.460
First, we see a SwiftEnum using unsigned Int

935
01:04:05.420 --> 01:04:07.980
with all the cases, case zero, one and two.

936
01:04:08.900 --> 01:04:13.900
Then a struct called MyOptions conforming to option set

937
01:04:14.180 --> 01:04:16.660
with initializer taking the raw value

938
01:04:16.660 --> 01:04:21.500
and only the option one and option two static vars

939
01:04:21.500 --> 01:04:24.580
because option zero is the default one.

940
01:04:24.580 --> 01:04:28.700
And the MyError struct is even more complex.

941
01:04:28.700 --> 01:04:32.260
It has an initializer that takes an NSError.

942
01:04:32.260 --> 01:04:37.260
It has an embedded enum code with the specific Error codes

943
01:04:38.220 --> 01:04:43.220
and some static vars for the specific Errors.

944
01:04:43.220 --> 01:04:48.220
So we should prefer these to regular C-style enums.

945
01:04:55.460 --> 01:05:00.460
Another thing which we can do to help the Swift compiler

946
01:05:01.660 --> 01:05:06.660
is following this convention of functions

947
01:05:07.700 --> 01:05:11.700
that return a bool and return a Null.

948
01:05:11.700 --> 01:05:16.700
That return a bool and return like user in out

949
01:05:19.020 --> 01:05:21.780
double pointer NSError as the last parameter

950
01:05:21.780 --> 01:05:25.900
and it's called Error because the Swift generated header

951
01:05:25.900 --> 01:05:29.020
can detect that that's actually a throwing method.

952
01:05:29.020 --> 01:05:34.020
So it can transform that to a Swift API that throws.

953
01:05:34.020 --> 01:05:39.020
And finally, the Objective-C Generics we mentioned.

954
01:05:43.300 --> 01:05:48.300
So I'll paste in my String helper some functions.

955
01:05:52.900 --> 01:05:54.700
The first function is called MyArray

956
01:05:54.700 --> 01:05:57.700
and just returns a simple NSArray.

957
01:05:57.700 --> 01:06:02.220
The second one uses the Generics so that it returns

958
01:06:02.220 --> 01:06:06.580
uses the Generics so it's an explicit NSArray

959
01:06:06.580 --> 01:06:10.220
using NSString pointer as the backing type.

960
01:06:10.220 --> 01:06:13.940
Then a simple NSDictionary and again an NSDictionary

961
01:06:13.940 --> 01:06:17.580
where the key is an NSString and the value is an NSNumber.

962
01:06:17.580 --> 01:06:30.580
And we'll see how the interface for these looks like.

963
01:06:33.660 --> 01:06:34.500
Oops.

964
01:06:35.660 --> 01:06:40.340
So the MyArray function returns an Array of any

965
01:06:40.340 --> 01:06:43.980
as the MyDictionary returns AnyHashable to any.

966
01:06:43.980 --> 01:06:47.540
This is because NSArray and NSDictionary

967
01:06:47.540 --> 01:06:49.500
don't provide any information about the type

968
01:06:49.500 --> 01:06:52.700
so it basically can be anything.

969
01:06:52.700 --> 01:06:54.740
But if we use these Generics,

970
01:06:56.660 --> 01:07:00.820
we really help the compiler resolve the types.

971
01:07:00.820 --> 01:07:05.820
So MyArray of strings, here it returns an Array of String

972
01:07:06.100 --> 01:07:09.380
and the same for the dictionary,

973
01:07:09.380 --> 01:07:14.140
an explicit hash from String to NSNumber.

974
01:07:14.140 --> 01:07:16.660
These Generics are nowhere near as powerful

975
01:07:16.660 --> 01:07:19.540
as the Swift ones, but they do help,

976
01:07:19.540 --> 01:07:22.420
especially the Swift compiler importing the declarations.

977
01:07:22.420 --> 01:07:26.100
But even the Clang compiler is pretty smart about it.

978
01:07:33.620 --> 01:07:38.060
So to recap, we've seen the implicit transformations

979
01:07:38.060 --> 01:07:40.660
applied by the compiler to Objective-C headers

980
01:07:40.660 --> 01:07:42.100
when importing them to Swift.

981
01:07:43.500 --> 01:07:47.020
Also, we've seen ways to make our Swift interface

982
01:07:47.020 --> 01:07:52.020
friendlier or more Swift-y by giving explicit Swift API names,

983
01:07:52.900 --> 01:07:56.140
hiding APIs from Swift when they're not useful,

984
01:07:56.140 --> 01:07:58.660
providing nullable or non-Null annotations

985
01:07:58.660 --> 01:08:01.500
to avoid implicit and unwrapped optionals

986
01:08:02.860 --> 01:08:07.540
using NSEnum, NSOptions and NSErrorEnum

987
01:08:07.540 --> 01:08:09.580
and using the Objective-C generics

988
01:08:09.580 --> 01:08:12.860
to let the Swift compiler know exactly which types to use.

989
01:08:19.820 --> 01:08:23.820
So that's how Swift imports Objective-C,

990
01:08:23.820 --> 01:08:25.580
but what about the other direction?

991
01:08:25.580 --> 01:08:28.340
How does Objective-C import Swift?

992
01:08:28.340 --> 01:08:31.540
Well, the answer is pretty simple.

993
01:08:31.540 --> 01:08:34.580
Swift generates a header for each target

994
01:08:34.580 --> 01:08:37.180
that you can pound import.

995
01:08:37.180 --> 01:08:41.740
This header follows the convention

996
01:08:41.740 --> 01:08:45.100
of the targetName dash Swift point H.

997
01:08:48.540 --> 01:08:52.020
I'll go to the SceneDelegate class,

998
01:08:53.500 --> 01:08:56.980
Swift class in the EssentialApp target

999
01:08:56.980 --> 01:09:00.060
and using the Generated Interface.

1000
01:09:00.940 --> 01:09:03.660
So the Generated Interface assistant

1001
01:09:03.660 --> 01:09:07.540
now shows my EssentialApp dash Swift header.

1002
01:09:10.420 --> 01:09:13.940
And there's a lot of macros and instructions here,

1003
01:09:13.940 --> 01:09:16.420
but if we scroll to the end,

1004
01:09:16.420 --> 01:09:18.460
we'll get to the part that's important.

1005
01:09:20.220 --> 01:09:21.580
Let's see how this works.

1006
01:09:22.620 --> 01:09:26.700
The compiler will generate these Objective-C declarations

1007
01:09:27.900 --> 01:09:32.180
for the Swift classes that extend any subject

1008
01:09:32.180 --> 01:09:35.420
and for the methods marked with add of C.

1009
01:09:38.820 --> 01:09:40.980
For apps and unit test targets,

1010
01:09:40.980 --> 01:09:42.660
the generated header will include

1011
01:09:42.660 --> 01:09:44.780
both public and internal declarations.

1012
01:09:44.780 --> 01:09:46.860
This allows you to use internal Swift

1013
01:09:46.860 --> 01:09:49.740
from the Objective-C parts of your app.

1014
01:09:49.740 --> 01:09:52.100
Using the Generated Interface assistant,

1015
01:09:52.100 --> 01:09:54.620
like we are already doing,

1016
01:09:54.620 --> 01:09:56.580
we can see the generated Swift interface

1017
01:09:56.580 --> 01:09:58.420
for the EssentialApp target.

1018
01:09:59.940 --> 01:10:01.900
And we notice two entities,

1019
01:10:01.900 --> 01:10:04.340
the AppDelegate and the SceneDelegate.

1020
01:10:06.740 --> 01:10:11.740
This is because these are the only NSObject subclasses

1021
01:10:12.140 --> 01:10:16.940
because UI-responder is actually a subclass of NSObject.

1022
01:10:20.100 --> 01:10:23.420
And their definition.

1023
01:10:23.420 --> 01:10:30.180
But if we go to, let's say, the URLSessionHTTPClient,

1024
01:10:32.420 --> 01:10:36.220
Swift File that's a part of our EssentialFeed framework

1025
01:10:37.220 --> 01:10:40.460
and try to look at the EssentialFeed.Swift,

1026
01:10:40.460 --> 01:10:42.860
we'll see that it has no definitions

1027
01:10:42.860 --> 01:10:47.860
besides the macros automatically included by the compiler.

1028
01:10:47.860 --> 01:10:52.860
This is because there are no entities in our EssentialFeed

1029
01:10:54.020 --> 01:10:56.660
that are exposed to Objective-C.

1030
01:10:56.660 --> 01:10:59.580
But as an experiment to see how this works,

1031
01:10:59.580 --> 01:11:02.540
we can make the URLSessionHTTPClient

1032
01:11:02.540 --> 01:11:05.740
a subclass of NSObject.

1033
01:11:05.740 --> 01:11:10.020
And we can also mark this in public initializer

1034
01:11:10.900 --> 01:11:15.580
with the add Objective-C mark.

1035
01:11:15.580 --> 01:11:20.580
If we build, the Swift Generated Interface is regenerated.

1036
01:11:22.180 --> 01:11:27.180
So now we can see that it contains the interface

1037
01:11:28.380 --> 01:11:31.300
for the URLSessionHTTPClient.

1038
01:11:31.300 --> 01:11:34.140
And the Swift name is interesting

1039
01:11:34.140 --> 01:11:37.980
because it's a mangled variation

1040
01:11:37.980 --> 01:11:40.060
containing the name of the framework,

1041
01:11:40.060 --> 01:11:45.060
which is EssentialFeed in the name of the class.

1042
01:11:47.540 --> 01:11:49.620
This prevents conflicts at runtime

1043
01:11:49.620 --> 01:11:52.780
when two modules define a class with the same name.

1044
01:11:52.780 --> 01:11:56.220
Since Objective-C has no namespaces like Swift,

1045
01:11:56.220 --> 01:11:59.380
all the entities belong to a global namespace,

1046
01:11:59.380 --> 01:12:01.620
so collisions are likely to happen.

1047
01:12:02.740 --> 01:12:06.980
The mangling the Swift Generated Interface does prevents that.

1048
01:12:06.980 --> 01:12:11.980
You can tell the Swift compiler

1049
01:12:13.300 --> 01:12:16.180
to use a different Objective-C name,

1050
01:12:16.180 --> 01:12:20.180
but passing that name with obc.

1051
01:12:27.940 --> 01:12:32.940
And now, even the Swift name is also URLSessionHTTPClient.

1052
01:12:32.940 --> 01:12:35.420
But if you do this, you're responsible

1053
01:12:35.420 --> 01:12:37.420
for making sure the names don't conflict.

1054
01:12:50.780 --> 01:12:55.780
So to use this Swift interface in this class,

1055
01:12:57.180 --> 01:13:00.180
we need to create a new class.

1056
01:13:00.180 --> 01:13:03.180
And if we want to use this Swift interface

1057
01:13:03.180 --> 01:13:07.700
in this Swift interface into an Objective-C header,

1058
01:13:07.700 --> 01:13:11.980
we can go to one of our Objective-C files.

1059
01:13:13.020 --> 01:13:16.980
Over here, I can use the import essential,

1060
01:13:18.980 --> 01:13:23.980
yes, EssentialFeed, yeah, it works.

1061
01:13:23.980 --> 01:13:28.980
So here, I can use my URLHTTPSession type.

1062
01:13:33.580 --> 01:13:34.820
Client equals.

1063
01:13:43.780 --> 01:13:45.780
It only exposes this initializer,

1064
01:13:45.780 --> 01:13:47.940
so that's the way to use it.

1065
01:13:47.940 --> 01:13:51.940
So to recap, finding Swift declarations

1066
01:13:51.940 --> 01:13:53.780
that are used from Objective-C

1067
01:13:53.780 --> 01:13:56.180
is done through the Swift generated header.

1068
01:13:59.700 --> 01:14:03.220
An important note here is never import

1069
01:14:03.220 --> 01:14:06.420
your Swift generated header inside the umbrella header,

1070
01:14:06.420 --> 01:14:09.820
because this creates a circular dependency.

1071
01:14:09.820 --> 01:14:12.820
So if you want to use Swift generated header,

1072
01:14:12.820 --> 01:14:15.820
you need to import your Swift generated header

1073
01:14:15.820 --> 01:14:17.980
in a circular dependency.

1074
01:14:17.980 --> 01:14:21.260
It's something that Apple really recommends we don't do.

1075
01:14:26.540 --> 01:14:30.900
And finally, let's talk a bit about

1076
01:14:30.900 --> 01:14:32.740
how to harness the power of Swift,

1077
01:14:32.740 --> 01:14:35.580
even when mixing it with Objective-C.

1078
01:14:37.900 --> 01:14:41.660
So if you've mixed Swift and Objective-C

1079
01:14:41.660 --> 01:14:43.620
into the same project,

1080
01:14:43.620 --> 01:14:46.900
you probably noticed that making your Swift code

1081
01:14:46.900 --> 01:14:48.740
accessible from Objective-C

1082
01:14:48.740 --> 01:14:51.220
requires limiting the Swift features

1083
01:14:51.220 --> 01:14:53.020
that you can use in that Swift code.

1084
01:14:54.140 --> 01:14:56.300
Using the following Swift features

1085
01:14:56.300 --> 01:14:58.660
will make your code not accessible

1086
01:14:58.660 --> 01:15:02.340
or limitedly accessible in Objective-C.

1087
01:15:02.340 --> 01:15:04.580
The use of generics, tuples,

1088
01:15:04.580 --> 01:15:07.780
enums with associated values, structs,

1089
01:15:09.140 --> 01:15:11.700
top level functions or global variables,

1090
01:15:11.700 --> 01:15:15.020
type aliases, nested types and more.

1091
01:15:18.580 --> 01:15:21.700
So in practice, this means that you can't really use

1092
01:15:21.700 --> 01:15:23.500
all the power that Swift offers you,

1093
01:15:23.500 --> 01:15:26.420
since you most probably have to share that Swift code

1094
01:15:26.420 --> 01:15:28.380
with your Objective-C layer.

1095
01:15:28.380 --> 01:15:30.860
And that leads to suboptimal Swift code.

1096
01:15:32.740 --> 01:15:35.500
If your objective is to gradually migrate

1097
01:15:35.500 --> 01:15:38.900
from Objective-C code base to a Swift one,

1098
01:15:38.900 --> 01:15:41.420
writing new code in Swift with these limitations

1099
01:15:41.420 --> 01:15:44.420
will lead to Swift code that is suboptimal.

1100
01:15:45.580 --> 01:15:48.220
And most of your types will be classes

1101
01:15:48.220 --> 01:15:49.860
which inherit from any subject

1102
01:15:49.860 --> 01:15:52.820
and all the enums are in-based.

1103
01:15:52.820 --> 01:15:55.340
So you probably want to rewrite that code

1104
01:15:55.340 --> 01:15:56.740
in the Future as well.

1105
01:15:58.340 --> 01:15:59.980
Let's introduce a Strategy

1106
01:15:59.980 --> 01:16:03.100
by which you can still write your new code in Swift,

1107
01:16:03.100 --> 01:16:05.180
taking advantage of all the new features

1108
01:16:05.180 --> 01:16:06.700
Swift has to offer,

1109
01:16:06.700 --> 01:16:08.860
while preserving a layer of compatibility

1110
01:16:08.860 --> 01:16:13.100
with Objective-C code.

1111
01:16:13.100 --> 01:16:18.100
The idea is to reduce the points of intersection to a mean.

1112
01:16:19.780 --> 01:16:22.380
Try having subsystems like modules,

1113
01:16:22.380 --> 01:16:25.580
features or components written using the same language

1114
01:16:25.580 --> 01:16:27.100
instead of going back and forth

1115
01:16:27.100 --> 01:16:28.900
between Swift and Objective-C.

1116
01:16:32.780 --> 01:16:36.500
If such a system, subsystem is written in Swift

1117
01:16:36.500 --> 01:16:39.580
and needs to be accessed from Objective-C,

1118
01:16:39.580 --> 01:16:41.820
only the subsystem interface

1119
01:16:41.820 --> 01:16:45.380
needs to be accessible from Objective-C.

1120
01:16:45.380 --> 01:16:48.060
So for that, we can write a wrapper in Swift

1121
01:16:48.060 --> 01:16:51.580
that follows the Objective-C limitations we talked about,

1122
01:16:51.580 --> 01:16:55.180
while all the other files in the subsystem

1123
01:16:55.180 --> 01:16:58.060
can continue to use the Swift features.

1124
01:17:00.940 --> 01:17:04.580
Also, writing these wrappers is only temporary.

1125
01:17:04.580 --> 01:17:06.780
And once you've rewritten all the clients

1126
01:17:06.780 --> 01:17:09.260
that use that subsystem in Swift,

1127
01:17:09.260 --> 01:17:10.660
you can remove them.

1128
01:17:12.780 --> 01:17:17.780
And the remaining will be Swifty types and code.

1129
01:17:18.900 --> 01:17:21.100
Now let's see some example.

1130
01:17:21.100 --> 01:17:32.100
Let's add a new Swift File and we'll call it a timer.

1131
01:17:38.780 --> 01:17:41.500
So our timer class is pretty simple.

1132
01:17:41.500 --> 01:17:43.860
It has an enum that can be now

1133
01:17:43.860 --> 01:17:47.300
or later with an associated Date

1134
01:17:47.300 --> 01:17:52.300
and an execute function that takes one of these time enums

1135
01:17:53.100 --> 01:17:57.540
and execute a callback now if the enum case is now

1136
01:17:57.540 --> 01:18:02.540
or later at the Date using this patch async after.

1137
01:18:02.900 --> 01:18:03.740
Pretty simple.

1138
01:18:04.620 --> 01:18:07.660
This is not code I recommend you use in production,

1139
01:18:07.660 --> 01:18:10.180
but it works as an exercise.

1140
01:18:11.980 --> 01:18:14.700
The only real limitation we have on this class

1141
01:18:14.700 --> 01:18:18.020
is the fact that the subclass is NSObject,

1142
01:18:18.020 --> 01:18:20.380
but that's easy to remove in the Future.

1143
01:18:21.220 --> 01:18:26.140
Other than that, we can use these enum

1144
01:18:26.140 --> 01:18:27.940
with associated values inside

1145
01:18:29.300 --> 01:18:34.300
and other entities like mentioned features.

1146
01:18:35.980 --> 01:18:40.980
And then we have the extension for the Objective-C axis

1147
01:18:40.980 --> 01:18:45.980
where we expose a function marked with Objective-C

1148
01:18:49.540 --> 01:18:52.980
for each of the cases of the enum.

1149
01:18:52.980 --> 01:18:56.980
So one's execute now and the other's execute later.

1150
01:18:56.980 --> 01:18:59.380
And the execute later also takes a Date.

1151
01:19:01.420 --> 01:19:06.420
And behind doors, they both just call our Swift function.

1152
01:19:06.420 --> 01:19:11.420
Swift function, so that's the Objective-C wrapper.

1153
01:19:17.980 --> 01:19:22.980
Another example is you might want to define your value types

1154
01:19:26.100 --> 01:19:29.380
or Models as structs.

1155
01:19:31.420 --> 01:19:34.540
Such an example in our project

1156
01:19:34.540 --> 01:19:36.780
is the FeedImage struct.

1157
01:19:38.180 --> 01:19:41.700
So how can we expose a struct to Objective-C?

1158
01:19:42.660 --> 01:19:45.580
Well, we can't, but we can write a wrapper around it.

1159
01:19:48.620 --> 01:19:53.620
So I'll just quickly remind everyone

1160
01:19:55.100 --> 01:19:57.260
that the FeedImage has an ID, a description,

1161
01:19:57.260 --> 01:19:59.580
a location and a URL.

1162
01:19:59.580 --> 01:20:02.500
And we'll wrap this FeedImage

1163
01:20:02.500 --> 01:20:05.500
into a FeedImage underscore Objective-C,

1164
01:20:06.340 --> 01:20:11.340
which is a class because it needs to inherit from NSObject.

1165
01:20:11.540 --> 01:20:13.420
It uses the FeedImage inside.

1166
01:20:15.820 --> 01:20:19.420
And we've written some computed vars

1167
01:20:19.420 --> 01:20:23.540
that just return the value of the FeedImage.

1168
01:20:23.540 --> 01:20:27.100
There's a special case about the description variable

1169
01:20:27.100 --> 01:20:30.660
because NSObject already contains

1170
01:20:30.660 --> 01:20:33.340
a property called description.

1171
01:20:33.340 --> 01:20:35.580
So we had to override that.

1172
01:20:35.580 --> 01:20:37.940
And it has a slight different signature

1173
01:20:37.940 --> 01:20:41.660
where it returns a String instead of a String option.

1174
01:20:47.300 --> 01:20:50.500
So by wrapping the FeedImage into a FeedImage

1175
01:20:50.500 --> 01:20:53.820
of C class, we allow the Objective-C

1176
01:20:53.820 --> 01:20:58.380
to interact with the Objective-C code

1177
01:20:58.380 --> 01:21:01.020
and this NSObject subclass,

1178
01:21:01.020 --> 01:21:02.940
while all the Swift code we have

1179
01:21:02.940 --> 01:21:05.700
can still use our FeedImage struct.

1180
01:21:07.140 --> 01:21:10.140
If you have all the Swift types working with FeedImage

1181
01:21:10.140 --> 01:21:12.340
that needs to be accessed from Objective-C,

1182
01:21:13.540 --> 01:21:16.540
let's say the FeedCache,

1183
01:21:18.100 --> 01:21:20.540
you can apply the same technique as before.

1184
01:21:20.540 --> 01:21:24.900
So writing an extension and defining the API

1185
01:21:24.900 --> 01:21:29.820
that works with the wrapped FeedImage of C subclass

1186
01:21:29.820 --> 01:21:30.940
of NSObject.

1187
01:21:35.340 --> 01:21:40.340
So this extension looks something like this.

1188
01:21:43.700 --> 01:21:46.500
So we use the OPC prefix

1189
01:21:46.500 --> 01:21:51.300
and instead of taking an Array of FeedImage,

1190
01:21:51.300 --> 01:21:55.180
it takes an Array of FeedImage underscore OPC.

1191
01:21:55.180 --> 01:22:00.180
It also throws and we call the save Image,

1192
01:22:00.300 --> 01:22:02.260
the save method we already have

1193
01:22:02.260 --> 01:22:06.700
and we Map to get the FeedImages inside.

1194
01:22:12.460 --> 01:22:16.700
Another example would be,

1195
01:22:16.700 --> 01:22:21.700
we used to have a FeedLoader Protocol

1196
01:22:26.220 --> 01:22:28.020
inside our project.

1197
01:22:28.020 --> 01:22:32.860
It got removed when creating some,

1198
01:22:32.860 --> 01:22:35.300
like the final refactoring is doing generics.

1199
01:22:39.060 --> 01:22:40.620
But this was the signature.

1200
01:22:40.620 --> 01:22:42.860
So it had a Result type

1201
01:22:42.860 --> 01:22:47.620
that was either an Array of FeedImage or Error

1202
01:22:47.620 --> 01:22:49.540
and an API called load,

1203
01:22:49.540 --> 01:22:54.540
which is a async API and basically returns a Result.

1204
01:22:58.260 --> 01:23:03.260
Now, if we have a solid Objective-C implementation for it,

1205
01:23:06.300 --> 01:23:09.860
for convenience, I will still List it here as Swift,

1206
01:23:09.860 --> 01:23:12.580
but let's say this is Objective-C.

1207
01:23:15.580 --> 01:23:16.420
Then,

1208
01:23:23.660 --> 01:23:27.780
we can again write a Swift wrapper this time around it.

1209
01:23:27.780 --> 01:23:29.460
So it's the other way around.

1210
01:23:29.460 --> 01:23:31.620
If we have a solid Objective-C,

1211
01:23:31.620 --> 01:23:33.460
which we want to use to Swift,

1212
01:23:33.460 --> 01:23:38.060
we wrap it in a Swift object, Swift type.

1213
01:23:38.060 --> 01:23:41.540
Now, our Objective-C has some limitations.

1214
01:23:41.540 --> 01:23:43.540
It cannot use the Result type.

1215
01:23:43.540 --> 01:23:46.900
So it has to use two parameters,

1216
01:23:46.900 --> 01:23:50.340
an optional FeedImage Array and an optional Error.

1217
01:23:51.420 --> 01:23:54.580
While we know that we want to use the Result type,

1218
01:23:54.580 --> 01:23:57.460
which is either an Array or an Error.

1219
01:23:59.060 --> 01:24:03.860
So we wrap the RemoteFeedLoader of C

1220
01:24:03.860 --> 01:24:07.180
inside the RemoteFeedLoader class.

1221
01:24:07.180 --> 01:24:10.460
And inside the load function

1222
01:24:10.460 --> 01:24:14.860
that this time follows the FeedLoader Protocol,

1223
01:24:14.860 --> 01:24:18.820
we just Map over the load,

1224
01:24:18.820 --> 01:24:20.900
which can return two parameters.

1225
01:24:21.820 --> 01:24:24.860
And if we get an Error,

1226
01:24:24.860 --> 01:24:27.700
we call the Completion with the failure.

1227
01:24:27.700 --> 01:24:30.780
If we get a Feed, we call the Completion with success.

1228
01:24:30.780 --> 01:24:34.060
And because there's a state here,

1229
01:24:34.060 --> 01:24:36.220
which shouldn't be representable,

1230
01:24:36.220 --> 01:24:39.740
but is because of the combination of optionals,

1231
01:24:39.740 --> 01:24:44.380
we can have no Error and no Feed.

1232
01:24:44.380 --> 01:24:48.100
And in that case, we complete with the failure

1233
01:24:48.100 --> 01:24:50.580
and this unexpected Error struct.

1234
01:24:53.060 --> 01:24:58.060
So that's how I would suggest

1235
01:24:58.060 --> 01:25:03.060
you approach this problem of gradually migrating.

1236
01:25:08.980 --> 01:25:10.500
Thank you.

1237
01:25:10.500 --> 01:25:12.380
And if there are any questions,

1238
01:25:13.580 --> 01:25:17.140
Sarthak says, allow FeedImage or FeedImage of C.

1239
01:25:17.140 --> 01:25:22.140
Yes, it should be a FeedImage of C here, right?

1240
01:25:31.260 --> 01:25:36.260
Okay, hello, hi, so in FeedImage underscore Objective-C

1241
01:25:39.380 --> 01:25:42.700
in the class, you exposed a FeedImage.

1242
01:25:42.700 --> 01:25:44.140
So will it be okay?

1243
01:25:45.300 --> 01:25:46.460
There's a reason for it.

1244
01:25:46.460 --> 01:25:51.380
So like I said, this Objective-C wrappers are temporary.

1245
01:25:51.380 --> 01:25:56.380
We need this because in the FeedCache implementation,

1246
01:25:57.580 --> 01:26:01.220
we need to Map and to actually get the FeedImage.

1247
01:26:01.220 --> 01:26:04.340
So this is where we use this property.

1248
01:26:04.340 --> 01:26:06.100
That's why it's public.

1249
01:26:06.100 --> 01:26:09.940
You could hide this by just creating a new FeedImage.

1250
01:26:09.940 --> 01:26:12.860
So this will become private.

1251
01:26:12.860 --> 01:26:17.860
And then this cannot be accessed,

1252
01:26:18.260 --> 01:26:21.180
but we can create a new FeedImage.

1253
01:26:22.780 --> 01:26:27.780
And we have to pass $0.ID, $0.description.

1254
01:26:35.180 --> 01:26:37.460
So making it public will be an optimization

1255
01:26:37.460 --> 01:26:38.740
when bridging back.

1256
01:26:38.740 --> 01:26:41.420
So you don't need to instantiate a new object.

1257
01:26:41.420 --> 01:26:43.500
But if you don't want to expose it, that's fine as well.

1258
01:26:43.500 --> 01:26:45.060
We just create a new one.

1259
01:26:46.500 --> 01:26:51.500
So if there's no other questions, we can wrap it up.

1260
01:26:52.860 --> 01:26:55.140
Okay, thanks.

1261
01:26:55.140 --> 01:26:56.460
Thank you.

1262
01:26:56.460 --> 01:27:11.460
I'll see you next time.

