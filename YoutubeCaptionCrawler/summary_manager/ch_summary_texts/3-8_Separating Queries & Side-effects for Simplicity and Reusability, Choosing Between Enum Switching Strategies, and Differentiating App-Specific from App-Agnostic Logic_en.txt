1. 本課程首先介紹將從緩存用例取得負載分成兩部分的概念，將讀取與無效的邏輯分離。
2. 他們討論了一個過度擴展的用例導致違反Command Query Separation原則的情況，其中一個理應只是查詢的方法，實際上改變了系統的狀態。
3. Command Query Separation原則意味著要將查詢任務與改變系統狀態的命令分離。
4. 他們展示瞭如何透過創建新的用例來分離這些任務的步驟。
5. 新的 'validate feed cache' 用例的主要過程是執行 "validate cache command"。它從緩存中取得數據並驗證緩存是否少於7天舊。
6. 如果有檢索錯誤，則表示緩存中的饋送數據無效，因此會被刪除。
7. 如果找到饋送，但緩存已經過期，也會被刪除。
8. 強調用例會因應需求變化和關於系統的新訊息而變動。
9. 他們提醒大家在建立過程中定期編譯、運行並測試程式碼的必要性，以確保功能並修復錯誤。
10. 他們也討論瞭如何將load方法中的副作用移到新的 'validate cache'方法，以及如何管理和防止可能在生產過程中崩潰。
11. 如果緩存有效（少於7天舊），則不採取任何行動，但如果緩存無效或超過7天舊，就會被刪除。
12. 講座轉向修改程式碼；突出重複，並討論使用更高範疇的共享輔助器以降低程式碼複雜度。
13. 最終，他們成功將功能分離為擴展，並使LocalFeedLoader符合FeedLoader協議。
14. 講座以討論下一步結束，該步驟將是將驗證政策從用例提取到新的模型類型。